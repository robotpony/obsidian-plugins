/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SpaceCommandPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/TodoScanner.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
var LOGO_PREFIX = "\u2423\u2318";
var PLUGIN_TAGS = /* @__PURE__ */ new Set([
  "#todo",
  "#todos",
  "#todone",
  "#todones",
  "#idea",
  "#ideas",
  "#ideation",
  "#principle",
  "#principles"
]);
var PRIORITY_TAG_MAP = {
  "#focus": 0,
  "#today": 1,
  "#p0": 2,
  "#p1": 3,
  "#p2": 4,
  "#p3": 5,
  "#p4": 6,
  "#future": 7
};
function getTagColourInfo(tag, projectColourMap) {
  var _a;
  const normalizedTag = tag.toLowerCase();
  if (PLUGIN_TAGS.has(normalizedTag)) {
    return { type: "plugin", priority: 3 };
  }
  if (PRIORITY_TAG_MAP[normalizedTag] !== void 0) {
    return { type: "priority", priority: PRIORITY_TAG_MAP[normalizedTag] };
  }
  const colourIndex = (_a = projectColourMap == null ? void 0 : projectColourMap.get(normalizedTag)) != null ? _a : 4;
  return { type: "project", priority: colourIndex };
}
function showNotice(message, timeout) {
  const fragment = document.createDocumentFragment();
  const logo = document.createElement("span");
  logo.className = "space-command-logo";
  logo.textContent = LOGO_PREFIX;
  fragment.appendChild(logo);
  fragment.appendChild(document.createTextNode(" " + message));
  return new import_obsidian.Notice(fragment, timeout);
}
function formatDate(date, format) {
  return (0, import_obsidian.moment)(date).format(format);
}
function getPriorityValue(tags) {
  if (tags.includes("#focus"))
    return 0;
  if (tags.includes("#today"))
    return 1;
  if (tags.includes("#p0"))
    return 2;
  if (tags.includes("#p1"))
    return 3;
  if (tags.includes("#p2"))
    return 4;
  if (tags.includes("#p3"))
    return 6;
  if (tags.includes("#p4"))
    return 7;
  if (tags.includes("#future") || tags.includes("#snooze") || tags.includes("#snoozed"))
    return 8;
  return 5;
}
function getTagCount(tags) {
  const systemTags = /* @__PURE__ */ new Set([
    "#todo",
    "#todos",
    "#todone",
    "#todones",
    "#idea",
    "#ideas",
    "#ideation",
    "#principle",
    "#principles",
    "#focus",
    "#today",
    "#future",
    "#snooze",
    "#snoozed",
    "#p0",
    "#p1",
    "#p2",
    "#p3",
    "#p4"
  ]);
  return tags.filter((tag) => !systemTags.has(tag)).length;
}
function compareTodoItems(a, b) {
  const aHasFocus = a.tags.includes("#focus");
  const bHasFocus = b.tags.includes("#focus");
  if (aHasFocus && !bHasFocus)
    return -1;
  if (!aHasFocus && bHasFocus)
    return 1;
  const priorityDiff = getPriorityValue(a.tags) - getPriorityValue(b.tags);
  if (priorityDiff !== 0)
    return priorityDiff;
  const tagCountDiff = getTagCount(b.tags) - getTagCount(a.tags);
  return tagCountDiff;
}
function extractTags(text) {
  const textWithoutCode = text.replace(/`[^`]*`/g, "");
  const tagRegex = /#[\w-]+/g;
  return textWithoutCode.match(tagRegex) || [];
}
function filenameToTag(basename) {
  return "#" + basename.toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]/g, "").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
function hasCheckboxFormat(text) {
  return /^-\s*\[[ x]\]/i.test(text.trim());
}
function isCheckboxChecked(text) {
  return /^-\s*\[x\]/i.test(text.trim());
}
function markCheckboxComplete(text) {
  return text.replace(/^(-\s*\[)[ ](\])/, "$1x$2");
}
function replaceTodoWithTodone(text, date) {
  if (text.includes("#todos")) {
    return text.replace(/#todos\b/, `#todones @${date}`);
  }
  return text.replace(/#todo\b/, `#todone @${date}`);
}
function replaceTodoneWithTodo(text) {
  if (text.includes("#todones")) {
    let result2 = text.replace(/#todones\s+@\d{4}-\d{2}-\d{2}/, "#todos");
    result2 = result2.replace(/#todones\b/, "#todos");
    return result2;
  }
  let result = text.replace(/#todone\s+@\d{4}-\d{2}-\d{2}/, "#todo");
  result = result.replace(/#todone\b/, "#todo");
  return result;
}
function markCheckboxIncomplete(text) {
  return text.replace(/^(-\s*\[)x(\])/i, "$1 $2");
}
function removeIdeaTag(text) {
  return text.replace(/#idea(?:s|tion)?\b\s*/, "").trim();
}
function replaceIdeaWithTodo(text) {
  return text.replace(/#idea(?:s|tion)?\b/, "#todo");
}
function renderTextWithTags(text, container, mutedTags = [], projectColourMap) {
  const tagRegex = /(#[\w-]+)/g;
  let lastIndex = 0;
  let match;
  while ((match = tagRegex.exec(text)) !== null) {
    if (match.index > lastIndex) {
      container.appendText(text.substring(lastIndex, match.index));
    }
    const tag = match[1];
    const colourInfo = getTagColourInfo(tag, projectColourMap);
    let tagEl;
    if (mutedTags.length > 0 && mutedTags.includes(tag)) {
      tagEl = container.createEl("span", {
        cls: "tag muted-pill",
        text: tag
      });
    } else {
      tagEl = container.createEl("span", {
        cls: "tag",
        text: tag
      });
    }
    tagEl.dataset.scTagType = colourInfo.type;
    tagEl.dataset.scPriority = colourInfo.priority.toString();
    lastIndex = tagRegex.lastIndex;
  }
  if (lastIndex < text.length) {
    container.appendText(text.substring(lastIndex));
  }
}
function highlightLine(editor, line) {
  const lineText = editor.getLine(line);
  const lineLength = lineText.length;
  editor.setSelection({ line, ch: 0 }, { line, ch: lineLength });
  setTimeout(() => {
    editor.setCursor({ line, ch: 0 });
  }, 1500);
}
function extractCompletionDate(text) {
  const match = text.match(/@(\d{4}-\d{2}-\d{2})/);
  return match ? match[1] : null;
}
function compareByStatusAndDate(a, b) {
  const aIsComplete = a.itemType === "todone";
  const bIsComplete = b.itemType === "todone";
  if (!aIsComplete && bIsComplete)
    return -1;
  if (aIsComplete && !bIsComplete)
    return 1;
  if (!aIsComplete && !bIsComplete)
    return 0;
  const aDate = extractCompletionDate(a.text);
  const bDate = extractCompletionDate(b.text);
  if (aDate && !bDate)
    return -1;
  if (!aDate && bDate)
    return 1;
  if (aDate && bDate) {
    return bDate.localeCompare(aDate);
  }
  return 0;
}
function openFileAtLine(app, file, line) {
  const leaf = app.workspace.getLeaf(false);
  leaf.openFile(file, { active: true }).then(() => {
    const view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view == null ? void 0 : view.editor) {
      const editor = view.editor;
      editor.setCursor({ line, ch: 0 });
      editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
      highlightLine(editor, line);
    }
  });
}

// src/TodoScanner.ts
var TodoScanner = class extends import_obsidian2.Events {
  constructor(app) {
    super();
    this.todosCache = /* @__PURE__ */ new Map();
    this.todonesCache = /* @__PURE__ */ new Map();
    this.ideasCache = /* @__PURE__ */ new Map();
    this.principlesCache = /* @__PURE__ */ new Map();
    this.excludeFromTodones = /* @__PURE__ */ new Set();
    this.app = app;
    this.debouncedScanFile = (0, import_obsidian2.debounce)(
      (file) => this.scanFile(file),
      100,
      true
    );
  }
  setExcludeFromTodones(filePaths) {
    this.excludeFromTodones = new Set(filePaths);
  }
  async scanVault() {
    this.todosCache.clear();
    this.todonesCache.clear();
    this.ideasCache.clear();
    this.principlesCache.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      await this.scanFile(file);
    }
    this.trigger("todos-updated");
  }
  async scanFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const todos = [];
      const todones = [];
      const ideas = [];
      const principles = [];
      const linesToCleanup = [];
      const linesToSyncTodone = [];
      let inCodeBlock = false;
      let currentHeaderTodo = null;
      let currentHeaderIdea = null;
      let currentHeaderPrinciple = null;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim().startsWith("```")) {
          inCodeBlock = !inCodeBlock;
          continue;
        }
        if (inCodeBlock) {
          continue;
        }
        if (this.isInInlineCode(line)) {
          continue;
        }
        const tags = extractTags(line);
        const headerInfo = this.detectHeader(line);
        if (headerInfo) {
          if (currentHeaderTodo && headerInfo.level <= currentHeaderTodo.level) {
            currentHeaderTodo = null;
          }
          if (currentHeaderIdea && headerInfo.level <= currentHeaderIdea.level) {
            currentHeaderIdea = null;
          }
          if (currentHeaderPrinciple && headerInfo.level <= currentHeaderPrinciple.level) {
            currentHeaderPrinciple = null;
          }
        }
        if (headerInfo && (tags.includes("#todo") || tags.includes("#todos")) && !tags.includes("#todone") && !tags.includes("#todones")) {
          if (!this.hasContent(line))
            continue;
          const headerTodo = this.createTodoItem(file, i, line, tags, "todo");
          headerTodo.isHeader = true;
          headerTodo.headerLevel = headerInfo.level;
          headerTodo.childLineNumbers = [];
          todos.push(headerTodo);
          currentHeaderTodo = { lineNumber: i, level: headerInfo.level, todoItem: headerTodo };
          continue;
        }
        if (headerInfo && (tags.includes("#todone") || tags.includes("#todones"))) {
          if (!this.hasContent(line))
            continue;
          const headerTodone = this.createTodoItem(file, i, line, tags, "todone");
          headerTodone.isHeader = true;
          headerTodone.headerLevel = headerInfo.level;
          todones.push(headerTodone);
          currentHeaderTodo = null;
          continue;
        }
        if (currentHeaderTodo && this.isListItem(line)) {
          const hasIdeaTag = tags.includes("#idea") || tags.includes("#ideas") || tags.includes("#ideation");
          if (hasIdeaTag) {
            continue;
          }
          const hasPrincipleTag = tags.includes("#principle") || tags.includes("#principles");
          if (hasPrincipleTag) {
          } else {
            const isChecked = isCheckboxChecked(line);
            const hasTodoneTag = tags.includes("#todone");
            if (isChecked && !hasTodoneTag) {
              linesToSyncTodone.push(i);
              tags.push("#todone");
            }
            if (!this.hasContent(line))
              continue;
            const childItemType = tags.includes("#todone") ? "todone" : "todo";
            const childItem = this.createTodoItem(file, i, line, tags, childItemType);
            childItem.parentLineNumber = currentHeaderTodo.lineNumber;
            currentHeaderTodo.todoItem.childLineNumbers.push(i);
            if (tags.includes("#todone")) {
              todones.push(childItem);
            } else {
              todos.push(childItem);
            }
            continue;
          }
        }
        const hasTodo = tags.includes("#todo") || tags.includes("#todos");
        const hasTodone = tags.includes("#todone") || tags.includes("#todones");
        const hasIdea = tags.includes("#idea") || tags.includes("#ideas") || tags.includes("#ideation");
        const lineHasContent = this.hasContent(line);
        if (hasTodone && hasTodo) {
          linesToCleanup.push(i);
          if (lineHasContent)
            todones.push(this.createTodoItem(file, i, line, tags, "todone"));
        } else if (hasTodo && !hasIdea) {
          if (lineHasContent)
            todos.push(this.createTodoItem(file, i, line, tags, "todo"));
        } else if (hasTodone) {
          if (lineHasContent)
            todones.push(this.createTodoItem(file, i, line, tags, "todone"));
        }
        if (tags.includes("#idea") || tags.includes("#ideas") || tags.includes("#ideation")) {
          if (!lineHasContent)
            continue;
          if (headerInfo) {
            const headerIdea = this.createTodoItem(file, i, line, tags, "idea");
            headerIdea.isHeader = true;
            headerIdea.headerLevel = headerInfo.level;
            headerIdea.childLineNumbers = [];
            ideas.push(headerIdea);
            currentHeaderIdea = { lineNumber: i, level: headerInfo.level, todoItem: headerIdea };
          } else {
            ideas.push(this.createTodoItem(file, i, line, tags, "idea"));
          }
        } else if (currentHeaderIdea && this.isListItem(line) && !tags.includes("#todo") && !tags.includes("#todone")) {
          if (!this.hasContent(line))
            continue;
          const childItem = this.createTodoItem(file, i, line, tags, "idea");
          childItem.parentLineNumber = currentHeaderIdea.lineNumber;
          currentHeaderIdea.todoItem.childLineNumbers.push(i);
          ideas.push(childItem);
        }
        if (tags.includes("#principle") || tags.includes("#principles")) {
          if (!lineHasContent)
            continue;
          if (headerInfo) {
            const headerPrinciple = this.createTodoItem(file, i, line, tags, "principle");
            headerPrinciple.isHeader = true;
            headerPrinciple.headerLevel = headerInfo.level;
            headerPrinciple.childLineNumbers = [];
            principles.push(headerPrinciple);
            currentHeaderPrinciple = { lineNumber: i, level: headerInfo.level, todoItem: headerPrinciple };
          } else {
            principles.push(this.createTodoItem(file, i, line, tags, "principle"));
          }
        } else if (currentHeaderPrinciple && this.isListItem(line) && !tags.includes("#todo") && !tags.includes("#todone") && !tags.includes("#idea") && !tags.includes("#ideas") && !tags.includes("#ideation")) {
          if (!this.hasContent(line))
            continue;
          const childItem = this.createTodoItem(file, i, line, tags, "principle");
          childItem.parentLineNumber = currentHeaderPrinciple.lineNumber;
          currentHeaderPrinciple.todoItem.childLineNumbers.push(i);
          principles.push(childItem);
        }
      }
      if (linesToCleanup.length > 0) {
        this.cleanupDuplicateTags(file, lines, linesToCleanup);
      }
      if (linesToSyncTodone.length > 0) {
        this.syncCheckedCheckboxes(file, lines, linesToSyncTodone);
      }
      if (todos.length > 0) {
        this.todosCache.set(file.path, todos);
      } else {
        this.todosCache.delete(file.path);
      }
      if (todones.length > 0) {
        this.todonesCache.set(file.path, todones);
      } else {
        this.todonesCache.delete(file.path);
      }
      if (ideas.length > 0) {
        this.ideasCache.set(file.path, ideas);
      } else {
        this.ideasCache.delete(file.path);
      }
      if (principles.length > 0) {
        this.principlesCache.set(file.path, principles);
      } else {
        this.principlesCache.delete(file.path);
      }
      this.trigger("todos-updated");
    } catch (error) {
      console.error(`Error scanning file ${file.path}:`, error);
    }
  }
  // Detect markdown header and return its level
  detectHeader(line) {
    const match = line.match(/^(#{1,6})\s+/);
    if (match) {
      return { level: match[1].length };
    }
    return null;
  }
  // Check if a line is a list item (bullet or numbered)
  isListItem(line) {
    return /^[\s]*[-*+]\s/.test(line) || /^[\s]*\d+\.\s/.test(line);
  }
  isInInlineCode(line) {
    const todoMatches = [...line.matchAll(/#todos?\b/g)];
    const todoneMatches = [...line.matchAll(/#todones?\b/g)];
    const ideaMatches = [...line.matchAll(/#idea(?:s|tion)?\b/g)];
    const principleMatches = [...line.matchAll(/#principles?\b/g)];
    const focusMatches = [...line.matchAll(/#focus\b/g)];
    const allMatches = [...todoMatches, ...todoneMatches, ...ideaMatches, ...principleMatches, ...focusMatches];
    if (allMatches.length === 0) {
      return false;
    }
    const backticks = [];
    for (let i = 0; i < line.length; i++) {
      if (line[i] === "`") {
        backticks.push(i);
      }
    }
    if (backticks.length % 2 !== 0) {
      return false;
    }
    for (const match of allMatches) {
      const pos = match.index;
      for (let i = 0; i < backticks.length; i += 2) {
        const start = backticks[i];
        const end = backticks[i + 1];
        if (pos > start && pos < end) {
          return true;
        }
      }
    }
    return false;
  }
  createTodoItem(file, lineNumber, text, tags, itemType) {
    var _a;
    return {
      file,
      filePath: file.path,
      folder: ((_a = file.parent) == null ? void 0 : _a.path) || "",
      lineNumber,
      text: text.trim(),
      hasCheckbox: hasCheckboxFormat(text),
      tags,
      dateCreated: file.stat.mtime,
      itemType,
      inferredFileTag: filenameToTag(file.basename)
    };
  }
  /**
   * Check if a line has meaningful content beyond tags and markers.
   * Returns false for empty items like "- [ ] #todo" or "- #idea  "
   */
  hasContent(text) {
    let content = text.trim();
    content = content.replace(/^#{1,6}\s*/, "");
    content = content.replace(/^[-*]\s*/, "");
    content = content.replace(/^\d+\.\s*/, "");
    content = content.replace(/^\[[ xX]?\]\s*/, "");
    content = content.replace(/#[\w-]+/g, "");
    content = content.replace(/@\d{4}-\d{2}-\d{2}/g, "");
    content = content.replace(/\^[\w-]+/g, "");
    return content.trim().length > 0;
  }
  getTodos() {
    const allTodos = [];
    for (const todos of this.todosCache.values()) {
      allTodos.push(...todos);
    }
    return allTodos.sort((a, b) => a.dateCreated - b.dateCreated);
  }
  getTodones(limit) {
    const allTodones = [];
    for (const [filePath, todones] of this.todonesCache.entries()) {
      if (this.excludeFromTodones.has(filePath)) {
        continue;
      }
      allTodones.push(...todones);
    }
    const sorted = allTodones.sort((a, b) => b.dateCreated - a.dateCreated);
    return limit ? sorted.slice(0, limit) : sorted;
  }
  getIdeas() {
    const allIdeas = [];
    for (const ideas of this.ideasCache.values()) {
      allIdeas.push(...ideas);
    }
    return allIdeas.sort((a, b) => a.dateCreated - b.dateCreated);
  }
  getPrinciples() {
    const allPrinciples = [];
    for (const principles of this.principlesCache.values()) {
      allPrinciples.push(...principles);
    }
    return allPrinciples.sort((a, b) => a.dateCreated - b.dateCreated);
  }
  watchFiles() {
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
      }
    });
    this.app.metadataCache.on("changed", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
      }
    });
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        this.todosCache.delete(file.path);
        this.todonesCache.delete(file.path);
        this.ideasCache.delete(file.path);
        this.principlesCache.delete(file.path);
        this.trigger("todos-updated");
      }
    });
    this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.todosCache.delete(oldPath);
        this.todonesCache.delete(oldPath);
        this.ideasCache.delete(oldPath);
        this.principlesCache.delete(oldPath);
        this.debouncedScanFile(file);
      }
    });
  }
  // Clean up lines that have both #todo/#todos and #todone/#todones (remove #todo/#todos)
  async cleanupDuplicateTags(file, lines, lineNumbers) {
    let modified = false;
    for (const lineNum of lineNumbers) {
      const newLine = lines[lineNum].replace(/#todos?\b\s*/g, "");
      if (newLine !== lines[lineNum]) {
        lines[lineNum] = newLine;
        modified = true;
      }
    }
    if (modified) {
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
  // Sync checked checkboxes (- [x]) by adding #todone tag with date
  async syncCheckedCheckboxes(file, lines, lineNumbers) {
    let modified = false;
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    for (const lineNum of lineNumbers) {
      const line = lines[lineNum];
      const newLine = line.trimEnd() + ` #todone @${today}`;
      if (newLine !== lines[lineNum]) {
        lines[lineNum] = newLine;
        modified = true;
      }
    }
    if (modified) {
      await this.app.vault.modify(file, lines.join("\n"));
    }
  }
};

// src/TodoProcessor.ts
var import_obsidian3 = require("obsidian");
var TodoProcessor = class {
  constructor(app, dateFormat = "YYYY-MM-DD") {
    this.app = app;
    this.dateFormat = dateFormat;
  }
  setScanner(scanner) {
    this.scanner = scanner;
  }
  setOnCompleteCallback(callback) {
    this.onComplete = callback;
  }
  async completeTodo(todo, todoneFilePath) {
    var _a;
    try {
      const today = formatDate(/* @__PURE__ */ new Date(), this.dateFormat);
      if (todo.isHeader && todo.childLineNumbers && todo.childLineNumbers.length > 0) {
        await this.completeChildrenLines(todo.file, todo.childLineNumbers, today);
      }
      await this.updateSourceFile(todo, today);
      await this.appendToTodoneFile(todo, todoneFilePath, today);
      if (this.scanner) {
        await this.scanner.scanFile(todo.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      const childCount = ((_a = todo.childLineNumbers) == null ? void 0 : _a.length) || 0;
      const message = childCount > 0 ? `TODO marked as complete! (including ${childCount} child item${childCount > 1 ? "s" : ""})` : "TODO marked as complete!";
      showNotice(message);
      return true;
    } catch (error) {
      console.error("Error completing TODO:", error);
      showNotice("Failed to complete TODO. See console for details.");
      return false;
    }
  }
  // Complete all child lines of a header TODO
  async completeChildrenLines(file, lineNumbers, date) {
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    for (const lineNum of lineNumbers) {
      if (lineNum >= lines.length)
        continue;
      let line = lines[lineNum];
      if (!line.includes("#todone")) {
        if (line.includes("#todo")) {
          line = replaceTodoWithTodone(line, date);
        } else {
          line = line.trimEnd() + ` #todone @${date}`;
        }
      }
      if (/\[\s*\]/.test(line)) {
        line = markCheckboxComplete(line);
      }
      lines[lineNum] = line;
    }
    await this.app.vault.modify(file, lines.join("\n"));
  }
  async uncompleteTodo(todo) {
    try {
      await this.revertSourceFile(todo);
      if (this.scanner) {
        await this.scanner.scanFile(todo.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice("TODO marked as incomplete!");
      return true;
    } catch (error) {
      console.error("Error uncompleting TODO:", error);
      showNotice("Failed to uncomplete TODO. See console for details.");
      return false;
    }
  }
  async revertSourceFile(todo) {
    const content = await this.app.vault.read(todo.file);
    const lines = content.split("\n");
    if (todo.lineNumber >= lines.length) {
      throw new Error(
        `Line number ${todo.lineNumber} out of bounds for file ${todo.filePath}`
      );
    }
    let updatedLine = lines[todo.lineNumber];
    if (!updatedLine.includes("#todone")) {
      throw new Error(
        `Line ${todo.lineNumber} in ${todo.filePath} no longer contains #todone tag. File may have been modified.`
      );
    }
    updatedLine = replaceTodoneWithTodo(updatedLine);
    if (todo.hasCheckbox) {
      updatedLine = markCheckboxIncomplete(updatedLine);
    }
    lines[todo.lineNumber] = updatedLine;
    await this.app.vault.modify(todo.file, lines.join("\n"));
  }
  async updateSourceFile(todo, date) {
    const content = await this.app.vault.read(todo.file);
    const lines = content.split("\n");
    if (todo.lineNumber >= lines.length) {
      throw new Error(
        `Line number ${todo.lineNumber} out of bounds for file ${todo.filePath}`
      );
    }
    let updatedLine = lines[todo.lineNumber];
    if (updatedLine.includes("#todone")) {
      throw new Error(
        `Line ${todo.lineNumber} in ${todo.filePath} already contains #todone tag. File may have been modified.`
      );
    }
    const isChildItem = todo.parentLineNumber !== void 0;
    if (updatedLine.includes("#todo")) {
      updatedLine = replaceTodoWithTodone(updatedLine, date);
    } else if (isChildItem) {
      updatedLine = updatedLine.trimEnd() + ` #todone @${date}`;
    } else {
      throw new Error(
        `Line ${todo.lineNumber} in ${todo.filePath} no longer contains #todo tag. File may have been modified.`
      );
    }
    if (todo.hasCheckbox) {
      updatedLine = markCheckboxComplete(updatedLine);
    }
    lines[todo.lineNumber] = updatedLine;
    await this.app.vault.modify(todo.file, lines.join("\n"));
  }
  async appendToTodoneFile(todo, todoneFilePath, date) {
    let todoneFile = this.app.vault.getAbstractFileByPath(todoneFilePath);
    if (!todoneFile) {
      const pathParts = todoneFilePath.split("/");
      const fileName = pathParts.pop();
      const folderPath = pathParts.join("/");
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      todoneFile = await this.app.vault.create(todoneFilePath, "");
    }
    if (!(todoneFile instanceof import_obsidian3.TFile)) {
      throw new Error(`${todoneFilePath} is not a file`);
    }
    let todoneText = todo.text;
    if (todo.isHeader) {
      todoneText = todoneText.replace(/^#{1,6}\s+/, "");
    }
    todoneText = replaceTodoWithTodone(todoneText, date);
    if (todo.hasCheckbox) {
      todoneText = markCheckboxComplete(todoneText);
    } else {
      todoneText = `- [x] ${todoneText}`;
    }
    const currentContent = await this.app.vault.read(todoneFile);
    const newContent = currentContent ? `${currentContent}
${todoneText}` : todoneText;
    await this.app.vault.modify(todoneFile, newContent);
  }
  async ensureFolderExists(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  async setPriorityTag(todo, newTag, addFocus = false) {
    try {
      const content = await this.app.vault.read(todo.file);
      const lines = content.split("\n");
      if (todo.lineNumber >= lines.length) {
        throw new Error(
          `Line number ${todo.lineNumber} out of bounds for file ${todo.filePath}`
        );
      }
      let line = lines[todo.lineNumber];
      const isChildItem = todo.parentLineNumber !== void 0;
      if (line.includes("#todone")) {
        throw new Error(
          `Line ${todo.lineNumber} in ${todo.filePath} contains #todone tag. Item is already completed.`
        );
      }
      if (!line.includes("#todo") && !isChildItem) {
        throw new Error(
          `Line ${todo.lineNumber} in ${todo.filePath} no longer contains #todo tag. File may have been modified.`
        );
      }
      line = line.replace(/#p[0-4]\b/g, "");
      line = line.replace(/#future\b/g, "");
      line = line.replace(/\s+/g, " ").trim();
      line = line + ` ${newTag}`;
      if (addFocus && !line.includes("#focus")) {
        line = line + " #focus";
      }
      lines[todo.lineNumber] = line;
      await this.app.vault.modify(todo.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(todo.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice(`Priority set to ${newTag}${addFocus ? " + #focus" : ""}`);
      return true;
    } catch (error) {
      console.error("Error setting priority:", error);
      showNotice("Failed to set priority. See console for details.");
      return false;
    }
  }
  async removeTag(todo, tag) {
    try {
      const content = await this.app.vault.read(todo.file);
      const lines = content.split("\n");
      if (todo.lineNumber >= lines.length) {
        throw new Error(
          `Line number ${todo.lineNumber} out of bounds for file ${todo.filePath}`
        );
      }
      let line = lines[todo.lineNumber];
      const tagPattern = new RegExp(`${tag}\\b\\s*`, "g");
      line = line.replace(tagPattern, "");
      line = line.replace(/\s+/g, " ").trim();
      lines[todo.lineNumber] = line;
      await this.app.vault.modify(todo.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(todo.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice(`Removed ${tag}`);
      return true;
    } catch (error) {
      console.error("Error removing tag:", error);
      showNotice("Failed to remove tag. See console for details.");
      return false;
    }
  }
  async addTag(item, tag) {
    try {
      const content = await this.app.vault.read(item.file);
      const lines = content.split("\n");
      if (item.lineNumber >= lines.length) {
        throw new Error(
          `Line number ${item.lineNumber} out of bounds for file ${item.filePath}`
        );
      }
      let line = lines[item.lineNumber];
      if (line.includes(tag)) {
        return true;
      }
      line = line.trimEnd() + ` ${tag}`;
      lines[item.lineNumber] = line;
      await this.app.vault.modify(item.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(item.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice(`Added ${tag}`);
      return true;
    } catch (error) {
      console.error("Error adding tag:", error);
      showNotice("Failed to add tag. See console for details.");
      return false;
    }
  }
  async completeIdea(idea) {
    try {
      const content = await this.app.vault.read(idea.file);
      const lines = content.split("\n");
      if (idea.lineNumber >= lines.length) {
        throw new Error(
          `Line number ${idea.lineNumber} out of bounds for file ${idea.filePath}`
        );
      }
      let line = lines[idea.lineNumber];
      if (!/#idea(?:s|tion)?\b/.test(line)) {
        throw new Error(
          `Line ${idea.lineNumber} in ${idea.filePath} no longer contains #idea/#ideas/#ideation tag. File may have been modified.`
        );
      }
      line = removeIdeaTag(line);
      lines[idea.lineNumber] = line;
      await this.app.vault.modify(idea.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(idea.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice("Idea completed!");
      return true;
    } catch (error) {
      console.error("Error completing idea:", error);
      showNotice("Failed to complete idea. See console for details.");
      return false;
    }
  }
  async convertIdeaToTodo(idea) {
    try {
      const content = await this.app.vault.read(idea.file);
      const lines = content.split("\n");
      if (idea.lineNumber >= lines.length) {
        throw new Error(
          `Line number ${idea.lineNumber} out of bounds for file ${idea.filePath}`
        );
      }
      let line = lines[idea.lineNumber];
      if (!/#idea(?:s|tion)?\b/.test(line)) {
        throw new Error(
          `Line ${idea.lineNumber} in ${idea.filePath} no longer contains #idea/#ideas/#ideation tag. File may have been modified.`
        );
      }
      line = replaceIdeaWithTodo(line);
      lines[idea.lineNumber] = line;
      await this.app.vault.modify(idea.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(idea.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice("Idea promoted to TODO!");
      return true;
    } catch (error) {
      console.error("Error converting idea to TODO:", error);
      showNotice("Failed to convert idea. See console for details.");
      return false;
    }
  }
  async addFocusToIdea(idea) {
    try {
      const content = await this.app.vault.read(idea.file);
      const lines = content.split("\n");
      if (idea.lineNumber >= lines.length) {
        throw new Error(
          `Line number ${idea.lineNumber} out of bounds for file ${idea.filePath}`
        );
      }
      let line = lines[idea.lineNumber];
      if (!line.includes("#focus")) {
        line = line.trimEnd() + " #focus";
      }
      lines[idea.lineNumber] = line;
      await this.app.vault.modify(idea.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(idea.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice("Idea focused!");
      return true;
    } catch (error) {
      console.error("Error focusing idea:", error);
      showNotice("Failed to focus idea. See console for details.");
      return false;
    }
  }
  // ========== Batch operations for project tags ==========
  /**
   * Focus all TODOs with the given tag: add #focus and increase priority
   */
  async focusAllWithTag(todos) {
    let success = 0;
    let failed = 0;
    for (const todo of todos) {
      if (todo.tags.includes("#focus"))
        continue;
      const currentPriority = this.getCurrentPriorityTag(todo);
      const newPriority = this.calculateFocusPriority(currentPriority);
      const result = await this.setPriorityTagSilent(todo, newPriority, true);
      if (result)
        success++;
      else
        failed++;
    }
    if (success > 0) {
      showNotice(`Focused ${success} TODO${success > 1 ? "s" : ""}`);
    }
    return { success, failed };
  }
  /**
   * Unfocus all TODOs with the given tag: remove #focus
   */
  async unfocusAllWithTag(todos) {
    let success = 0;
    let failed = 0;
    for (const todo of todos) {
      if (!todo.tags.includes("#focus"))
        continue;
      const result = await this.removeTagSilent(todo, "#focus");
      if (result)
        success++;
      else
        failed++;
    }
    if (success > 0) {
      showNotice(`Unfocused ${success} TODO${success > 1 ? "s" : ""}`);
    }
    return { success, failed };
  }
  /**
   * Later all TODOs with the given tag: decrease priority
   */
  async laterAllWithTag(todos) {
    let success = 0;
    let failed = 0;
    for (const todo of todos) {
      const currentPriority = this.getCurrentPriorityTag(todo);
      if (currentPriority && /^#p[3-4]$/.test(currentPriority))
        continue;
      const newPriority = this.calculateLaterPriority(currentPriority);
      const result = await this.setPriorityTagSilent(todo, newPriority, false);
      if (result)
        success++;
      else
        failed++;
    }
    if (success > 0) {
      showNotice(`Set ${success} TODO${success > 1 ? "s" : ""} to later`);
    }
    return { success, failed };
  }
  /**
   * Unlater all TODOs with the given tag: remove low priority tags
   */
  async unlaterAllWithTag(todos) {
    let success = 0;
    let failed = 0;
    for (const todo of todos) {
      const currentPriority = this.getCurrentPriorityTag(todo);
      if (!currentPriority || !/^#p[3-4]$/.test(currentPriority))
        continue;
      const result = await this.removeTagSilent(todo, currentPriority);
      if (result)
        success++;
      else
        failed++;
    }
    if (success > 0) {
      showNotice(`Unlatered ${success} TODO${success > 1 ? "s" : ""}`);
    }
    return { success, failed };
  }
  /**
   * Snooze all TODOs with the given tag: add #future
   */
  async snoozeAllWithTag(todos) {
    let success = 0;
    let failed = 0;
    for (const todo of todos) {
      if (todo.tags.includes("#future"))
        continue;
      const result = await this.setPriorityTagSilent(todo, "#future", false);
      if (result)
        success++;
      else
        failed++;
    }
    if (success > 0) {
      showNotice(`Snoozed ${success} TODO${success > 1 ? "s" : ""}`);
    }
    return { success, failed };
  }
  /**
   * Unsnooze all TODOs with the given tag: remove #future
   */
  async unsnoozeAllWithTag(todos) {
    let success = 0;
    let failed = 0;
    for (const todo of todos) {
      if (!todo.tags.includes("#future"))
        continue;
      const result = await this.removeTagSilent(todo, "#future");
      if (result)
        success++;
      else
        failed++;
    }
    if (success > 0) {
      showNotice(`Unsnoozed ${success} TODO${success > 1 ? "s" : ""}`);
    }
    return { success, failed };
  }
  // ========== Helper methods for batch operations ==========
  getCurrentPriorityTag(todo) {
    if (todo.tags.includes("#future"))
      return "#future";
    for (const tag of todo.tags) {
      if (/^#p[0-4]$/.test(tag))
        return tag;
    }
    return null;
  }
  calculateFocusPriority(currentPriority) {
    if (!currentPriority || currentPriority === "#future")
      return "#p0";
    const match = currentPriority.match(/^#p([0-4])$/);
    if (match) {
      const num = parseInt(match[1]);
      return num > 0 ? `#p${num - 1}` : "#p0";
    }
    return "#p0";
  }
  calculateLaterPriority(currentPriority) {
    if (!currentPriority || currentPriority === "#future")
      return "#p4";
    const match = currentPriority.match(/^#p([0-4])$/);
    if (match) {
      const num = parseInt(match[1]);
      return num < 4 ? `#p${num + 1}` : "#p4";
    }
    return "#p4";
  }
  /**
   * Set priority tag without showing notice (for batch operations)
   */
  async setPriorityTagSilent(todo, newTag, addFocus) {
    try {
      const content = await this.app.vault.read(todo.file);
      const lines = content.split("\n");
      if (todo.lineNumber >= lines.length)
        return false;
      let line = lines[todo.lineNumber];
      if (!line.includes("#todo") || line.includes("#todone"))
        return false;
      line = line.replace(/#p[0-4]\b/g, "");
      line = line.replace(/#future\b/g, "");
      line = line.replace(/\s+/g, " ").trim();
      line = line + ` ${newTag}`;
      if (addFocus && !line.includes("#focus")) {
        line = line + " #focus";
      }
      lines[todo.lineNumber] = line;
      await this.app.vault.modify(todo.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(todo.file);
      }
      return true;
    } catch (error) {
      console.error("Error setting priority:", error);
      return false;
    }
  }
  /**
   * Remove tag without showing notice (for batch operations)
   */
  async removeTagSilent(todo, tag) {
    try {
      const content = await this.app.vault.read(todo.file);
      const lines = content.split("\n");
      if (todo.lineNumber >= lines.length)
        return false;
      let line = lines[todo.lineNumber];
      const tagPattern = new RegExp(`${tag}\\b\\s*`, "g");
      line = line.replace(tagPattern, "");
      line = line.replace(/\s+/g, " ").trim();
      lines[todo.lineNumber] = line;
      await this.app.vault.modify(todo.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(todo.file);
      }
      return true;
    } catch (error) {
      console.error("Error removing tag:", error);
      return false;
    }
  }
  /**
   * Sort children of a header TODO by status (open first) then completion date (newest first).
   * Modifies the underlying markdown file to persist the sort order.
   */
  async sortHeaderChildren(headerTodo) {
    if (!headerTodo.isHeader || !headerTodo.childLineNumbers || headerTodo.childLineNumbers.length < 2) {
      return false;
    }
    try {
      const content = await this.app.vault.read(headerTodo.file);
      const lines = content.split("\n");
      const childLines = headerTodo.childLineNumbers.filter((lineNum) => lineNum >= 0 && lineNum < lines.length).map((lineNum) => ({
        lineNumber: lineNum,
        text: lines[lineNum],
        itemType: this.detectItemType(lines[lineNum])
      }));
      const sortedChildren = [...childLines].sort(compareByStatusAndDate);
      const orderChanged = sortedChildren.some(
        (child, idx) => child.lineNumber !== childLines[idx].lineNumber
      );
      if (!orderChanged) {
        showNotice("Items already sorted");
        return true;
      }
      const sortedLineContents = sortedChildren.map((c) => c.text);
      const sortedLineNumbers = [...headerTodo.childLineNumbers].sort((a, b) => a - b);
      for (let i = 0; i < sortedLineNumbers.length; i++) {
        lines[sortedLineNumbers[i]] = sortedLineContents[i];
      }
      await this.app.vault.modify(headerTodo.file, lines.join("\n"));
      if (this.scanner) {
        await this.scanner.scanFile(headerTodo.file);
      }
      if (this.onComplete) {
        this.onComplete();
      }
      showNotice("Sorted items");
      return true;
    } catch (error) {
      console.error("Error sorting header children:", error);
      showNotice("Failed to sort items");
      return false;
    }
  }
  /**
   * Detect if a line is complete (todone) or open (todo) based on its content.
   * For list items, checkbox state is the primary indicator.
   */
  detectItemType(text) {
    const trimmed = text.trim();
    if (/^-\s*\[x\]/i.test(trimmed))
      return "todone";
    if (/^-\s*\[\s*\]/.test(trimmed))
      return "todo";
    const textWithoutCode = text.replace(/`[^`]*`/g, "");
    if (/#todones?\b/.test(textWithoutCode))
      return "todone";
    return "todo";
  }
};

// src/ProjectManager.ts
var import_obsidian4 = require("obsidian");
var ProjectManager = class {
  constructor(app, scanner, projectsFolder, priorityTags, excludeFolders = []) {
    this.app = app;
    this.scanner = scanner;
    this.projectsFolder = projectsFolder;
    this.priorityTags = priorityTags;
    this.excludeFolders = excludeFolders;
  }
  getProjects() {
    const todos = this.scanner.getTodos();
    const projectMap = /* @__PURE__ */ new Map();
    for (const todo of todos) {
      const excludedTags = /* @__PURE__ */ new Set([
        "#todo",
        "#todos",
        "#todone",
        "#todones",
        "#idea",
        "#ideas",
        "#ideation",
        "#principle",
        "#principles",
        "#future",
        "#snooze",
        "#snoozed",
        "#focus",
        "#today",
        ...this.priorityTags
      ]);
      const explicitProjectTags = todo.tags.filter((tag) => !excludedTags.has(tag));
      let projectTags = explicitProjectTags;
      if (projectTags.length === 0 && todo.inferredFileTag) {
        const isInProjectsFolder = todo.folder.startsWith(this.projectsFolder.replace(/\/$/, ""));
        const isInExcludedFolder = this.excludeFolders.some(
          (folder) => todo.folder === folder || todo.folder.startsWith(folder + "/")
        );
        if (isInProjectsFolder && !isInExcludedFolder) {
          projectTags = [todo.inferredFileTag];
        }
      }
      const todoPriority = getPriorityValue(todo.tags);
      for (const tag of projectTags) {
        if (projectMap.has(tag)) {
          const project = projectMap.get(tag);
          project.count++;
          project.prioritySum += todoPriority;
          project.lastActivity = Math.max(
            project.lastActivity,
            todo.dateCreated
          );
          project.highestPriority = Math.min(
            project.highestPriority,
            todoPriority
          );
        } else {
          projectMap.set(tag, {
            tag,
            count: 1,
            lastActivity: todo.dateCreated,
            highestPriority: todoPriority,
            prioritySum: todoPriority,
            colourIndex: 4
            // default, will be calculated below
          });
        }
      }
    }
    const projects = [];
    for (const [, project] of projectMap) {
      const avgPriority = project.prioritySum / project.count;
      const colourIndex = Math.min(6, Math.round(avgPriority * 6 / 7));
      projects.push({
        tag: project.tag,
        count: project.count,
        lastActivity: project.lastActivity,
        highestPriority: project.highestPriority,
        colourIndex
      });
    }
    return projects;
  }
  getFocusProjects(limit) {
    const projects = this.getProjects();
    projects.sort((a, b) => {
      const aHasFocus = a.highestPriority === 0;
      const bHasFocus = b.highestPriority === 0;
      if (aHasFocus && !bHasFocus)
        return -1;
      if (!aHasFocus && bHasFocus)
        return 1;
      const priorityDiff = a.highestPriority - b.highestPriority;
      if (priorityDiff !== 0)
        return priorityDiff;
      return b.count - a.count;
    });
    if (limit !== void 0 && limit > 0) {
      return projects.slice(0, limit);
    }
    return projects;
  }
  getProjectFilePath(tag) {
    const filename = tag.replace(/^#/, "") + ".md";
    return this.projectsFolder + filename;
  }
  async getProjectFileInfo(tag) {
    var _a, _b;
    const filepath = this.getProjectFilePath(tag);
    const file = this.app.vault.getAbstractFileByPath(filepath);
    if (!(file instanceof import_obsidian4.TFile)) {
      return null;
    }
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    let startIndex = 0;
    if (((_a = lines[0]) == null ? void 0 : _a.trim()) === "---") {
      for (let i = 1; i < lines.length; i++) {
        if (((_b = lines[i]) == null ? void 0 : _b.trim()) === "---") {
          startIndex = i + 1;
          break;
        }
      }
    }
    const blocks = [];
    let currentBlock = "";
    let inCodeBlock = false;
    let inCallout = false;
    for (let i = startIndex; i < lines.length && blocks.length < 2; i++) {
      const line = lines[i];
      const trimmed = line.trim();
      if (trimmed.startsWith("```")) {
        inCodeBlock = !inCodeBlock;
        if (currentBlock) {
          blocks.push(currentBlock.trim());
          currentBlock = "";
          inCallout = false;
        }
        continue;
      }
      if (inCodeBlock) {
        continue;
      }
      if (trimmed.startsWith("#") && trimmed.match(/^#+\s/)) {
        if (currentBlock) {
          blocks.push(currentBlock.trim());
          currentBlock = "";
          inCallout = false;
        }
        continue;
      }
      if (trimmed === tag) {
        continue;
      }
      if (trimmed.match(/^\{\{.*\}\}$/)) {
        continue;
      }
      if (trimmed.match(/^>\s*\[!/)) {
        if (currentBlock) {
          blocks.push(currentBlock.trim());
          currentBlock = "";
        }
        inCallout = true;
        currentBlock = line;
        continue;
      }
      if (inCallout && trimmed.startsWith(">")) {
        currentBlock += "\n" + line;
        continue;
      }
      if (inCallout && !trimmed.startsWith(">")) {
        if (currentBlock) {
          blocks.push(currentBlock.trim());
          currentBlock = "";
        }
        inCallout = false;
      }
      if (trimmed === "") {
        if (currentBlock) {
          blocks.push(currentBlock.trim());
          currentBlock = "";
        }
        continue;
      }
      const cleanedLine = trimmed.replace(/\{\{[^}]*\}\}/g, "").trim();
      if (cleanedLine) {
        currentBlock += (currentBlock ? " " : "") + cleanedLine;
      }
    }
    if (currentBlock && blocks.length < 2) {
      blocks.push(currentBlock.trim());
    }
    if (blocks.length > 0) {
      const lastBlock = blocks[blocks.length - 1];
      const blockLines = lastBlock.split("\n");
      while (blockLines.length > 0) {
        const lastLine = blockLines[blockLines.length - 1].trim();
        if (lastLine.match(/^#+\s/)) {
          blockLines.pop();
        } else {
          break;
        }
      }
      if (blockLines.length === 0) {
        blocks.pop();
      } else {
        blocks[blocks.length - 1] = blockLines.join("\n").trim();
      }
    }
    const principleRegex = /#principles?\b/gi;
    const principlesInFile = [];
    for (const line of lines) {
      if (line.match(principleRegex)) {
        const tagMatches = line.match(/#[\w-]+/g);
        if (tagMatches) {
          for (const match of tagMatches) {
            if (!match.match(/^#principles?$/i) && !principlesInFile.includes(match)) {
              principlesInFile.push(match);
            }
          }
        }
      }
    }
    return {
      description: blocks.join("\n\n"),
      principles: principlesInFile,
      filepath
    };
  }
  async openProjectFile(tag) {
    const filename = tag.replace(/^#/, "") + ".md";
    const filepath = this.projectsFolder + filename;
    const file = this.app.vault.getAbstractFileByPath(filepath);
    if (file instanceof import_obsidian4.TFile) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
    } else {
      const confirmed = await this.confirmCreateProjectFile(tag, filepath);
      if (confirmed) {
        await this.createProjectFile(filepath, tag);
      }
    }
  }
  confirmCreateProjectFile(tag, filepath) {
    return new Promise((resolve) => {
      const modal = new import_obsidian4.Modal(this.app);
      modal.titleEl.setText("Create Project File?");
      modal.contentEl.createEl("p", {
        text: `Create project file for ${tag} in ${this.projectsFolder}?`
      });
      const buttonContainer = modal.contentEl.createEl("div", {
        cls: "modal-button-container"
      });
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "flex-end";
      buttonContainer.style.gap = "8px";
      buttonContainer.style.marginTop = "16px";
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const createBtn = buttonContainer.createEl("button", {
        text: "Create",
        cls: "mod-cta"
      });
      createBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  async createProjectFile(filepath, tag) {
    const folderPath = filepath.substring(0, filepath.lastIndexOf("/"));
    if (folderPath && !this.app.vault.getAbstractFileByPath(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }
    const projectName = tag.replace(/^#/, "");
    const content = `# ${projectName}

${tag}

## Overview

## TODOs

`;
    const file = await this.app.vault.create(filepath, content);
    const leaf = this.app.workspace.getLeaf(false);
    await leaf.openFile(file);
  }
};

// src/FilterParser.ts
var FilterParser = class {
  static parse(filterString) {
    const filters = {};
    if (!filterString || filterString.trim() === "") {
      return filters;
    }
    const parts = filterString.split("|").map((p) => p.trim());
    for (const part of parts) {
      if (part.startsWith("path:")) {
        filters.path = part.substring(5).trim();
      } else if (part.startsWith("tags:")) {
        const tagString = part.substring(5).trim();
        filters.tags = tagString.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      } else if (part.startsWith("limit:")) {
        const limitStr = part.substring(6).trim();
        const limit = parseInt(limitStr, 10);
        if (!isNaN(limit) && limit > 0) {
          filters.limit = limit;
        }
      } else if (part.startsWith("todone:")) {
        const value = part.substring(7).trim().toLowerCase();
        if (value === "show" || value === "hide") {
          filters.todone = value;
        }
      }
    }
    return filters;
  }
  static applyFilters(todos, filters) {
    let filtered = [...todos];
    if (filters.path) {
      const pathPrefix = filters.path.toLowerCase();
      filtered = filtered.filter(
        (todo) => todo.filePath.toLowerCase().startsWith(pathPrefix)
      );
    }
    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter((todo) => {
        const todoTags = todo.tags.map((t) => t.toLowerCase());
        const effectiveTags = todo.inferredFileTag ? [...todoTags, todo.inferredFileTag.toLowerCase()] : todoTags;
        return filters.tags.every(
          (filterTag) => effectiveTags.includes(filterTag.toLowerCase())
        );
      });
    }
    if (filters.limit) {
      filtered = filtered.slice(0, filters.limit);
    }
    return filtered;
  }
};

// src/ContextMenuHandler.ts
var import_obsidian5 = require("obsidian");
var ContextMenuHandler = class {
  constructor(app, processor, priorityTags) {
    this.app = app;
    this.processor = processor;
    this.priorityTags = priorityTags;
  }
  /**
   * Show context menu for an active TODO item
   */
  showTodoMenu(evt, todo, onRefresh) {
    const menu = new import_obsidian5.Menu();
    const currentPriority = this.getCurrentPriority(todo);
    const hasFocus = todo.tags.includes("#focus");
    const hasFuture = todo.tags.includes("#future");
    const hasLaterPriority = currentPriority && /^#p[3-4]$/.test(currentPriority);
    menu.addItem((item) => {
      item.setTitle("Copy").setIcon("copy").onClick(async () => {
        await navigator.clipboard.writeText(todo.text);
      });
    });
    menu.addItem((item) => {
      item.setTitle(hasFocus ? "Unfocus" : "Focus").setIcon("zap").onClick(async () => {
        let success;
        if (hasFocus) {
          success = await this.processor.removeTag(todo, "#focus");
        } else {
          const newPriority = this.calculateFocusPriority(currentPriority);
          success = await this.processor.setPriorityTag(todo, newPriority, true);
        }
        if (success)
          onRefresh();
      });
    });
    menu.addItem((item) => {
      item.setTitle(hasLaterPriority ? "Unlater" : "Later").setIcon("clock").onClick(async () => {
        let success;
        if (hasLaterPriority) {
          success = await this.processor.removeTag(todo, currentPriority);
        } else {
          const newPriority = this.calculateLaterPriority(currentPriority);
          success = await this.processor.setPriorityTag(todo, newPriority);
        }
        if (success)
          onRefresh();
      });
    });
    menu.addItem((item) => {
      item.setTitle(hasFuture ? "Unsnooze" : "Snooze").setIcon("moon").onClick(async () => {
        let success;
        if (hasFuture) {
          success = await this.processor.removeTag(todo, "#future");
        } else {
          success = await this.processor.setPriorityTag(todo, "#future");
        }
        if (success)
          onRefresh();
      });
    });
    menu.showAtMouseEvent(evt);
  }
  /**
   * Extract current priority tag from TODO
   */
  getCurrentPriority(todo) {
    if (todo.tags.includes("#future")) {
      return "#future";
    }
    for (const tag of todo.tags) {
      if (/^#p[0-4]$/.test(tag)) {
        return tag;
      }
    }
    return null;
  }
  /**
   * Calculate new priority for Focus action
   * If no priority or #future  #p0
   * If #pN  #p(N-1), but #p0 stays #p0
   */
  calculateFocusPriority(currentPriority) {
    if (!currentPriority || currentPriority === "#future") {
      return "#p0";
    }
    const match = currentPriority.match(/^#p([0-4])$/);
    if (match) {
      const num = parseInt(match[1]);
      return num > 0 ? `#p${num - 1}` : "#p0";
    }
    return "#p0";
  }
  /**
   * Calculate new priority for Later action
   * If no priority or #future  #p4
   * If #pN  #p(N+1), but #p4 stays #p4
   */
  calculateLaterPriority(currentPriority) {
    if (!currentPriority || currentPriority === "#future") {
      return "#p4";
    }
    const match = currentPriority.match(/^#p([0-4])$/);
    if (match) {
      const num = parseInt(match[1]);
      return num < 4 ? `#p${num + 1}` : "#p4";
    }
    return "#p4";
  }
  /**
   * Show context menu for a project (focus list item)
   * Operations apply to all TODOs matching the project tag
   */
  showProjectMenu(evt, project, scanner, onRefresh, onFilterByTag) {
    const menu = new import_obsidian5.Menu();
    const getTodosForProject = () => {
      return scanner.getTodos().filter((todo) => todo.tags.includes(project.tag));
    };
    const todos = getTodosForProject();
    const anyHasFocus = todos.some((t) => t.tags.includes("#focus"));
    const anyHasFuture = todos.some((t) => t.tags.includes("#future"));
    const anyHasLaterPriority = todos.some((t) => {
      for (const tag of t.tags) {
        if (/^#p[3-4]$/.test(tag))
          return true;
      }
      return false;
    });
    menu.addItem((item) => {
      item.setTitle(project.tag).setIcon("tag");
      const submenu = item.setSubmenu();
      submenu.addItem((subItem) => {
        subItem.setTitle("Filter by").setIcon("filter").onClick(() => {
          onFilterByTag(project.tag);
        });
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(anyHasFocus ? "Unfocus" : "Focus").setIcon("zap").onClick(async () => {
        const currentTodos = getTodosForProject();
        if (anyHasFocus) {
          await this.processor.unfocusAllWithTag(currentTodos);
        } else {
          await this.processor.focusAllWithTag(currentTodos);
        }
        onRefresh();
      });
    });
    menu.addItem((item) => {
      item.setTitle(anyHasLaterPriority ? "Unlater" : "Later").setIcon("clock").onClick(async () => {
        const currentTodos = getTodosForProject();
        if (anyHasLaterPriority) {
          await this.processor.unlaterAllWithTag(currentTodos);
        } else {
          await this.processor.laterAllWithTag(currentTodos);
        }
        onRefresh();
      });
    });
    menu.addItem((item) => {
      item.setTitle(anyHasFuture ? "Unsnooze" : "Snooze").setIcon("moon").onClick(async () => {
        const currentTodos = getTodosForProject();
        if (anyHasFuture) {
          await this.processor.unsnoozeAllWithTag(currentTodos);
        } else {
          await this.processor.snoozeAllWithTag(currentTodos);
        }
        onRefresh();
      });
    });
    menu.showAtMouseEvent(evt);
  }
  /**
   * Show context menu for an idea item
   */
  showIdeaMenu(evt, idea, onRefresh) {
    const menu = new import_obsidian5.Menu();
    const hasFocus = idea.tags.includes("#focus");
    menu.addItem((item) => {
      item.setTitle("Add to TODOs").setIcon("check-square").onClick(async () => {
        const success = await this.processor.convertIdeaToTodo(idea);
        if (success)
          onRefresh();
      });
    });
    menu.addItem((item) => {
      item.setTitle("Copy").setIcon("copy").onClick(async () => {
        await navigator.clipboard.writeText(idea.text);
      });
    });
    menu.addItem((item) => {
      item.setTitle(hasFocus ? "Unfocus" : "Focus").setIcon("zap").onClick(async () => {
        let success;
        if (hasFocus) {
          success = await this.processor.removeTag(idea, "#focus");
        } else {
          success = await this.processor.addFocusToIdea(idea);
        }
        if (success)
          onRefresh();
      });
    });
    menu.showAtMouseEvent(evt);
  }
  /**
   * Show context menu for a principle item
   */
  showPrincipleMenu(evt, principle) {
    const menu = new import_obsidian5.Menu();
    menu.addItem((item) => {
      item.setTitle("Copy").setIcon("copy").onClick(async () => {
        await navigator.clipboard.writeText(principle.text);
      });
    });
    menu.showAtMouseEvent(evt);
  }
};

// src/EmbedRenderer.ts
var EmbedRenderer = class {
  constructor(app, scanner, processor, projectManager, defaultTodoneFile = "todos/done.md", focusListLimit = 5, priorityTags = ["#p0", "#p1", "#p2", "#p3", "#p4"], makeLinksClickable = true) {
    // Track active renders for event cleanup
    this.activeRenders = /* @__PURE__ */ new Map();
    // Track TODONE visibility state per container
    this.todoneVisibility = /* @__PURE__ */ new Map();
    // Cache project colour map to avoid recalculating for each tag
    this.projectColourMapCache = null;
    this.app = app;
    this.scanner = scanner;
    this.processor = processor;
    this.projectManager = projectManager;
    this.defaultTodoneFile = defaultTodoneFile;
    this.focusListLimit = focusListLimit;
    this.priorityTags = priorityTags;
    this.makeLinksClickable = makeLinksClickable;
    this.contextMenuHandler = new ContextMenuHandler(app, processor, priorityTags);
  }
  // Get project colour map for tag colouring (cached per render cycle)
  getProjectColourMap() {
    if (!this.projectColourMapCache) {
      const projects = this.projectManager.getProjects();
      this.projectColourMapCache = /* @__PURE__ */ new Map();
      for (const project of projects) {
        this.projectColourMapCache.set(project.tag.toLowerCase(), project.colourIndex);
      }
    }
    return this.projectColourMapCache;
  }
  // Invalidate colour map cache (called when re-rendering)
  invalidateColourMapCache() {
    this.projectColourMapCache = null;
  }
  // Cleanup method to remove event listeners for a specific container
  cleanup(container) {
    const listener = this.activeRenders.get(container);
    if (listener) {
      this.scanner.off("todos-updated", listener);
      this.activeRenders.delete(container);
    }
    this.todoneVisibility.delete(container);
  }
  // Cleanup all renders (called on plugin unload)
  cleanupAll() {
    for (const [, listener] of this.activeRenders) {
      this.scanner.off("todos-updated", listener);
    }
    this.activeRenders.clear();
  }
  // Public helper method for code block processor
  // Renders a TODO list with filters (includes both TODOs and TODONEs)
  renderTodos(container, filterString, todoneFile) {
    const filters = FilterParser.parse(filterString);
    const allTodos = this.scanner.getTodos().filter(
      (t) => !t.tags.includes("#idea") && !t.tags.includes("#ideas") && !t.tags.includes("#ideation")
    );
    const allTodones = this.scanner.getTodones();
    const unfiltered = [...allTodos, ...allTodones];
    let filteredTodos = FilterParser.applyFilters(allTodos, filters);
    let filteredTodones = FilterParser.applyFilters(allTodones, filters);
    filteredTodos = this.includeParentHeaders(filteredTodos, allTodos);
    filteredTodones = this.includeParentHeaders(filteredTodones, allTodones);
    const combined = [...filteredTodos, ...filteredTodones];
    this.renderTodoList(container, combined, todoneFile, filterString, unfiltered);
  }
  // Public helper method for focus-list code blocks
  renderProjects(container) {
    this.renderFocusList(container);
  }
  // Public helper method for focus-ideas code blocks
  renderIdeas(container, filterString) {
    const filters = FilterParser.parse(filterString);
    const allIdeas = this.scanner.getIdeas();
    const filteredIdeas = FilterParser.applyFilters(allIdeas, filters);
    this.renderIdeaList(container, filteredIdeas, filterString, allIdeas);
  }
  // Public helper method for focus-principles code blocks
  renderPrinciples(container, filterString) {
    const filters = FilterParser.parse(filterString);
    const allPrinciples = this.scanner.getPrinciples();
    const filteredPrinciples = FilterParser.applyFilters(allPrinciples, filters);
    this.renderPrincipleList(container, filteredPrinciples, filterString, allPrinciples);
  }
  async render(source, el) {
    var _a;
    const focusListMatch = source.match(/\{\{focus-list\}\}/);
    if (focusListMatch) {
      this.renderFocusList(el);
      return;
    }
    const ideasMatch = source.match(
      /\{\{focus-ideas(?:\s*\|\s*(.+))?\}\}/
    );
    if (ideasMatch) {
      const filterString2 = ideasMatch[1] || "";
      this.renderIdeas(el, filterString2);
      return;
    }
    const match = source.match(
      /\{\{focus-todos:?\s*([^|}]*)(?:\s*\|\s*(.+))?\}\}/
    );
    if (!match) {
      el.createEl("div", {
        text: "Invalid syntax (use {{focus-todos}}, {{focus-ideas}}, or {{focus-list}})",
        cls: "space-command-error"
      });
      return;
    }
    const beforePipe = ((_a = match[1]) == null ? void 0 : _a.trim()) || "";
    const afterPipe = match[2] || "";
    const isFilter = beforePipe.startsWith("path:") || beforePipe.startsWith("tags:") || beforePipe.startsWith("limit:");
    let todoneFile;
    let filterString;
    if (isFilter) {
      todoneFile = this.defaultTodoneFile;
      filterString = beforePipe + (afterPipe ? " " + afterPipe : "");
    } else {
      todoneFile = beforePipe || this.defaultTodoneFile;
      filterString = afterPipe;
    }
    const filters = FilterParser.parse(filterString);
    const allTodos = this.scanner.getTodos().filter(
      (t) => !t.tags.includes("#idea") && !t.tags.includes("#ideas") && !t.tags.includes("#ideation")
    );
    const allTodones = this.scanner.getTodones();
    const unfiltered = [...allTodos, ...allTodones];
    let filteredTodos = FilterParser.applyFilters(allTodos, filters);
    let filteredTodones = FilterParser.applyFilters(allTodones, filters);
    filteredTodos = this.includeParentHeaders(filteredTodos, allTodos);
    filteredTodones = this.includeParentHeaders(filteredTodones, allTodones);
    const combined = [...filteredTodos, ...filteredTodones];
    this.renderTodoList(el, combined, todoneFile, filterString, unfiltered);
  }
  renderFocusList(container) {
    container.empty();
    container.addClass("space-command-embed", "focus-list-embed");
    const header = container.createEl("div", { cls: "embed-header" });
    const refreshBtn = header.createEl("button", {
      cls: "clickable-icon embed-refresh-btn",
      attr: { "aria-label": "Refresh" }
    });
    refreshBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>';
    refreshBtn.addEventListener("click", () => {
      this.renderFocusList(container);
    });
    this.setupFocusListAutoRefresh(container);
    const projects = this.projectManager.getFocusProjects(this.focusListLimit);
    if (projects.length === 0) {
      container.createEl("div", {
        text: "No focus projects",
        cls: "space-command-empty"
      });
      return;
    }
    const list = container.createEl("ul", { cls: "focus-list" });
    for (const project of projects) {
      const item = list.createEl("li", { cls: "focus-list-item" });
      item.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.contextMenuHandler.showProjectMenu(
          e,
          project,
          this.scanner,
          () => this.renderFocusList(container),
          () => {
          }
          // No filter action for embeds
        );
      });
      const textSpan = item.createEl("span", { cls: "focus-project-text" });
      textSpan.textContent = `${project.tag} `;
      const link = item.createEl("a", {
        text: "\u2192",
        cls: "focus-project-link",
        href: "#"
      });
      link.addEventListener("click", async (e) => {
        e.preventDefault();
        await this.projectManager.openProjectFile(project.tag);
      });
    }
  }
  // Include parent headers when their children match the filter
  // This ensures header TODOs appear even if only their children have the filtered tag
  includeParentHeaders(filtered, unfiltered) {
    const result = [...filtered];
    const filteredPaths = new Set(filtered.map((t) => `${t.filePath}:${t.lineNumber}`));
    for (const item of filtered) {
      if (item.parentLineNumber !== void 0) {
        const parentKey = `${item.filePath}:${item.parentLineNumber}`;
        if (!filteredPaths.has(parentKey)) {
          const parent = unfiltered.find(
            (t) => t.filePath === item.filePath && t.lineNumber === item.parentLineNumber
          );
          if (parent && !filteredPaths.has(parentKey)) {
            result.push(parent);
            filteredPaths.add(parentKey);
          }
        }
      }
    }
    return result;
  }
  sortTodos(todos) {
    const activeTodos = todos.filter((t) => t.itemType === "todo");
    const completedTodones = todos.filter((t) => t.itemType === "todone");
    activeTodos.sort(compareTodoItems);
    return [...activeTodos, ...completedTodones];
  }
  extractCompletionDate(text) {
    const match = text.match(/@(\d{4}-\d{2}-\d{2})/);
    return match ? match[1] : null;
  }
  renderTodoList(container, todos, todoneFile, filterString = "", unfilteredTodos) {
    var _a;
    container.empty();
    container.addClass("space-command-embed");
    const filters = FilterParser.parse(filterString);
    const showTodones = (_a = this.todoneVisibility.get(container)) != null ? _a : filters.todone !== "hide";
    this.todoneVisibility.set(container, showTodones);
    const header = container.createEl("div", { cls: "embed-header" });
    const toggleBtn = header.createEl("button", {
      cls: `clickable-icon embed-toggle-todone-btn${showTodones ? " active" : ""}`,
      attr: { "aria-label": showTodones ? "Hide completed" : "Show completed" }
    });
    toggleBtn.innerHTML = showTodones ? '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>';
    toggleBtn.addEventListener("click", () => {
      this.todoneVisibility.set(container, !showTodones);
      this.refreshEmbed(container, todoneFile, filterString);
    });
    const refreshBtn = header.createEl("button", {
      cls: "clickable-icon embed-refresh-btn",
      attr: { "aria-label": "Refresh" }
    });
    refreshBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>';
    refreshBtn.addEventListener("click", () => {
      this.refreshEmbed(container, todoneFile, filterString);
    });
    this.setupAutoRefresh(container, todoneFile, filterString);
    let displayTodos = todos;
    if (!showTodones) {
      displayTodos = todos.filter((t) => t.itemType !== "todone");
    }
    if (displayTodos.length === 0) {
      container.createEl("div", {
        text: showTodones ? "No TODOs" : "No active TODOs",
        cls: "space-command-empty"
      });
      return;
    }
    let topLevelTodos = displayTodos.filter((t) => t.parentLineNumber === void 0);
    const allTodones = this.scanner.getTodones();
    const allTodosForChildLookup = this.scanner.getTodos();
    topLevelTodos = topLevelTodos.filter((todo) => {
      if (!todo.isHeader) {
        return true;
      }
      if (!todo.childLineNumbers) {
        return true;
      }
      if (todo.childLineNumbers.length === 0) {
        return false;
      }
      const hasActiveChild = todo.childLineNumbers.some((childLine) => {
        const isComplete = allTodones.some((t) => t.filePath === todo.filePath && t.lineNumber === childLine);
        if (isComplete)
          return false;
        const childItem = allTodosForChildLookup.find((t) => t.filePath === todo.filePath && t.lineNumber === childLine);
        if (!childItem) {
          return false;
        }
        const isSnoozed = childItem.tags.includes("#future") || childItem.tags.includes("#snooze") || childItem.tags.includes("#snoozed");
        if (isSnoozed)
          return false;
        return true;
      });
      return hasActiveChild;
    });
    const sortedTodos = this.sortTodos(topLevelTodos);
    const list = container.createEl("ul", { cls: "contains-task-list" });
    const allTodosForLookup = unfilteredTodos || todos;
    for (const todo of sortedTodos) {
      this.renderTodoItem(list, todo, allTodosForLookup, showTodones, todoneFile, filterString);
    }
  }
  // Render a single todo item (and its children if it's a header)
  // parentTags: optional tags inherited from a parent header block (for child items)
  renderTodoItem(list, todo, allTodos, showTodones, todoneFile, filterString, isChild = false, parentTags = []) {
    const isCompleted = todo.itemType === "todone";
    const isHeader = todo.isHeader === true;
    const hasChildren = isHeader && todo.childLineNumbers && todo.childLineNumbers.length > 0;
    const itemClasses = [
      "task-list-item",
      isCompleted ? "todone-item" : "",
      isHeader ? "todo-header" : "",
      isChild ? "todo-child" : "",
      hasChildren ? "todo-header-with-children" : ""
    ].filter((c) => c).join(" ");
    const item = list.createEl("li", { cls: itemClasses });
    const rowContainer = hasChildren ? item.createEl("div", { cls: "todo-header-row" }) : item;
    if (!isCompleted) {
      item.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.contextMenuHandler.showTodoMenu(e, todo, () => {
          this.refreshEmbed(list.closest(".space-command-embed"), todoneFile, filterString);
        });
      });
    }
    const checkbox = rowContainer.createEl("input", {
      type: "checkbox",
      cls: "task-list-item-checkbox"
    });
    if (isCompleted) {
      checkbox.checked = true;
      checkbox.disabled = true;
    }
    checkbox.addEventListener("change", async () => {
      if (isCompleted)
        return;
      checkbox.disabled = true;
      const success = await this.processor.completeTodo(todo, todoneFile);
      if (success) {
        const container = list.closest(".space-command-embed");
        if (container) {
          this.refreshEmbed(container, todoneFile, filterString);
        }
      } else {
        checkbox.disabled = false;
      }
    });
    const textSpan = rowContainer.createEl("span", { cls: "todo-text" });
    if (isCompleted) {
      textSpan.addClass("todone-text");
    }
    let cleanText = todo.text.replace(/#todos?\b/g, "").replace(/#todones?\b/g, "").trim();
    const completionDate = isCompleted ? this.extractCompletionDate(cleanText) : null;
    if (completionDate) {
      cleanText = cleanText.replace(/@\d{4}-\d{2}-\d{2}/, "").trim();
    }
    let displayText = cleanText.replace(/^-\s*\[\s*\]\s*/, "").replace(/^-\s*\[x\]\s*/i, "");
    displayText = displayText.replace(/^#{1,6}\s+/, "").replace(/^[*\-+]\s+/, "").replace(/^>\s+/, "");
    if (parentTags.length > 0) {
      const existingTags = new Set(displayText.match(/#[\w-]+/g) || []);
      const newTags = parentTags.filter((tag) => !existingTags.has(tag));
      if (newTags.length > 0) {
        displayText = displayText.trim() + " " + newTags.join(" ");
      }
    }
    this.renderInlineMarkdown(displayText, textSpan);
    textSpan.append(" ");
    if (completionDate) {
      rowContainer.createEl("span", {
        cls: "todo-date muted-pill",
        text: completionDate
      });
    }
    if (hasChildren) {
      rowContainer.createEl("span", {
        cls: "header-filename",
        text: todo.file.basename
      });
    }
    const link = rowContainer.createEl("a", {
      text: "\u2192",
      cls: "todo-source-link",
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      openFileAtLine(this.app, todo.file, todo.lineNumber);
    });
    if (isHeader && todo.childLineNumbers && todo.childLineNumbers.length > 0) {
      const childrenContainer = item.createEl("ul", { cls: "todo-children contains-task-list" });
      const headerTags = extractTags(todo.text).filter((tag) => !/#todos?\b/.test(tag) && !/#todones?\b/.test(tag));
      for (const childLine of todo.childLineNumbers) {
        const childTodo = allTodos.find(
          (t) => t.filePath === todo.filePath && t.lineNumber === childLine
        );
        if (childTodo) {
          if (!showTodones && childTodo.itemType === "todone") {
            continue;
          }
          this.renderTodoItem(childrenContainer, childTodo, allTodos, showTodones, todoneFile, filterString, true, headerTags);
        }
      }
    }
  }
  // Render ideas list (similar to renderTodoList but for ideas)
  renderIdeaList(container, ideas, filterString = "", unfilteredIdeas) {
    container.empty();
    container.addClass("space-command-embed", "focus-ideas-embed");
    const header = container.createEl("div", { cls: "embed-header" });
    const refreshBtn = header.createEl("button", {
      cls: "clickable-icon embed-refresh-btn",
      attr: { "aria-label": "Refresh" }
    });
    refreshBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>';
    refreshBtn.addEventListener("click", () => {
      this.refreshIdeaEmbed(container, filterString);
    });
    this.setupIdeaAutoRefresh(container, filterString);
    if (ideas.length === 0) {
      container.createEl("div", {
        text: "No ideas",
        cls: "space-command-empty"
      });
      return;
    }
    const topLevelIdeas = ideas.filter((i) => i.parentLineNumber === void 0);
    const list = container.createEl("ul", { cls: "idea-list" });
    const allIdeasForLookup = unfilteredIdeas || ideas;
    for (const idea of topLevelIdeas) {
      this.renderIdeaItem(list, idea, allIdeasForLookup, filterString);
    }
  }
  // Render a single idea item (and its children if it's a header)
  // parentTags: optional tags inherited from a parent header block (for child items)
  renderIdeaItem(list, idea, allIdeas, filterString, isChild = false, parentTags = []) {
    const isHeader = idea.isHeader === true;
    const hasChildren = isHeader && idea.childLineNumbers && idea.childLineNumbers.length > 0;
    const itemClasses = [
      "idea-item",
      isHeader ? "idea-header" : "",
      isChild ? "idea-child" : "",
      hasChildren ? "idea-header-with-children" : ""
    ].filter((c) => c).join(" ");
    const item = list.createEl("li", { cls: itemClasses });
    const rowContainer = hasChildren ? item.createEl("div", { cls: "idea-header-row" }) : item;
    const textSpan = rowContainer.createEl("span", { cls: "idea-text" });
    let cleanText = idea.text.replace(/#idea(?:s|tion)?\b/g, "").trim();
    let displayText = cleanText.replace(/^-\s*\[\s*\]\s*/, "").replace(/^-\s*\[x\]\s*/i, "");
    displayText = displayText.replace(/^#{1,6}\s+/, "").replace(/^[*\-+]\s+/, "").replace(/^>\s+/, "");
    if (parentTags.length > 0) {
      const existingTags = new Set(displayText.match(/#[\w-]+/g) || []);
      const newTags = parentTags.filter((tag) => !existingTags.has(tag));
      if (newTags.length > 0) {
        displayText = displayText.trim() + " " + newTags.join(" ");
      }
    }
    this.renderInlineMarkdown(displayText, textSpan);
    textSpan.append(" ");
    if (hasChildren) {
      rowContainer.createEl("span", {
        cls: "header-filename",
        text: idea.file.basename
      });
    }
    const link = rowContainer.createEl("a", {
      text: "\u2192",
      cls: "idea-source-link",
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      openFileAtLine(this.app, idea.file, idea.lineNumber);
    });
    if (isHeader && idea.childLineNumbers && idea.childLineNumbers.length > 0) {
      const childrenContainer = item.createEl("ul", { cls: "idea-children" });
      const headerTags = extractTags(idea.text).filter((tag) => !/#idea(?:s|tion)?\b/.test(tag));
      for (const childLine of idea.childLineNumbers) {
        const childIdea = allIdeas.find(
          (i) => i.filePath === idea.filePath && i.lineNumber === childLine
        );
        if (childIdea) {
          this.renderIdeaItem(childrenContainer, childIdea, allIdeas, filterString, true, headerTags);
        }
      }
    }
  }
  // Render principles list
  renderPrincipleList(container, principles, filterString = "", unfilteredPrinciples) {
    container.empty();
    container.addClass("space-command-embed", "focus-principles-embed");
    const header = container.createEl("div", { cls: "embed-header" });
    const refreshBtn = header.createEl("button", {
      cls: "clickable-icon embed-refresh-btn",
      attr: { "aria-label": "Refresh" }
    });
    refreshBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>';
    refreshBtn.addEventListener("click", () => {
      this.refreshPrincipleEmbed(container, filterString);
    });
    this.setupPrincipleAutoRefresh(container, filterString);
    if (principles.length === 0) {
      container.createEl("div", {
        text: "No principles",
        cls: "space-command-empty"
      });
      return;
    }
    const topLevelPrinciples = principles.filter((p) => p.parentLineNumber === void 0);
    const list = container.createEl("ul", { cls: "principle-list" });
    const allPrinciplesForLookup = unfilteredPrinciples || principles;
    for (const principle of topLevelPrinciples) {
      this.renderPrincipleItem(list, principle, allPrinciplesForLookup, filterString);
    }
  }
  // Render a single principle item (and its children if it's a header)
  // parentTags: optional tags inherited from a parent header block (for child items)
  renderPrincipleItem(list, principle, allPrinciples, filterString, isChild = false, parentTags = []) {
    const isHeader = principle.isHeader === true;
    const hasChildren = isHeader && principle.childLineNumbers && principle.childLineNumbers.length > 0;
    const itemClasses = [
      "principle-item",
      isHeader ? "principle-header" : "",
      isChild ? "principle-child" : "",
      hasChildren ? "principle-header-with-children" : ""
    ].filter((c) => c).join(" ");
    const item = list.createEl("li", { cls: itemClasses });
    const rowContainer = hasChildren ? item.createEl("div", { cls: "principle-header-row" }) : item;
    const textSpan = rowContainer.createEl("span", { cls: "principle-text" });
    let cleanText = principle.text.replace(/#principles?\b/g, "").trim();
    let displayText = cleanText.replace(/^-\s*\[\s*\]\s*/, "").replace(/^-\s*\[x\]\s*/i, "");
    displayText = displayText.replace(/^#{1,6}\s+/, "").replace(/^[*\-+]\s+/, "").replace(/^>\s+/, "");
    if (parentTags.length > 0) {
      const existingTags = new Set(displayText.match(/#[\w-]+/g) || []);
      const newTags = parentTags.filter((tag) => !existingTags.has(tag));
      if (newTags.length > 0) {
        displayText = displayText.trim() + " " + newTags.join(" ");
      }
    }
    this.renderInlineMarkdown(displayText, textSpan);
    textSpan.append(" ");
    if (hasChildren) {
      rowContainer.createEl("span", {
        cls: "header-filename",
        text: principle.file.basename
      });
    }
    const link = rowContainer.createEl("a", {
      text: "\u2192",
      cls: "principle-source-link",
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      openFileAtLine(this.app, principle.file, principle.lineNumber);
    });
    if (isHeader && principle.childLineNumbers && principle.childLineNumbers.length > 0) {
      const childrenContainer = item.createEl("ul", { cls: "principle-children" });
      const headerTags = extractTags(principle.text).filter((tag) => !/#principles?\b/.test(tag));
      for (const childLine of principle.childLineNumbers) {
        const childPrinciple = allPrinciples.find(
          (p) => p.filePath === principle.filePath && p.lineNumber === childLine
        );
        if (childPrinciple) {
          this.renderPrincipleItem(childrenContainer, childPrinciple, allPrinciples, filterString, true, headerTags);
        }
      }
    }
  }
  // Render inline markdown without creating block elements
  // Uses DOM methods to avoid XSS vulnerabilities
  renderInlineMarkdown(text, container) {
    const tokens = this.parseMarkdownTokens(text);
    const mutedTags = ["#focus", "#future", "#p0", "#p1", "#p2", "#p3", "#p4"];
    const projectColourMap = this.getProjectColourMap();
    for (const token of tokens) {
      switch (token.type) {
        case "text":
          renderTextWithTags(token.content, container, mutedTags, projectColourMap);
          break;
        case "bold":
          container.createEl("strong", { text: token.content });
          break;
        case "italic":
          container.createEl("em", { text: token.content });
          break;
        case "code":
          container.createEl("code", { text: token.content });
          break;
        case "link":
          if (this.makeLinksClickable) {
            const link = container.createEl("a", {
              text: token.content,
              cls: "internal-link"
            });
            link.addEventListener("click", async (e) => {
              e.preventDefault();
              const url = token.url || "";
              if (url.startsWith("http://") || url.startsWith("https://")) {
                window.open(url, "_blank");
              } else {
                await this.app.workspace.openLinkText(url, "", false);
              }
            });
          } else {
            container.appendText(token.content);
          }
          break;
      }
    }
  }
  // Parse markdown into tokens for safe rendering
  parseMarkdownTokens(text) {
    const tokens = [];
    let remaining = text;
    while (remaining.length > 0) {
      let matched = false;
      let match = remaining.match(/^(\*\*|__)(.+?)\1/);
      if (match) {
        tokens.push({ type: "bold", content: match[2] });
        remaining = remaining.substring(match[0].length);
        matched = true;
        continue;
      }
      match = remaining.match(/^`([^`]+)`/);
      if (match) {
        tokens.push({ type: "code", content: match[1] });
        remaining = remaining.substring(match[0].length);
        matched = true;
        continue;
      }
      match = remaining.match(/^\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/);
      if (match) {
        const pagePath = match[1];
        const alias = match[2];
        const displayText = alias || pagePath.split("#")[0];
        tokens.push({ type: "link", content: displayText, url: pagePath });
        remaining = remaining.substring(match[0].length);
        matched = true;
        continue;
      }
      match = remaining.match(/^\[([^\]]+)\]\(([^)]+)\)/);
      if (match) {
        tokens.push({ type: "link", content: match[1], url: match[2] });
        remaining = remaining.substring(match[0].length);
        matched = true;
        continue;
      }
      match = remaining.match(/^(\*|_)([^\s\*_][^\*_]*?)\1/);
      if (match) {
        tokens.push({ type: "italic", content: match[2] });
        remaining = remaining.substring(match[0].length);
        matched = true;
        continue;
      }
      if (!matched) {
        const nextSpecial = remaining.search(/[\*_`\[]/);
        if (nextSpecial === -1) {
          tokens.push({ type: "text", content: remaining });
          break;
        } else if (nextSpecial > 0) {
          tokens.push({ type: "text", content: remaining.substring(0, nextSpecial) });
          remaining = remaining.substring(nextSpecial);
        } else {
          tokens.push({ type: "text", content: remaining[0] });
          remaining = remaining.substring(1);
        }
      }
    }
    return tokens;
  }
  // Setup auto-refresh for focus list embed
  setupFocusListAutoRefresh(container) {
    this.cleanup(container);
    const listener = () => {
      if (container.isConnected) {
        this.renderFocusList(container);
      } else {
        this.cleanup(container);
      }
    };
    this.scanner.on("todos-updated", listener);
    this.activeRenders.set(container, listener);
  }
  // Setup auto-refresh for this embed
  setupAutoRefresh(container, todoneFile, filterString) {
    this.cleanup(container);
    const listener = () => {
      if (container.isConnected) {
        this.refreshEmbed(container, todoneFile, filterString);
      } else {
        this.cleanup(container);
      }
    };
    this.scanner.on("todos-updated", listener);
    this.activeRenders.set(container, listener);
  }
  // Refresh a specific embed
  refreshEmbed(container, todoneFile, filterString) {
    this.invalidateColourMapCache();
    const filters = FilterParser.parse(filterString);
    const allTodos = this.scanner.getTodos().filter(
      (t) => !t.tags.includes("#idea") && !t.tags.includes("#ideas") && !t.tags.includes("#ideation")
    );
    const allTodones = this.scanner.getTodones();
    const unfiltered = [...allTodos, ...allTodones];
    let filteredTodos = FilterParser.applyFilters(allTodos, filters);
    let filteredTodones = FilterParser.applyFilters(allTodones, filters);
    filteredTodos = this.includeParentHeaders(filteredTodos, allTodos);
    filteredTodones = this.includeParentHeaders(filteredTodones, allTodones);
    const combined = [...filteredTodos, ...filteredTodones];
    this.renderTodoList(container, combined, todoneFile, filterString, unfiltered);
  }
  // Setup auto-refresh for idea embeds
  setupIdeaAutoRefresh(container, filterString) {
    this.cleanup(container);
    const listener = () => {
      if (container.isConnected) {
        this.refreshIdeaEmbed(container, filterString);
      } else {
        this.cleanup(container);
      }
    };
    this.scanner.on("todos-updated", listener);
    this.activeRenders.set(container, listener);
  }
  // Refresh idea embed
  refreshIdeaEmbed(container, filterString) {
    this.invalidateColourMapCache();
    const filters = FilterParser.parse(filterString);
    const allIdeas = this.scanner.getIdeas();
    const filteredIdeas = FilterParser.applyFilters(allIdeas, filters);
    this.renderIdeaList(container, filteredIdeas, filterString, allIdeas);
  }
  // Setup auto-refresh for principle embeds
  setupPrincipleAutoRefresh(container, filterString) {
    this.cleanup(container);
    const listener = () => {
      if (container.isConnected) {
        this.refreshPrincipleEmbed(container, filterString);
      } else {
        this.cleanup(container);
      }
    };
    this.scanner.on("todos-updated", listener);
    this.activeRenders.set(container, listener);
  }
  // Refresh principle embed
  refreshPrincipleEmbed(container, filterString) {
    this.invalidateColourMapCache();
    const filters = FilterParser.parse(filterString);
    const allPrinciples = this.scanner.getPrinciples();
    const filteredPrinciples = FilterParser.applyFilters(allPrinciples, filters);
    this.renderPrincipleList(container, filteredPrinciples, filterString, allPrinciples);
  }
};

// src/CodeBlockProcessor.ts
var CodeBlockProcessor = class {
  constructor(embedRenderer, defaultTodoneFile) {
    this.embedRenderer = embedRenderer;
    this.defaultTodoneFile = defaultTodoneFile;
  }
  // Register all code block processors
  registerProcessors(plugin) {
    plugin.registerMarkdownCodeBlockProcessor(
      "focus-todos",
      this.processFocusTodos.bind(this)
    );
    plugin.registerMarkdownCodeBlockProcessor(
      "focus-list",
      this.processFocusList.bind(this)
    );
    plugin.registerMarkdownCodeBlockProcessor(
      "focus-ideas",
      this.processFocusIdeas.bind(this)
    );
    plugin.registerMarkdownCodeBlockProcessor(
      "focus-principles",
      this.processFocusPrinciples.bind(this)
    );
  }
  // Handle focus-todos code blocks
  processFocusTodos(source, el) {
    const { todoneFile, filterString } = this.parseContent(source);
    this.embedRenderer.renderTodos(el, filterString, todoneFile);
  }
  // Handle focus-list code blocks
  processFocusList(source, el) {
    this.embedRenderer.renderProjects(el);
  }
  // Handle focus-ideas code blocks
  processFocusIdeas(source, el) {
    const { filterString } = this.parseContent(source);
    this.embedRenderer.renderIdeas(el, filterString);
  }
  // Handle focus-principles code blocks
  processFocusPrinciples(source, el) {
    const { filterString } = this.parseContent(source);
    this.embedRenderer.renderPrinciples(el, filterString);
  }
  // Parse code block content
  // Supports multiple formats:
  // 1. Empty block: uses defaults
  // 2. File only: first line is TODONE file
  // 3. Filters only: all lines are filters (uses default file)
  // 4. File + filters (single line): "file.md | filters"
  // 5. File + filters (multi-line): first line is file, rest are filters
  parseContent(source) {
    const lines = source.split("\n").map((l) => l.trim()).filter((l) => l.length > 0);
    if (lines.length === 0) {
      return {
        todoneFile: this.defaultTodoneFile,
        filterString: ""
      };
    }
    const firstLine = lines[0];
    const isFilter = firstLine.includes("|") || firstLine.startsWith("path:") || firstLine.startsWith("tags:") || firstLine.startsWith("limit:") || firstLine.startsWith("todone:");
    if (isFilter) {
      return {
        todoneFile: this.defaultTodoneFile,
        filterString: lines.join(" | ")
      };
    }
    if (firstLine.includes("|")) {
      const [file, ...filterParts] = firstLine.split("|");
      return {
        todoneFile: file.trim(),
        filterString: filterParts.join("|").trim()
      };
    }
    const todoneFile = firstLine;
    const filterString = lines.slice(1).join(" | ");
    return { todoneFile, filterString };
  }
};

// src/SlashCommandSuggest.ts
var import_obsidian6 = require("obsidian");
var CALLOUT_TYPES = [
  { id: "info", name: "Info", icon: "\u2139\uFE0F" },
  { id: "tip", name: "Tip", icon: "\u{1F4A1}" },
  { id: "note", name: "Note", icon: "\u{1F4DD}" },
  { id: "warning", name: "Warning", icon: "\u26A0\uFE0F" },
  { id: "danger", name: "Danger", icon: "\u{1F534}" },
  { id: "bug", name: "Bug", icon: "\u{1F41B}" },
  { id: "example", name: "Example", icon: "\u{1F4CB}" },
  { id: "quote", name: "Quote", icon: "\u{1F4AC}" },
  { id: "abstract", name: "Abstract", icon: "\u{1F4C4}" },
  { id: "success", name: "Success", icon: "\u2705" },
  { id: "question", name: "Question", icon: "\u2753" },
  { id: "failure", name: "Failure", icon: "\u274C" }
];
var SlashCommandSuggest = class extends import_obsidian6.EditorSuggest {
  constructor(app, settings) {
    super(app);
    this.inCalloutMenu = false;
    this.triggerStart = null;
    this.settings = settings;
  }
  getCommands() {
    return [
      {
        id: "todo",
        name: "Todo",
        description: "Insert a TODO item",
        icon: "\u2610",
        action: (editor, start, end) => {
          editor.replaceRange("- [ ] #todo ", start, end);
          editor.setCursor({ line: start.line, ch: start.ch + 12 });
        }
      },
      {
        id: "todos",
        name: "Todos",
        description: "Insert a TODO list with heading",
        icon: "\u2630",
        action: (editor, start, end) => {
          const text = "## TODOs #todos\n\n- [ ] ";
          editor.replaceRange(text, start, end);
          editor.setCursor({ line: start.line + 2, ch: 6 });
        }
      },
      {
        id: "idea",
        name: "Idea",
        description: "Insert an idea item",
        icon: "\u{1F4A1}",
        action: (editor, start, end) => {
          editor.replaceRange("- [ ] #idea ", start, end);
          editor.setCursor({ line: start.line, ch: start.ch + 12 });
        }
      },
      {
        id: "ideas",
        name: "Ideas",
        description: "Insert an Ideas list with heading",
        icon: "\u{1F4A1}",
        action: (editor, start, end) => {
          const text = "## Ideas #ideas\n\n- [ ] ";
          editor.replaceRange(text, start, end);
          editor.setCursor({ line: start.line + 2, ch: 6 });
        }
      },
      {
        id: "today",
        name: "Today",
        description: "Insert today's date",
        icon: "\u{1F4C5}",
        action: (editor, start, end) => {
          const date = formatDate(/* @__PURE__ */ new Date(), this.settings.dateFormat);
          editor.replaceRange(date, start, end);
          editor.setCursor({ line: start.line, ch: start.ch + date.length });
        }
      },
      {
        id: "tomorrow",
        name: "Tomorrow",
        description: "Insert tomorrow's date",
        icon: "\u{1F4C6}",
        action: (editor, start, end) => {
          const tomorrow = /* @__PURE__ */ new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          const date = formatDate(tomorrow, this.settings.dateFormat);
          editor.replaceRange(date, start, end);
          editor.setCursor({ line: start.line, ch: start.ch + date.length });
        }
      },
      {
        id: "callout",
        name: "Callout",
        description: "Insert a callout block",
        icon: "\u{1F4E2}",
        action: () => {
        }
      }
    ];
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const match = beforeCursor.match(/^(\s*)\/(\S*)$/);
    if (!match) {
      this.inCalloutMenu = false;
      return null;
    }
    const whitespace = match[1];
    const query = match[2];
    this.triggerStart = { line: cursor.line, ch: whitespace.length };
    return {
      start: this.triggerStart,
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    if (this.inCalloutMenu) {
      return CALLOUT_TYPES.filter(
        (type) => type.id.includes(query) || type.name.toLowerCase().includes(query)
      );
    }
    const commands = this.getCommands();
    if (!query) {
      return commands;
    }
    return commands.filter(
      (cmd) => cmd.id.includes(query) || cmd.name.toLowerCase().includes(query)
    );
  }
  renderSuggestion(item, el) {
    el.addClass("space-command-suggestion");
    const iconSpan = el.createEl("span", { cls: "suggestion-icon" });
    iconSpan.textContent = item.icon;
    const textContainer = el.createEl("div", { cls: "suggestion-content" });
    textContainer.createEl("span", {
      cls: "suggestion-name",
      text: item.name
    });
    if ("description" in item) {
      textContainer.createEl("span", {
        cls: "suggestion-description",
        text: item.description
      });
    }
  }
  selectSuggestion(item, evt) {
    var _a;
    const editor = (_a = this.context) == null ? void 0 : _a.editor;
    if (!editor || !this.context)
      return;
    const start = this.context.start;
    const end = this.context.end;
    if (this.inCalloutMenu) {
      const calloutType = item;
      const calloutText = `> [!${calloutType.id}]
> `;
      editor.replaceRange(calloutText, start, end);
      editor.setCursor({ line: start.line + 1, ch: 2 });
      this.inCalloutMenu = false;
    } else if ("action" in item) {
      const command = item;
      if (command.id === "callout") {
        this.inCalloutMenu = true;
        editor.replaceRange("/", start, end);
        editor.setCursor({ line: start.line, ch: start.ch + 1 });
      } else {
        command.action(editor, start, end);
      }
    }
  }
};

// src/DateSuggest.ts
var import_obsidian7 = require("obsidian");
var DateSuggest = class extends import_obsidian7.EditorSuggest {
  constructor(app, settings) {
    super(app);
    this.settings = settings;
  }
  getDateOptions() {
    return [
      {
        id: "date",
        name: "@date",
        description: "Today's date",
        icon: "\u{1F4C5}",
        getDate: () => /* @__PURE__ */ new Date()
      },
      {
        id: "today",
        name: "@today",
        description: "Today's date",
        icon: "\u{1F4C5}",
        getDate: () => /* @__PURE__ */ new Date()
      },
      {
        id: "tomorrow",
        name: "@tomorrow",
        description: "Tomorrow's date",
        icon: "\u{1F4C6}",
        getDate: () => {
          const d = /* @__PURE__ */ new Date();
          d.setDate(d.getDate() + 1);
          return d;
        }
      },
      {
        id: "yesterday",
        name: "@yesterday",
        description: "Yesterday's date",
        icon: "\u{1F4C6}",
        getDate: () => {
          const d = /* @__PURE__ */ new Date();
          d.setDate(d.getDate() - 1);
          return d;
        }
      }
    ];
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const match = beforeCursor.match(/@(\w*)$/);
    if (!match) {
      return null;
    }
    const atIndex = beforeCursor.lastIndexOf("@");
    if (atIndex > 0) {
      const charBefore = beforeCursor[atIndex - 1];
      if (/[a-zA-Z0-9]/.test(charBefore)) {
        return null;
      }
    }
    return {
      start: { line: cursor.line, ch: atIndex },
      end: cursor,
      query: match[1].toLowerCase()
    };
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    const options = this.getDateOptions();
    if (!query) {
      return options;
    }
    return options.filter((opt) => {
      const id = opt.id.toLowerCase();
      return id.startsWith(query) || id.includes(query);
    });
  }
  renderSuggestion(item, el) {
    el.addClass("space-command-suggestion");
    const iconSpan = el.createEl("span", { cls: "suggestion-icon" });
    iconSpan.textContent = item.icon;
    const textContainer = el.createEl("div", { cls: "suggestion-content" });
    const nameSpan = textContainer.createEl("span", {
      cls: "suggestion-name",
      text: item.name
    });
    const date = formatDate(item.getDate(), this.settings.dateFormat);
    textContainer.createEl("span", {
      cls: "suggestion-description",
      text: date
    });
  }
  selectSuggestion(item, evt) {
    var _a;
    const editor = (_a = this.context) == null ? void 0 : _a.editor;
    if (!editor || !this.context)
      return;
    const start = this.context.start;
    const end = this.context.end;
    const date = formatDate(item.getDate(), this.settings.dateFormat);
    editor.replaceRange(date, start, end);
    editor.setCursor({ line: start.line, ch: start.ch + date.length });
  }
};

// src/SidebarView.ts
var import_obsidian8 = require("obsidian");
var VIEW_TYPE_TODO_SIDEBAR = "space-command-sidebar";
var TodoSidebarView = class extends import_obsidian8.ItemView {
  constructor(leaf, scanner, processor, projectManager, defaultTodoneFile, priorityTags, recentTodonesLimit, activeTodosLimit, focusListLimit, focusModeIncludeProjects, makeLinksClickable, triageSnoozedThreshold, triageActiveThreshold, onShowAbout, onShowStats, onShowTriage) {
    super(leaf);
    this.updateListener = null;
    this.activeTab = "todos";
    this.activeTagFilter = null;
    this.focusModeEnabled = false;
    this.openDropdown = null;
    this.openInfoPopup = null;
    // Configuration for unified list item rendering
    this.todoConfig = {
      type: "todo",
      classPrefix: "todo",
      tagToStrip: /#todos?\b/g,
      showCheckbox: true,
      onComplete: (item) => this.processor.completeTodo(item, this.defaultTodoneFile),
      onContextMenu: (e, item) => this.contextMenuHandler.showTodoMenu(e, item, () => this.render())
    };
    this.ideaConfig = {
      type: "idea",
      classPrefix: "idea",
      tagToStrip: /#idea(?:s|tion)?\b/g,
      showCheckbox: true,
      onComplete: (item) => this.processor.completeIdea(item),
      onContextMenu: (e, item) => this.contextMenuHandler.showIdeaMenu(e, item, () => this.render())
    };
    this.principleConfig = {
      type: "principle",
      classPrefix: "principle",
      tagToStrip: /#principles?\b/g,
      showCheckbox: false,
      onContextMenu: (e, item) => this.contextMenuHandler.showPrincipleMenu(e, item)
    };
    this.scanner = scanner;
    this.processor = processor;
    this.projectManager = projectManager;
    this.defaultTodoneFile = defaultTodoneFile;
    this.recentTodonesLimit = recentTodonesLimit;
    this.activeTodosLimit = activeTodosLimit;
    this.focusListLimit = focusListLimit;
    this.focusModeIncludeProjects = focusModeIncludeProjects;
    this.makeLinksClickable = makeLinksClickable;
    this.triageSnoozedThreshold = triageSnoozedThreshold;
    this.triageActiveThreshold = triageActiveThreshold;
    this.onShowAbout = onShowAbout;
    this.onShowStats = onShowStats;
    this.onShowTriage = onShowTriage;
    this.contextMenuHandler = new ContextMenuHandler(
      this.app,
      processor,
      priorityTags
    );
  }
  getViewType() {
    return VIEW_TYPE_TODO_SIDEBAR;
  }
  getDisplayText() {
    switch (this.activeTab) {
      case "todos":
        return "TODOs";
      case "ideas":
        return "IDEAs";
      case "snoozed":
        return "Snoozed";
    }
  }
  getIcon() {
    return "square-check-big";
  }
  shouldShowTriageAlert() {
    const allTodos = this.scanner.getTodos();
    const activeTodos = allTodos.filter(
      (t) => !t.tags.includes("#future") && !t.tags.includes("#snooze") && !t.tags.includes("#snoozed") && !t.tags.includes("#idea") && !t.tags.includes("#ideas") && !t.tags.includes("#ideation")
    );
    const allIdeas = this.scanner.getIdeas();
    const activeIdeas = allIdeas.filter(
      (i) => !i.tags.includes("#future") && !i.tags.includes("#snooze") && !i.tags.includes("#snoozed")
    );
    const snoozedTodos = allTodos.filter(
      (t) => t.tags.includes("#future") || t.tags.includes("#snooze") || t.tags.includes("#snoozed")
    );
    const snoozedIdeas = allIdeas.filter(
      (i) => i.tags.includes("#future") || i.tags.includes("#snooze") || i.tags.includes("#snoozed")
    );
    const totalSnoozed = snoozedTodos.length + snoozedIdeas.length;
    const activeCount = activeTodos.length + activeIdeas.length;
    return totalSnoozed > this.triageSnoozedThreshold || activeCount > this.triageActiveThreshold;
  }
  stripMarkdownSyntax(text) {
    let cleaned = text;
    cleaned = cleaned.replace(/^#{1,6}\s+/, "");
    cleaned = cleaned.replace(/^-\s*\[\s*\]\s*/, "");
    cleaned = cleaned.replace(/^-\s*\[x\]\s*/, "");
    cleaned = cleaned.replace(/^-\s+/, "");
    cleaned = cleaned.replace(/\*\*(.+?)\*\*/g, "$1");
    cleaned = cleaned.replace(/\*(.+?)\*/g, "$1");
    cleaned = cleaned.replace(/__(.+?)__/g, "$1");
    cleaned = cleaned.replace(/_(.+?)_/g, "$1");
    cleaned = cleaned.replace(/~~(.+?)~~/g, "$1");
    cleaned = cleaned.replace(/`(.+?)`/g, "$1");
    cleaned = cleaned.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (match, page, alias) => {
      return alias || page.split("#")[0];
    });
    cleaned = cleaned.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1");
    return cleaned;
  }
  // Extract completion date from text (@YYYY-MM-DD pattern)
  extractCompletionDate(text) {
    const match = text.match(/@(\d{4}-\d{2}-\d{2})/);
    return match ? match[1] : null;
  }
  // Strip tags from text but preserve tags inside backticks (inline code)
  stripTagsPreservingCode(text) {
    const codeBlocks = [];
    const placeholder = "\0CODE\0";
    const textWithPlaceholders = text.replace(/`[^`]+`/g, (match) => {
      codeBlocks.push(match);
      return placeholder + (codeBlocks.length - 1) + placeholder;
    });
    const textWithoutTags = textWithPlaceholders.replace(/#[\w-]+/g, "");
    return textWithoutTags.replace(new RegExp(placeholder + "(\\d+)" + placeholder, "g"), (_, index) => {
      return codeBlocks[parseInt(index)];
    });
  }
  // Render text with clickable links (simplified version for sidebar)
  renderTextWithLinks(text, container) {
    let processed = text.replace(/^#{1,6}\s+/, "").replace(/^-\s*\[\s*\]\s*/, "").replace(/^-\s*\[x\]\s*/, "").replace(/^-\s+/, "");
    let remaining = processed;
    while (remaining.length > 0) {
      let match = remaining.match(/^\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/);
      if (match) {
        const pagePath = match[1];
        const alias = match[2];
        const displayText = alias || pagePath.split("#")[0];
        const link = container.createEl("a", {
          text: displayText,
          cls: "internal-link"
        });
        link.addEventListener("click", async (e) => {
          e.preventDefault();
          await this.app.workspace.openLinkText(pagePath, "", false);
        });
        remaining = remaining.substring(match[0].length);
        continue;
      }
      match = remaining.match(/^\[([^\]]+)\]\(([^)]+)\)/);
      if (match) {
        const linkText = match[1];
        const url = match[2];
        const link = container.createEl("a", {
          text: linkText,
          cls: "external-link"
        });
        link.addEventListener("click", (e) => {
          e.preventDefault();
          window.open(url, "_blank");
        });
        remaining = remaining.substring(match[0].length);
        continue;
      }
      match = remaining.match(/^\*\*(.+?)\*\*/);
      if (match) {
        container.createEl("strong", { text: match[1] });
        remaining = remaining.substring(match[0].length);
        continue;
      }
      match = remaining.match(/^\*(.+?)\*/);
      if (match) {
        container.createEl("em", { text: match[1] });
        remaining = remaining.substring(match[0].length);
        continue;
      }
      match = remaining.match(/^`([^`]+)`/);
      if (match) {
        container.createEl("code", { text: match[1] });
        remaining = remaining.substring(match[0].length);
        continue;
      }
      const nextSpecial = remaining.search(/[\*`\[]/);
      if (nextSpecial === -1) {
        container.appendText(remaining);
        break;
      } else if (nextSpecial > 0) {
        container.appendText(remaining.substring(0, nextSpecial));
        remaining = remaining.substring(nextSpecial);
      } else {
        container.appendText(remaining[0]);
        remaining = remaining.substring(1);
      }
    }
  }
  // Unified list item renderer for todos, ideas, and principles
  // parentTags: optional tags inherited from a parent header block (for child items)
  renderListItem(list, item, config, isChild = false, parentTags = []) {
    const hasFocus = item.tags.includes("#focus");
    const isHeader = item.isHeader === true;
    const hasChildren = isHeader && item.childLineNumbers && item.childLineNumbers.length > 0;
    const itemClasses = [
      `${config.classPrefix}-item`,
      hasFocus ? `${config.classPrefix}-focus` : "",
      isHeader ? `${config.classPrefix}-header` : "",
      isChild ? `${config.classPrefix}-child` : "",
      hasChildren ? `${config.classPrefix}-header-with-children` : ""
    ].filter((c) => c).join(" ");
    const listItem = list.createEl("li", { cls: itemClasses });
    if (config.onContextMenu) {
      listItem.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        config.onContextMenu(e, item);
      });
    }
    const rowContainer = hasChildren ? listItem.createEl("div", { cls: `${config.classPrefix}-header-row` }) : listItem;
    if (config.showCheckbox && config.onComplete) {
      const checkbox = rowContainer.createEl("input", {
        type: "checkbox",
        cls: `${config.classPrefix}-checkbox`
      });
      checkbox.addEventListener("change", async () => {
        checkbox.disabled = true;
        const success = await config.onComplete(item);
        if (!success) {
          checkbox.disabled = false;
        }
      });
    }
    const textSpan = rowContainer.createEl("span", { cls: `${config.classPrefix}-text` });
    const cleanText = item.text.replace(config.tagToStrip, "").trim();
    const textWithoutTags = this.stripTagsPreservingCode(cleanText);
    if (this.makeLinksClickable) {
      this.renderTextWithLinks(textWithoutTags, textSpan);
    } else {
      const displayText = this.stripMarkdownSyntax(textWithoutTags);
      const finalText = displayText.replace(/\s+/g, " ").trim();
      textSpan.appendText(finalText);
    }
    if (hasChildren) {
      rowContainer.createEl("span", {
        cls: "header-filename",
        text: item.file.basename
      });
    }
    const itemTags = extractTags(cleanText).filter((tag) => !config.tagToStrip.test(tag));
    const mergedTags = [.../* @__PURE__ */ new Set([...parentTags, ...itemTags])];
    if (mergedTags.length > 0) {
      this.renderTagDropdown(mergedTags, rowContainer, item);
    }
    const link = rowContainer.createEl("a", {
      text: "\u2192",
      cls: `${config.classPrefix}-link`,
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      openFileAtLine(this.app, item.file, item.lineNumber);
    });
    if (hasChildren) {
      const childrenContainer = listItem.createEl("ul", { cls: `${config.classPrefix}-children` });
      const allItems = this.getItemsForType(config.type);
      const headerTags = extractTags(item.text).filter((tag) => !config.tagToStrip.test(tag));
      for (const childLine of item.childLineNumbers) {
        const childItem = allItems.find(
          (t) => t.filePath === item.filePath && t.lineNumber === childLine
        );
        if (childItem) {
          this.renderListItem(childrenContainer, childItem, config, true, headerTags);
        }
      }
    }
  }
  // Get all items of a given type for child lookup
  getItemsForType(type) {
    switch (type) {
      case "todo":
        return this.scanner.getTodos();
      case "idea":
        return this.scanner.getIdeas();
      case "principle":
        return this.scanner.getPrinciples();
    }
  }
  // Close any open tag dropdown
  closeDropdown() {
    if (this.openDropdown) {
      this.openDropdown.remove();
      this.openDropdown = null;
    }
  }
  // Get project colour map for tag colouring
  getProjectColourMap() {
    const projects = this.projectManager.getProjects();
    const map = /* @__PURE__ */ new Map();
    for (const project of projects) {
      map.set(project.tag.toLowerCase(), project.colourIndex);
    }
    return map;
  }
  // Render collapsed tag indicator with dropdown
  // If item is provided, "Clear tag" option will be available to remove tags from the item
  renderTagDropdown(tags, container, item) {
    if (tags.length === 0)
      return;
    const projectColourMap = this.getProjectColourMap();
    const trigger = container.createEl("span", {
      cls: "tag-dropdown-trigger",
      text: "#"
    });
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      this.closeInfoPopup();
      const dropdown = document.createElement("div");
      dropdown.className = "tag-dropdown-menu";
      const sidebarRoot = this.leaf.getRoot();
      const isRightSidebar = sidebarRoot === this.app.workspace.rightSplit;
      const rect = trigger.getBoundingClientRect();
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      if (isRightSidebar) {
        dropdown.style.right = `${window.innerWidth - rect.right}px`;
        dropdown.classList.add("dropdown-left");
      } else {
        dropdown.style.left = `${rect.left}px`;
      }
      const sortedTags = [...tags].sort((a, b) => a.localeCompare(b));
      for (const tag of sortedTags) {
        const tagItem = dropdown.createEl("div", {
          cls: "tag-dropdown-item tag-dropdown-item-with-submenu"
        });
        const colourInfo = getTagColourInfo(tag, projectColourMap);
        const tagLabel = tagItem.createEl("span", {
          cls: "tag-dropdown-item-label tag",
          text: tag
        });
        tagLabel.dataset.scTagType = colourInfo.type;
        tagLabel.dataset.scPriority = colourInfo.priority.toString();
        const arrow = tagItem.createEl("span", {
          cls: "tag-dropdown-item-arrow",
          text: "\u203A"
        });
        const submenu = tagItem.createEl("div", {
          cls: "tag-dropdown-submenu"
        });
        if (item) {
          const clearTagOption = submenu.createEl("div", {
            cls: "tag-dropdown-submenu-item",
            text: "Clear tag"
          });
          clearTagOption.addEventListener("click", async (e2) => {
            e2.stopPropagation();
            this.closeDropdown();
            const success = await this.processor.removeTag(item, tag);
            if (success) {
              this.render();
            }
          });
        }
        const filterOption = submenu.createEl("div", {
          cls: "tag-dropdown-submenu-item",
          text: "Filter by"
        });
        filterOption.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = tag;
          this.closeDropdown();
          this.render();
        });
      }
      dropdown.createEl("div", { cls: "tag-dropdown-separator" });
      if (item) {
        const isSnoozed = item.tags.includes("#future") || item.tags.includes("#snooze") || item.tags.includes("#snoozed");
        const snoozeItem = dropdown.createEl("div", {
          cls: "tag-dropdown-item tag-dropdown-snooze",
          text: isSnoozed ? "Unsnooze this" : "Snooze this"
        });
        snoozeItem.addEventListener("click", async (e2) => {
          e2.stopPropagation();
          this.closeDropdown();
          let success;
          if (isSnoozed) {
            success = await this.processor.removeTag(item, "#future");
            if (item.tags.includes("#snooze")) {
              await this.processor.removeTag(item, "#snooze");
            }
            if (item.tags.includes("#snoozed")) {
              await this.processor.removeTag(item, "#snoozed");
            }
          } else {
            success = await this.processor.setPriorityTag(item, "#future");
          }
          if (success) {
            this.render();
          }
        });
        dropdown.createEl("div", { cls: "tag-dropdown-separator" });
      }
      const clearItem = dropdown.createEl("div", {
        cls: `tag-dropdown-clear${this.activeTagFilter ? "" : " disabled"}`,
        text: "Clear filter"
      });
      if (this.activeTagFilter) {
        clearItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = null;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  async onOpen() {
    this.updateListener = () => this.render();
    this.scanner.on("todos-updated", this.updateListener);
    const hasTodos = this.scanner.getTodos().length > 0;
    const hasTodones = this.scanner.getTodones().length > 0;
    const hasIdeas = this.scanner.getIdeas().length > 0;
    const hasPrinciples = this.scanner.getPrinciples().length > 0;
    if (!hasTodos && !hasTodones && !hasIdeas && !hasPrinciples) {
      await this.scanner.scanVault();
    } else {
      this.render();
    }
  }
  async onClose() {
    if (this.updateListener) {
      this.scanner.off("todos-updated", this.updateListener);
      this.updateListener = null;
    }
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("space-command-sidebar");
    const headerDiv = container.createEl("div", { cls: "sidebar-header" });
    const titleEl = headerDiv.createEl("h4", { cls: "sidebar-title" });
    const logoEl = titleEl.createEl("span", { cls: "space-command-logo clickable-logo", text: "\u2423\u2318" });
    logoEl.addEventListener("click", () => this.onShowAbout());
    switch (this.activeTab) {
      case "todos":
        titleEl.appendText(" TODOs");
        break;
      case "ideas":
        titleEl.appendText(" IDEAs");
        break;
      case "snoozed":
        titleEl.appendText(" Snoozed");
        break;
    }
    const tabNav = headerDiv.createEl("div", { cls: "sidebar-tab-nav" });
    if (this.shouldShowTriageAlert()) {
      const triageBtn = tabNav.createEl("button", {
        cls: "sidebar-tab-btn triage-alert-btn",
        attr: { "aria-label": "Triage needed" }
      });
      triageBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4"/><path d="m5.5 5.5 3 3"/><path d="M2 12h4"/><path d="m5.5 18.5 3-3"/><path d="M12 22v-4"/><path d="m18.5 18.5-3-3"/><path d="M22 12h-4"/><path d="m18.5 5.5-3 3"/><circle cx="12" cy="12" r="4"/></svg>';
      triageBtn.addEventListener("click", () => this.onShowTriage());
    }
    const todosTab = tabNav.createEl("button", {
      cls: `sidebar-tab-btn ${this.activeTab === "todos" ? "active" : ""}`,
      attr: { "aria-label": "TODOs" }
    });
    todosTab.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.5"/><path d="m9 11 3 3L22 4"/></svg>';
    todosTab.addEventListener("click", () => {
      this.activeTab = "todos";
      this.render();
    });
    const ideasTab = tabNav.createEl("button", {
      cls: `sidebar-tab-btn ${this.activeTab === "ideas" ? "active" : ""}`,
      attr: { "aria-label": "Ideas" }
    });
    ideasTab.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18h6"></path><path d="M10 22h4"></path><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"></path></svg>';
    ideasTab.addEventListener("click", () => {
      this.activeTab = "ideas";
      this.render();
    });
    const snoozedTab = tabNav.createEl("button", {
      cls: `sidebar-tab-btn ${this.activeTab === "snoozed" ? "active" : ""}`,
      attr: { "aria-label": "Snoozed" }
    });
    snoozedTab.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>';
    snoozedTab.addEventListener("click", () => {
      this.activeTab = "snoozed";
      this.render();
    });
    const menuBtn = headerDiv.createEl("button", {
      cls: "clickable-icon sidebar-menu-btn",
      attr: { "aria-label": "Menu" }
    });
    menuBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
    menuBtn.addEventListener("click", (evt) => {
      const menu = new import_obsidian8.Menu();
      menu.addItem((item) => {
        item.setTitle("Refresh").setIcon("refresh-cw").onClick(async () => {
          menuBtn.addClass("rotating");
          await this.scanner.scanVault();
          setTimeout(() => menuBtn.removeClass("rotating"), 500);
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Embed Syntax").setIcon("copy");
        const submenu = item.setSubmenu();
        submenu.addItem((subItem) => {
          subItem.setTitle("IDEA code block").setIcon("code").onClick(() => {
            navigator.clipboard.writeText("```focus-ideas\n```");
            showNotice("Copied IDEA code block syntax");
          });
        });
        submenu.addItem((subItem) => {
          subItem.setTitle("IDEA inline").setIcon("brackets").onClick(() => {
            navigator.clipboard.writeText("{{focus-ideas}}");
            showNotice("Copied IDEA inline syntax");
          });
        });
        submenu.addItem((subItem) => {
          subItem.setTitle("TODO code block").setIcon("code").onClick(() => {
            navigator.clipboard.writeText("```focus-todos\n```");
            showNotice("Copied TODO code block syntax");
          });
        });
        submenu.addItem((subItem) => {
          subItem.setTitle("TODO inline").setIcon("brackets").onClick(() => {
            navigator.clipboard.writeText("{{focus-todos}}");
            showNotice("Copied TODO inline syntax");
          });
        });
      });
      menu.addItem((item) => {
        item.setTitle("Triage").setIcon("siren").onClick(() => this.onShowTriage());
      });
      menu.addItem((item) => {
        item.setTitle("Stats").setIcon("bar-chart-2").onClick(() => this.onShowStats());
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("About").setIcon("info").onClick(() => this.onShowAbout());
      });
      menu.addItem((item) => {
        item.setTitle("Settings").setIcon("settings").onClick(() => {
          this.app.setting.open();
          this.app.setting.openTabById("space-command");
        });
      });
      menu.showAtMouseEvent(evt);
    });
    const content = container.createEl("div", { cls: "sidebar-content" });
    switch (this.activeTab) {
      case "todos":
        this.renderTodosContent(content);
        break;
      case "ideas":
        this.renderIdeasContent(content);
        break;
      case "snoozed":
        this.renderSnoozedContent(content);
        break;
    }
  }
  renderTodosContent(container) {
    this.renderProjects(container);
    this.renderActiveTodos(container);
    this.renderRecentTodones(container);
  }
  renderIdeasContent(container) {
    this.renderPrinciples(container);
    this.renderActiveIdeas(container);
  }
  renderSnoozedContent(container) {
    this.renderSnoozedTodos(container);
    this.renderSnoozedIdeas(container);
  }
  renderSnoozedTodos(container) {
    let todos = this.scanner.getTodos();
    todos = todos.filter(
      (todo) => todo.tags.includes("#future") || todo.tags.includes("#snooze") || todo.tags.includes("#snoozed")
    );
    todos = todos.filter(
      (todo) => !todo.tags.includes("#idea") && !todo.tags.includes("#ideas") && !todo.tags.includes("#ideation")
    );
    todos = todos.filter((todo) => todo.parentLineNumber === void 0);
    if (this.activeTagFilter) {
      todos = todos.filter((todo) => todo.tags.includes(this.activeTagFilter));
    }
    todos = this.sortTodosByPriority(todos);
    const section = container.createEl("div", { cls: "snoozed-todos-section" });
    const header = section.createEl("div", {
      cls: "todo-section-header snoozed-todos-header"
    });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "Snoozed TODOs";
    this.renderFilterIndicator(header);
    if (todos.length === 0) {
      section.createEl("div", {
        text: this.activeTagFilter ? `No snoozed TODOs matching ${this.activeTagFilter}` : "No snoozed TODOs",
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "todo-list" });
    for (const todo of todos) {
      this.renderListItem(list, todo, this.todoConfig);
    }
  }
  renderSnoozedIdeas(container) {
    let ideas = this.scanner.getIdeas();
    ideas = ideas.filter(
      (idea) => idea.tags.includes("#future") || idea.tags.includes("#snooze") || idea.tags.includes("#snoozed")
    );
    ideas = ideas.filter((idea) => idea.parentLineNumber === void 0);
    if (this.activeTagFilter) {
      ideas = ideas.filter((idea) => idea.tags.includes(this.activeTagFilter));
    }
    ideas = this.sortTodosByPriority(ideas);
    const section = container.createEl("div", { cls: "snoozed-ideas-section" });
    const header = section.createEl("div", {
      cls: "todo-section-header snoozed-ideas-header"
    });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "Snoozed Ideas";
    this.renderFilterIndicator(header);
    if (ideas.length === 0) {
      section.createEl("div", {
        text: this.activeTagFilter ? `No snoozed ideas matching ${this.activeTagFilter}` : "No snoozed ideas",
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "idea-list" });
    for (const idea of ideas) {
      this.renderListItem(list, idea, this.ideaConfig);
    }
  }
  sortTodosByPriority(todos) {
    return [...todos].sort(compareTodoItems);
  }
  /**
   * Render filter indicator button after section title if a filter is active.
   * Clicking the button clears the filter.
   */
  renderFilterIndicator(header) {
    if (!this.activeTagFilter)
      return;
    const filterBtn = header.createEl("button", {
      cls: "filter-indicator-btn",
      attr: { "aria-label": `Clear filter: ${this.activeTagFilter}` }
    });
    filterBtn.createEl("span", { cls: "filter-indicator-tag", text: this.activeTagFilter });
    filterBtn.createEl("span", { cls: "filter-indicator-x", text: "\xD7" });
    filterBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.activeTagFilter = null;
      this.render();
    });
  }
  renderProjects(container) {
    let projects = this.projectManager.getProjects();
    const section = container.createEl("div", { cls: "projects-section" });
    const header = section.createEl("div", {
      cls: "todo-section-header projects-header"
    });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "Focus";
    const focusModeBtn = header.createEl("button", {
      cls: `clickable-icon focus-mode-toggle-btn${this.focusModeEnabled ? " active" : ""}`,
      attr: { "aria-label": this.focusModeEnabled ? "Show all projects" : "Show only focused" }
    });
    focusModeBtn.innerHTML = this.focusModeEnabled ? '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>';
    focusModeBtn.addEventListener("click", () => {
      this.focusModeEnabled = !this.focusModeEnabled;
      showNotice(this.focusModeEnabled ? "Focus mode enabled" : "Focus mode disabled");
      this.render();
    });
    this.renderFilterIndicator(header);
    if (this.focusModeEnabled) {
      projects = projects.filter((p) => p.highestPriority === 0);
    }
    if (projects.length === 0) {
      section.createEl("div", {
        text: this.focusModeEnabled ? "No focused projects" : "No focus projects yet",
        cls: "todo-empty"
      });
      return;
    }
    projects.sort((a, b) => {
      const aHasFocus = a.highestPriority === 0;
      const bHasFocus = b.highestPriority === 0;
      if (aHasFocus && !bHasFocus)
        return -1;
      if (!aHasFocus && bHasFocus)
        return 1;
      const priorityDiff = a.highestPriority - b.highestPriority;
      if (priorityDiff !== 0)
        return priorityDiff;
      return b.count - a.count;
    });
    const totalCount = projects.length;
    if (this.focusListLimit > 0) {
      projects = projects.slice(0, this.focusListLimit);
    }
    const list = section.createEl("ul", { cls: "project-list" });
    for (const project of projects) {
      this.renderProjectItem(list, project);
    }
    if (totalCount > projects.length) {
      const moreIndicator = section.createEl("div", {
        cls: "todo-more-indicator",
        text: `+${totalCount - projects.length} more`
      });
      moreIndicator.setAttribute("title", `Showing ${projects.length} of ${totalCount} projects`);
    }
  }
  renderProjectItem(list, project) {
    const hasFocusItems = project.highestPriority === 0;
    const item = list.createEl("li", { cls: `project-item${hasFocusItems ? " project-focus" : ""}` });
    item.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.contextMenuHandler.showProjectMenu(
        e,
        project,
        this.scanner,
        () => this.render(),
        (tag) => {
          this.activeTagFilter = tag;
          this.render();
        }
      );
    });
    const checkbox = item.createEl("input", {
      type: "checkbox",
      cls: "project-checkbox"
    });
    checkbox.addEventListener("change", async () => {
      checkbox.checked = false;
      const confirmed = await this.confirmCompleteProject(project);
      if (confirmed) {
        await this.completeAllProjectTodos(project);
      }
    });
    const textSpan = item.createEl("span", { cls: "project-text" });
    textSpan.appendText(project.tag + " ");
    const infoIcon = item.createEl("span", {
      cls: "project-info-icon",
      text: "\u24D8",
      attr: { "aria-label": "Project info" }
    });
    infoIcon.addEventListener("click", async (e) => {
      e.stopPropagation();
      await this.showProjectInfoPopup(project, infoIcon);
    });
    const link = item.createEl("a", {
      text: "\u2192",
      cls: "project-link",
      href: "#"
    });
    link.addEventListener("click", async (e) => {
      e.preventDefault();
      await this.projectManager.openProjectFile(project.tag);
    });
  }
  async showProjectInfoPopup(project, trigger) {
    this.closeInfoPopup();
    this.closeDropdown();
    const info = await this.projectManager.getProjectFileInfo(project.tag);
    const popup = document.createElement("div");
    popup.className = "project-info-popup";
    popup.style.minWidth = "350px";
    popup.style.maxWidth = "450px";
    const sidebarRoot = this.leaf.getRoot();
    const isRightSidebar = sidebarRoot === this.app.workspace.rightSplit;
    const rect = trigger.getBoundingClientRect();
    popup.style.position = "fixed";
    popup.style.top = `${rect.top}px`;
    if (isRightSidebar) {
      popup.style.right = `${window.innerWidth - rect.left + 8}px`;
      popup.classList.add("popup-left");
    } else {
      popup.style.left = `${rect.right + 8}px`;
      popup.classList.add("popup-right");
    }
    if (info) {
      const title = popup.createEl("div", { cls: "project-info-title" });
      title.appendText(project.tag);
      if (info.description) {
        const desc = popup.createEl("div", { cls: "project-info-description" });
        const component = new import_obsidian8.Component();
        component.load();
        await import_obsidian8.MarkdownRenderer.render(this.app, info.description, desc, info.filepath, component);
      } else {
        const desc = popup.createEl("div", { cls: "project-info-description project-info-empty" });
        desc.appendText("No description available.");
      }
      const projectPrinciples = this.scanner.getPrinciples().filter(
        (p) => p.tags.includes(project.tag) || p.inferredFileTag === project.tag
      );
      if (projectPrinciples.length > 0) {
        popup.createEl("div", { cls: "project-info-separator" });
        const principlesHeader = popup.createEl("div", { cls: "project-info-section-header" });
        principlesHeader.appendText("Principles");
        const principlesList = popup.createEl("ul", { cls: "project-info-principle-items" });
        for (const principle of projectPrinciples) {
          const li = principlesList.createEl("li", { cls: "project-info-principle-item" });
          let displayText = principle.text.replace(/#principles?\b/gi, "").replace(new RegExp(project.tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b", "gi"), "").replace(/\s+/g, " ").trim();
          displayText = displayText.replace(/^[-*+]\s*/, "");
          const principleComponent = new import_obsidian8.Component();
          principleComponent.load();
          await import_obsidian8.MarkdownRenderer.render(this.app, displayText, li, (info == null ? void 0 : info.filepath) || "", principleComponent);
        }
      }
      if (info.principles.length > 0) {
        popup.createEl("div", { cls: "project-info-separator" });
        const tagsHeader = popup.createEl("div", { cls: "project-info-section-header" });
        tagsHeader.appendText("Tags");
        const tagsList = popup.createEl("div", { cls: "project-info-principles" });
        for (const principle of info.principles) {
          const tagItem = tagsList.createEl("span", { cls: "project-info-principle-tag" });
          tagItem.appendText(principle);
        }
      }
      popup.createEl("div", { cls: "project-info-separator" });
      const linkContainer = popup.createEl("div", { cls: "project-info-link-container" });
      const openLink = linkContainer.createEl("a", {
        cls: "project-info-link",
        href: "#"
      });
      openLink.appendText("Open project file \u2192");
      openLink.addEventListener("click", async (e) => {
        e.preventDefault();
        this.closeInfoPopup();
        const filepath = this.projectManager.getProjectFilePath(project.tag);
        const file = this.app.vault.getAbstractFileByPath(filepath);
        if (file instanceof import_obsidian8.TFile) {
          const leaf = this.app.workspace.getLeaf("tab");
          await leaf.openFile(file);
        }
      });
    } else {
      const noFile = popup.createEl("div", { cls: "project-info-no-file" });
      noFile.appendText("Project file not found.");
      const createHint = popup.createEl("div", { cls: "project-info-hint" });
      createHint.appendText("Click \u2192 to create it.");
    }
    document.body.appendChild(popup);
    this.openInfoPopup = popup;
    const popupRect = popup.getBoundingClientRect();
    if (popupRect.bottom > window.innerHeight - 10) {
      const overflow = popupRect.bottom - window.innerHeight + 10;
      popup.style.top = `${rect.top - overflow}px`;
    }
    const closeHandler = (e) => {
      if (!popup.contains(e.target) && e.target !== trigger) {
        this.closeInfoPopup();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  closeInfoPopup() {
    if (this.openInfoPopup) {
      this.openInfoPopup.remove();
      this.openInfoPopup = null;
    }
  }
  renderActiveTodos(container) {
    let todos = this.scanner.getTodos();
    todos = todos.filter(
      (todo) => !todo.tags.includes("#future") && !todo.tags.includes("#snooze") && !todo.tags.includes("#snoozed")
    );
    todos = todos.filter(
      (todo) => !todo.tags.includes("#idea") && !todo.tags.includes("#ideas") && !todo.tags.includes("#ideation")
    );
    if (this.focusModeEnabled) {
      todos = todos.filter((todo) => {
        if (todo.parentLineNumber === void 0) {
          return true;
        }
        if (!todo.tags.includes("#focus")) {
          return false;
        }
        const parent = this.scanner.getTodos().find(
          (t) => t.filePath === todo.filePath && t.lineNumber === todo.parentLineNumber
        );
        return !(parent == null ? void 0 : parent.tags.includes("#focus"));
      });
    } else {
      todos = todos.filter((todo) => todo.parentLineNumber === void 0);
    }
    const allTodones = this.scanner.getTodones();
    const allTodosForChildLookup = this.scanner.getTodos();
    todos = todos.filter((todo) => {
      if (!todo.isHeader) {
        return true;
      }
      if (!todo.childLineNumbers) {
        return true;
      }
      if (todo.childLineNumbers.length === 0) {
        return false;
      }
      const hasActiveChild = todo.childLineNumbers.some((childLine) => {
        const isComplete = allTodones.some((t) => t.filePath === todo.filePath && t.lineNumber === childLine);
        if (isComplete)
          return false;
        const childItem = allTodosForChildLookup.find((t) => t.filePath === todo.filePath && t.lineNumber === childLine);
        if (!childItem) {
          return false;
        }
        const isSnoozed = childItem.tags.includes("#future") || childItem.tags.includes("#snooze") || childItem.tags.includes("#snoozed");
        if (isSnoozed)
          return false;
        return true;
      });
      return hasActiveChild;
    });
    if (this.activeTagFilter) {
      todos = todos.filter((todo) => todo.tags.includes(this.activeTagFilter));
    }
    if (this.focusModeEnabled) {
      if (this.focusModeIncludeProjects) {
        const focusedProjects = this.projectManager.getProjects().filter((p) => p.highestPriority === 0).map((p) => p.tag);
        todos = todos.filter(
          (todo) => todo.tags.includes("#focus") || todo.tags.some((tag) => focusedProjects.includes(tag))
        );
      } else {
        todos = todos.filter((todo) => todo.tags.includes("#focus"));
      }
    }
    todos = this.sortTodosByPriority(todos);
    const totalCount = todos.length;
    if (this.activeTodosLimit > 0) {
      todos = todos.slice(0, this.activeTodosLimit);
    }
    const section = container.createEl("div", { cls: "todo-section" });
    const header = section.createEl("div", { cls: "todo-section-header" });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "TODO";
    this.renderFilterIndicator(header);
    if (totalCount === 0) {
      let emptyText = "No TODOs";
      if (this.focusModeEnabled) {
        emptyText = "No focused TODOs";
      } else if (this.activeTagFilter) {
        emptyText = `No TODOs matching ${this.activeTagFilter}`;
      }
      section.createEl("div", {
        text: emptyText,
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "todo-list" });
    for (const todo of todos) {
      this.renderTodoItem(list, todo);
    }
    if (totalCount > todos.length) {
      const moreIndicator = section.createEl("div", {
        cls: "todo-more-indicator",
        text: `+${totalCount - todos.length} more`
      });
      moreIndicator.setAttribute("title", `Showing ${todos.length} of ${totalCount} TODOs`);
    }
  }
  renderTodoItem(list, todo, isChild = false) {
    this.renderListItem(list, todo, this.todoConfig, isChild);
  }
  renderRecentTodones(container) {
    let allTodones = this.scanner.getTodones(100);
    if (this.focusModeEnabled) {
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      allTodones = allTodones.filter((todone) => {
        const completionDate = this.extractCompletionDate(todone.text);
        return completionDate === today;
      });
      if (this.focusModeIncludeProjects) {
        const focusedProjects = this.projectManager.getProjects().filter((p) => p.highestPriority === 0).map((p) => p.tag);
        allTodones = allTodones.filter(
          (todone) => todone.tags.includes("#focus") || todone.tags.some((tag) => focusedProjects.includes(tag))
        );
      } else {
        allTodones = allTodones.filter((todone) => todone.tags.includes("#focus"));
      }
    }
    const todones = allTodones.slice(0, this.recentTodonesLimit);
    const section = container.createEl("div", { cls: "todone-section" });
    const header = section.createEl("div", {
      cls: "todo-section-header todone-header"
    });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "DONE";
    const fileLink = header.createEl("a", {
      text: this.defaultTodoneFile,
      cls: "done-file-link",
      href: "#"
    });
    fileLink.addEventListener("click", async (e) => {
      e.preventDefault();
      const file = this.app.vault.getAbstractFileByPath(this.defaultTodoneFile);
      if (file instanceof import_obsidian8.TFile) {
        await this.app.workspace.getLeaf(false).openFile(file);
      }
    });
    if (allTodones.length === 0) {
      let emptyText = "No completed TODOs";
      if (this.focusModeEnabled) {
        emptyText = "No focused TODOs completed today";
      }
      section.createEl("div", {
        text: emptyText,
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "todo-list todone-list" });
    for (const todone of todones) {
      this.renderTodoneItem(list, todone);
    }
  }
  renderTodoneItem(list, todone) {
    const item = list.createEl("li", { cls: "todo-item todone-item" });
    const checkbox = item.createEl("input", {
      type: "checkbox",
      cls: "todo-checkbox",
      attr: { checked: "checked" }
    });
    checkbox.addEventListener("change", async () => {
      checkbox.disabled = true;
      const success = await this.processor.uncompleteTodo(todone);
      if (!success) {
        checkbox.disabled = false;
        checkbox.checked = true;
      }
    });
    const textSpan = item.createEl("span", { cls: "todo-text todone-text" });
    const cleanText = todone.text.replace(/#todones?\b/g, "").trim();
    const completionDate = this.extractCompletionDate(cleanText);
    const displayText = this.stripMarkdownSyntax(cleanText);
    const textWithoutTags = displayText.replace(/#[\w-]+/g, "").replace(/@\d{4}-\d{2}-\d{2}/g, "").replace(/\s+/g, " ").trim();
    textSpan.appendText(textWithoutTags);
    textSpan.appendText(" ");
    const tags = extractTags(cleanText);
    this.renderTagDropdown(tags, item, todone);
    if (completionDate) {
      item.createEl("span", {
        cls: "todo-date muted-pill",
        text: completionDate
      });
    }
    const link = item.createEl("a", {
      text: "\u2192",
      cls: "todo-link",
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      openFileAtLine(this.app, todone.file, todone.lineNumber);
    });
  }
  renderPrinciples(container) {
    let principles = this.scanner.getPrinciples();
    principles = principles.filter((p) => p.parentLineNumber === void 0);
    if (this.activeTagFilter) {
      principles = principles.filter((p) => p.tags.includes(this.activeTagFilter));
    }
    const section = container.createEl("div", { cls: "principles-section" });
    const header = section.createEl("div", {
      cls: "todo-section-header principles-header"
    });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "Principles";
    this.renderFilterIndicator(header);
    if (principles.length === 0) {
      section.createEl("div", {
        text: this.activeTagFilter ? `No principles matching ${this.activeTagFilter}` : "No principles yet",
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "principle-list" });
    for (const principle of principles) {
      this.renderPrincipleItem(list, principle);
    }
  }
  renderPrincipleItem(list, principle) {
    this.renderListItem(list, principle, this.principleConfig);
  }
  renderActiveIdeas(container) {
    let ideas = this.scanner.getIdeas();
    ideas = ideas.filter(
      (idea) => !idea.tags.includes("#future") && !idea.tags.includes("#snooze") && !idea.tags.includes("#snoozed")
    );
    ideas = ideas.filter((idea) => idea.parentLineNumber === void 0);
    if (this.activeTagFilter) {
      ideas = ideas.filter((idea) => idea.tags.includes(this.activeTagFilter));
    }
    ideas = this.sortTodosByPriority(ideas);
    const section = container.createEl("div", { cls: "ideas-section" });
    const header = section.createEl("div", { cls: "todo-section-header" });
    const titleSpan = header.createEl("span", { cls: "todo-section-title" });
    titleSpan.textContent = "Ideas";
    this.renderFilterIndicator(header);
    if (ideas.length === 0) {
      section.createEl("div", {
        text: this.activeTagFilter ? `No ideas matching ${this.activeTagFilter}` : "No ideas yet",
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "idea-list" });
    for (const idea of ideas) {
      this.renderIdeaItem(list, idea);
    }
  }
  renderIdeaItem(list, idea) {
    this.renderListItem(list, idea, this.ideaConfig);
  }
  async confirmCompleteProject(project) {
    return new Promise((resolve) => {
      const modal = new import_obsidian8.Modal(this.app);
      modal.titleEl.setText("Complete All Project TODOs?");
      modal.contentEl.createEl("p", {
        text: `This will mark all ${project.count} TODO(s) for project ${project.tag} as complete. This action cannot be undone.`
      });
      const buttonContainer = modal.contentEl.createEl("div", {
        cls: "modal-button-container"
      });
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "flex-end";
      buttonContainer.style.gap = "8px";
      buttonContainer.style.marginTop = "16px";
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      const confirmBtn = buttonContainer.createEl("button", {
        text: "Complete All",
        cls: "mod-cta"
      });
      confirmBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  async completeAllProjectTodos(project) {
    const todos = this.scanner.getTodos().filter(
      (todo) => todo.tags.includes(project.tag)
    );
    let completed = 0;
    let failed = 0;
    for (const todo of todos) {
      const success = await this.processor.completeTodo(
        todo,
        this.defaultTodoneFile
      );
      if (success) {
        completed++;
      } else {
        failed++;
      }
    }
    if (failed > 0) {
      showNotice(`Completed ${completed} TODO(s), ${failed} failed. See console for details.`);
    } else {
      showNotice(`Completed all ${completed} TODO(s) for ${project.tag}!`);
    }
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  defaultTodoneFile: "todos/done.md",
  showSidebarByDefault: true,
  dateFormat: "YYYY-MM-DD",
  excludeTodoneFilesFromRecent: true,
  defaultProjectsFolder: "projects/",
  focusListLimit: 5,
  activeTodosLimit: 0,
  priorityTags: ["#p0", "#p1", "#p2", "#p3", "#p4"],
  recentTodonesLimit: 5,
  excludeFoldersFromProjects: ["log"],
  // Focus mode settings
  focusModeIncludeProjects: false,
  // Tab lock settings
  showTabLockButton: false,
  // Link rendering settings
  makeLinksClickable: true,
  // LLM/Define settings
  llmEnabled: true,
  llmUrl: "http://localhost:11434",
  llmModel: "llama3.2",
  llmPrompt: "Explain what this means in plain language, providing context if it's a technical term:",
  llmRewritePrompt: "Rewrite the following text to improve clarity, accuracy, and brevity. Keep the same tone and intent. Avoid clich\xE9s and filler words. Output only the rewritten text, nothing else:",
  llmReviewPrompt: "Review the following text and provide specific suggestions for improvement. Focus on clarity, accuracy, structure, and style. Be concise and actionable:",
  llmTimeout: 3e4,
  // Triage settings
  triageSnoozedThreshold: 10,
  triageActiveThreshold: 20
};

// src/SlackConverter.ts
function convertToSlackMarkdown(markdown) {
  const lines = markdown.split("\n");
  const result = [];
  let inCodeBlock = false;
  let codeBlockContent = [];
  for (const line of lines) {
    if (line.trim().startsWith("```")) {
      if (!inCodeBlock) {
        inCodeBlock = true;
        codeBlockContent = [];
        result.push("```");
      } else {
        inCodeBlock = false;
        result.push(...codeBlockContent);
        result.push("```");
      }
      continue;
    }
    if (inCodeBlock) {
      codeBlockContent.push(line);
      continue;
    }
    let processed = line;
    const headingMatch = processed.match(/^(#{1,6})\s+(.+)$/);
    if (headingMatch) {
      processed = `*${headingMatch[2].trim()}*`;
    } else {
      processed = convertInlineFormatting(processed);
    }
    result.push(processed);
  }
  return result.join("\n");
}
function convertInlineFormatting(text) {
  let result = text;
  const codeSpans = [];
  result = result.replace(/`([^`]+)`/g, (_, code) => {
    codeSpans.push(code);
    return `\0CODE${codeSpans.length - 1}\0`;
  });
  result = result.replace(/\*\*\*(.+?)\*\*\*/g, "\0BI_START\0$1\0BI_END\0");
  result = result.replace(/___(.+?)___/g, "\0BI_START\0$1\0BI_END\0");
  result = result.replace(/\*\*(.+?)\*\*/g, "\0B_START\0$1\0B_END\0");
  result = result.replace(/\*([^*\x00]+?)\*/g, "_$1_");
  result = result.replace(/\x00B_START\x00/g, "*");
  result = result.replace(/\x00B_END\x00/g, "*");
  result = result.replace(/\x00BI_START\x00/g, "_*");
  result = result.replace(/\x00BI_END\x00/g, "*_");
  result = result.replace(/~~(.+?)~~/g, "~$1~");
  result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1 ($2)");
  result = result.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, "$1 ($2)");
  result = result.replace(/\x00CODE(\d+)\x00/g, (_, idx) => {
    return `\`${codeSpans[parseInt(idx)]}\``;
  });
  return result;
}

// src/LLMClient.ts
var import_obsidian9 = require("obsidian");
var LLMClient = class {
  constructor(config) {
    this.config = config;
  }
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
  async define(text) {
    var _a;
    const fullPrompt = `${this.config.prompt}

"${text}"`;
    try {
      const response = await (0, import_obsidian9.requestUrl)({
        url: `${this.config.url}/api/generate`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.config.model,
          prompt: fullPrompt,
          stream: false
        }),
        throw: false
      });
      if (response.status !== 200) {
        console.error(`[Space Command] Define request failed`, {
          status: response.status,
          model: this.config.model,
          url: this.config.url,
          response: response.text
        });
        return {
          success: false,
          error: "request_failed"
        };
      }
      const data = response.json;
      return {
        success: true,
        definition: ((_a = data.response) == null ? void 0 : _a.trim()) || "No response received"
      };
    } catch (error) {
      console.error(`[Space Command] Define request error`, {
        model: this.config.model,
        url: this.config.url,
        error: error instanceof Error ? error.message : error
      });
      return {
        success: false,
        error: "connection_failed"
      };
    }
  }
  async rewrite(text) {
    var _a;
    const fullPrompt = `${this.config.rewritePrompt}

${text}`;
    try {
      const response = await (0, import_obsidian9.requestUrl)({
        url: `${this.config.url}/api/generate`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.config.model,
          prompt: fullPrompt,
          stream: false
        }),
        throw: false
      });
      if (response.status !== 200) {
        console.error(`[Space Command] Rewrite request failed`, {
          status: response.status,
          model: this.config.model,
          url: this.config.url,
          response: response.text
        });
        return {
          success: false,
          error: "request_failed"
        };
      }
      const data = response.json;
      return {
        success: true,
        result: ((_a = data.response) == null ? void 0 : _a.trim()) || "No response received"
      };
    } catch (error) {
      console.error(`[Space Command] Rewrite request error`, {
        model: this.config.model,
        url: this.config.url,
        error: error instanceof Error ? error.message : error
      });
      return {
        success: false,
        error: "connection_failed"
      };
    }
  }
  async review(text) {
    var _a;
    const fullPrompt = `${this.config.reviewPrompt}

${text}`;
    try {
      const response = await (0, import_obsidian9.requestUrl)({
        url: `${this.config.url}/api/generate`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.config.model,
          prompt: fullPrompt,
          stream: false
        }),
        throw: false
      });
      if (response.status !== 200) {
        console.error(`[Space Command] Review request failed`, {
          status: response.status,
          model: this.config.model,
          url: this.config.url,
          response: response.text
        });
        return {
          success: false,
          error: "request_failed"
        };
      }
      const data = response.json;
      return {
        success: true,
        result: ((_a = data.response) == null ? void 0 : _a.trim()) || "No response received"
      };
    } catch (error) {
      console.error(`[Space Command] Review request error`, {
        model: this.config.model,
        url: this.config.url,
        error: error instanceof Error ? error.message : error
      });
      return {
        success: false,
        error: "connection_failed"
      };
    }
  }
  getModel() {
    return this.config.model;
  }
};

// src/DefineTooltip.ts
var import_obsidian10 = require("obsidian");
var DefineTooltip = class {
  constructor(app) {
    this.tooltip = null;
    this.closeHandler = null;
    this.escapeHandler = null;
    this.searchTerm = "";
    this.currentContent = "";
    this.options = {};
    this.component = null;
    this.app = app;
  }
  show(editor, content, isLoading = false, term = "", options = {}) {
    this.close();
    this.searchTerm = term;
    this.currentContent = content;
    this.options = options;
    const cm = editor.cm;
    if (!cm)
      return;
    const cursor = editor.getCursor("to");
    let coords = null;
    if (cm.coordsAtPos) {
      const line = cm.state.doc.line(cursor.line + 1);
      const pos = line.from + cursor.ch;
      coords = cm.coordsAtPos(pos);
    } else if (cm.charCoords) {
      coords = cm.charCoords({ line: cursor.line, ch: cursor.ch }, "page");
    }
    if (!coords)
      return;
    this.tooltip = document.createElement("div");
    this.tooltip.className = "define-tooltip";
    if (isLoading) {
      this.tooltip.classList.add("define-tooltip-loading");
    }
    const headerEl = this.tooltip.createEl("div", { cls: "define-tooltip-header" });
    headerEl.createEl("span", { cls: "define-tooltip-logo space-command-logo", text: "\u2423\u2318" });
    const commandLabel = this.getCommandLabel(options.commandType);
    headerEl.createEl("span", { cls: "define-tooltip-command-type", text: commandLabel });
    const closeBtn = headerEl.createEl("button", {
      cls: "define-tooltip-close",
      text: "\xD7",
      attr: { "aria-label": "Close" }
    });
    closeBtn.addEventListener("click", () => this.close());
    const contentEl = this.tooltip.createEl("div", { cls: "define-tooltip-content" });
    if (isLoading) {
      contentEl.createEl("span", { cls: "define-tooltip-spinner" });
      contentEl.createSpan({ text: options.loadingText || "Loading..." });
    } else {
      this.renderMarkdownContent(contentEl, content);
    }
    if (!isLoading && (options.showApply || options.onApply)) {
      this.createActionsBar();
    }
    this.tooltip.style.position = "fixed";
    this.tooltip.style.top = `${coords.bottom + 8}px`;
    this.tooltip.style.left = `${coords.left}px`;
    document.body.appendChild(this.tooltip);
    this.adjustPosition(coords);
  }
  createActionsBar() {
    if (!this.tooltip)
      return;
    const actionsEl = this.tooltip.createEl("div", { cls: "define-tooltip-actions" });
    const copyBtn = actionsEl.createEl("button", {
      cls: "define-tooltip-btn define-tooltip-copy-btn",
      text: "Copy"
    });
    copyBtn.addEventListener("click", async () => {
      await navigator.clipboard.writeText(this.currentContent);
      showNotice("Copied to clipboard");
    });
    if (this.options.onApply) {
      const applyBtn = actionsEl.createEl("button", {
        cls: "define-tooltip-btn define-tooltip-apply-btn",
        text: "Apply"
      });
      applyBtn.addEventListener("click", () => {
        if (this.options.onApply) {
          this.options.onApply(this.currentContent);
        }
        this.close();
      });
    }
  }
  adjustPosition(coords) {
    if (!this.tooltip)
      return;
    const rect = this.tooltip.getBoundingClientRect();
    const margin = 10;
    if (rect.right > window.innerWidth - margin) {
      const newLeft = Math.max(margin, window.innerWidth - rect.width - margin);
      this.tooltip.style.left = `${newLeft}px`;
    }
    if (rect.left < margin) {
      this.tooltip.style.left = `${margin}px`;
    }
    if (rect.bottom > window.innerHeight - margin) {
      const aboveTop = coords.top - rect.height - 8;
      if (aboveTop >= margin) {
        this.tooltip.style.top = `${aboveTop}px`;
      } else {
        this.tooltip.style.top = `${margin}px`;
        const maxHeight = window.innerHeight - 2 * margin;
        if (rect.height > maxHeight) {
          this.tooltip.style.maxHeight = `${maxHeight}px`;
          this.tooltip.style.overflowY = "auto";
        }
      }
    }
    this.closeHandler = (e) => {
      if (this.tooltip && !this.tooltip.contains(e.target)) {
        this.close();
      }
    };
    this.escapeHandler = (e) => {
      if (e.key === "Escape") {
        this.close();
      }
    };
    setTimeout(() => {
      document.addEventListener("click", this.closeHandler);
      document.addEventListener("keydown", this.escapeHandler);
    }, 100);
  }
  getCommandLabel(commandType) {
    switch (commandType) {
      case "define":
        return "Define";
      case "rewrite":
        return "Rewrite";
      case "review":
        return "Review";
      default:
        return "";
    }
  }
  async renderMarkdownContent(container, content) {
    if (this.component) {
      this.component.unload();
    }
    this.component = new import_obsidian10.Component();
    this.component.load();
    let processedContent = content;
    if (this.searchTerm && this.searchTerm.trim() !== "") {
      const regex = new RegExp(`(${this.escapeRegex(this.searchTerm)})`, "gi");
      processedContent = content.replace(regex, "==$1==");
    }
    await import_obsidian10.MarkdownRenderer.render(
      this.app,
      processedContent,
      container,
      "",
      this.component
    );
  }
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  async updateContent(content, options) {
    if (!this.tooltip)
      return;
    this.currentContent = content;
    if (options) {
      this.options = { ...this.options, ...options };
    }
    this.tooltip.classList.remove("define-tooltip-loading");
    const contentEl = this.tooltip.querySelector(".define-tooltip-content");
    if (contentEl) {
      contentEl.empty();
      await this.renderMarkdownContent(contentEl, content);
    }
    const existingActions = this.tooltip.querySelector(".define-tooltip-actions");
    if (!existingActions && (this.options.showApply || this.options.onApply)) {
      this.createActionsBar();
    }
  }
  showError(modelName, onOpenSettings) {
    if (!this.tooltip)
      return;
    this.tooltip.classList.remove("define-tooltip-loading");
    const contentEl = this.tooltip.querySelector(".define-tooltip-content");
    if (contentEl) {
      contentEl.empty();
      const container = contentEl;
      container.appendText(`Could not connect to ${modelName}. Fix in `);
      const settingsLink = container.createEl("a", {
        text: "Settings",
        cls: "define-tooltip-settings-link"
      });
      settingsLink.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.close();
        onOpenSettings();
      });
      container.appendText(".");
    }
  }
  close() {
    if (this.component) {
      this.component.unload();
      this.component = null;
    }
    if (this.tooltip) {
      this.tooltip.remove();
      this.tooltip = null;
    }
    if (this.closeHandler) {
      document.removeEventListener("click", this.closeHandler);
      this.closeHandler = null;
    }
    if (this.escapeHandler) {
      document.removeEventListener("keydown", this.escapeHandler);
      this.escapeHandler = null;
    }
    this.searchTerm = "";
    this.currentContent = "";
    this.options = {};
  }
};

// src/TabLockManager.ts
var TabLockManager = class {
  constructor(app) {
    this.enabled = false;
    this.mutationObserver = null;
    this.updateTimeout = null;
    this.app = app;
  }
  /**
   * Enable the tab lock feature - adds lock buttons to all tab headers.
   */
  enable() {
    if (this.enabled)
      return;
    this.enabled = true;
    this.updateAllTabs();
    setTimeout(() => this.updateAllTabs(), 200);
    this.startObserving();
  }
  /**
   * Disable the tab lock feature - removes all lock buttons.
   */
  disable() {
    if (!this.enabled)
      return;
    this.enabled = false;
    this.stopObserving();
    this.removeAllButtons();
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
      this.updateTimeout = null;
    }
  }
  /**
   * Clean up resources.
   */
  destroy() {
    this.disable();
  }
  /**
   * Update all existing tabs with lock buttons.
   */
  updateAllTabs() {
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      this.addButtonToLeaf(leaf);
    }
    const allLeaves = this.getAllLeaves();
    for (const leaf of allLeaves) {
      this.addButtonToLeaf(leaf);
    }
  }
  /**
   * Get all leaves in the workspace.
   */
  getAllLeaves() {
    const leaves = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      leaves.push(leaf);
    });
    return leaves;
  }
  /**
   * Add a lock button to a specific leaf's tab header.
   * If forceRefresh is true, removes any existing button first.
   */
  addButtonToLeaf(leaf, forceRefresh = false) {
    if (!this.enabled)
      return;
    const tabHeader = leaf.tabHeaderEl;
    if (!tabHeader)
      return;
    if (!tabHeader.classList.contains("workspace-tab-header"))
      return;
    const dataType = tabHeader.getAttribute("data-type");
    if (dataType !== "markdown")
      return;
    const existingBtn = tabHeader.querySelector(".space-command-tab-lock-btn");
    if (existingBtn) {
      if (forceRefresh) {
        existingBtn.remove();
        const pinContainer = tabHeader.querySelector("[data-space-command-pin-handler]");
        if (pinContainer) {
          pinContainer.removeAttribute("data-space-command-pin-handler");
        }
      } else {
        return;
      }
    }
    const innerContainer = tabHeader.querySelector(".workspace-tab-header-inner");
    if (!innerContainer)
      return;
    const closeButton = innerContainer.querySelector(".workspace-tab-header-inner-close-button");
    const lockBtn = document.createElement("div");
    lockBtn.className = "space-command-tab-lock-btn workspace-tab-header-status-icon";
    lockBtn.setAttribute("aria-label", "Lock tab (pinned tabs open links in new tabs)");
    const isPinned = leaf.pinned === true;
    this.updateButtonState(lockBtn, isPinned);
    lockBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      const currentlyPinned = leaf.pinned === true;
      const newPinnedState = !currentlyPinned;
      leaf.setPinned(newPinnedState);
      this.updateButtonState(lockBtn, newPinnedState);
      setTimeout(() => {
        this.addButtonToLeaf(leaf, true);
      }, 50);
    });
    if (closeButton) {
      innerContainer.insertBefore(lockBtn, closeButton);
    } else {
      innerContainer.appendChild(lockBtn);
    }
    this.addPinClickHandler(tabHeader, leaf, lockBtn);
  }
  /**
   * Add a click handler to Obsidian's native pin icon for unlocking.
   * The pin icon appears when the tab is pinned.
   */
  addPinClickHandler(tabHeader, leaf, lockBtn) {
    const pinContainer = tabHeader.querySelector(
      ".workspace-tab-header-status-container"
    );
    if (!pinContainer)
      return;
    if (pinContainer.hasAttribute("data-space-command-pin-handler"))
      return;
    pinContainer.setAttribute("data-space-command-pin-handler", "true");
    pinContainer.addEventListener(
      "click",
      (e) => {
        const wasPinned = leaf.pinned === true;
        if (!wasPinned)
          return;
        e.stopPropagation();
        e.preventDefault();
        leaf.setPinned(false);
        tabHeader.classList.remove("space-command-tab-locked");
        setTimeout(() => {
          this.addButtonToLeaf(leaf, true);
        }, 50);
      },
      { capture: true }
    );
  }
  /**
   * Update the button's visual state based on pinned status.
   * When locked: hide the lock button and close button, let Obsidian's native pushpin show.
   * When unlocked: show the lock button (open padlock) and close button.
   */
  updateButtonState(button, isPinned) {
    button.classList.toggle("is-locked", isPinned);
    button.setAttribute("aria-label", isPinned ? "Unlock tab" : "Lock tab");
    const tabHeader = button.closest(".workspace-tab-header");
    if (tabHeader) {
      tabHeader.classList.toggle("space-command-tab-locked", isPinned);
    }
    button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>`;
  }
  /**
   * Remove all lock buttons and cleanup tab header classes.
   */
  removeAllButtons() {
    const buttons = document.querySelectorAll(".space-command-tab-lock-btn");
    buttons.forEach((btn) => btn.remove());
    const lockedTabs = document.querySelectorAll(".space-command-tab-locked");
    lockedTabs.forEach(
      (tab) => tab.classList.remove("space-command-tab-locked")
    );
    const pinContainers = document.querySelectorAll(
      "[data-space-command-pin-handler]"
    );
    pinContainers.forEach(
      (container) => container.removeAttribute("data-space-command-pin-handler")
    );
  }
  /**
   * Schedule a debounced update of all tabs.
   */
  scheduleUpdate() {
    if (this.updateTimeout) {
      clearTimeout(this.updateTimeout);
    }
    this.updateTimeout = setTimeout(() => {
      this.updateTimeout = null;
      this.updateAllTabs();
    }, 50);
  }
  /**
   * Start observing DOM changes to add buttons to new tabs.
   */
  startObserving() {
    if (this.mutationObserver)
      return;
    this.mutationObserver = new MutationObserver((mutations) => {
      var _a, _b, _c, _d;
      let shouldUpdate = false;
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          for (const node of Array.from(mutation.addedNodes)) {
            if (node instanceof HTMLElement) {
              if (((_a = node.classList) == null ? void 0 : _a.contains("workspace-tab-header")) || ((_b = node.querySelector) == null ? void 0 : _b.call(node, ".workspace-tab-header")) || ((_c = node.classList) == null ? void 0 : _c.contains("workspace-tab-header-inner")) || ((_d = node.closest) == null ? void 0 : _d.call(node, ".workspace-tab-header"))) {
                shouldUpdate = true;
                break;
              }
            }
          }
          if (!shouldUpdate && mutation.target instanceof HTMLElement) {
            if (mutation.target.closest(".workspace-tab-header") && mutation.removedNodes.length > 0) {
              shouldUpdate = true;
            }
          }
        }
        if (shouldUpdate)
          break;
      }
      if (shouldUpdate) {
        this.scheduleUpdate();
      }
    });
    const workspaceContainer = document.querySelector(".workspace");
    if (workspaceContainer) {
      this.mutationObserver.observe(workspaceContainer, {
        childList: true,
        subtree: true
      });
    }
  }
  /**
   * Stop observing DOM changes.
   */
  stopObserving() {
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
      this.mutationObserver = null;
    }
  }
};

// src/HeaderSortExtension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var SORT_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5h10"/><path d="M11 9h7"/><path d="M11 13h4"/><path d="m3 17 3 3 3-3"/><path d="M6 18V4"/></svg>`;
var SortButtonWidget = class extends import_view.WidgetType {
  constructor(app, processor, scanner, lineNumber, filePath) {
    super();
    this.app = app;
    this.processor = processor;
    this.scanner = scanner;
    this.lineNumber = lineNumber;
    this.filePath = filePath;
  }
  toDOM() {
    const btn = document.createElement("button");
    btn.className = "todo-sort-btn-editor clickable-icon";
    btn.setAttribute("aria-label", "Sort children");
    btn.innerHTML = SORT_ICON;
    btn.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const todos = this.scanner.getTodos();
      const headerTodo = todos.find(
        (t) => t.filePath === this.filePath && t.lineNumber === this.lineNumber && t.isHeader === true
      );
      if (headerTodo) {
        btn.disabled = true;
        await this.processor.sortHeaderChildren(headerTodo);
        btn.disabled = false;
      }
    });
    return btn;
  }
  eq(other) {
    return this.lineNumber === other.lineNumber && this.filePath === other.filePath;
  }
  ignoreEvent() {
    return false;
  }
};
function isHeaderTodoWithChildren(line, lineNumber, scanner, filePath) {
  if (!/^#{1,6}\s+.*#todos?\b/i.test(line)) {
    return false;
  }
  const todos = scanner.getTodos();
  const headerTodo = todos.find(
    (t) => t.filePath === filePath && t.lineNumber === lineNumber && t.isHeader === true
  );
  return !!(headerTodo && headerTodo.childLineNumbers && headerTodo.childLineNumbers.length > 0);
}
function createHeaderSortPlugin(app, processor, scanner) {
  return import_view.ViewPlugin.fromClass(
    class {
      constructor(view) {
        this.app = app;
        this.processor = processor;
        this.scanner = scanner;
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const builder = new import_state.RangeSetBuilder();
        const filePath = this.getFilePath(view);
        if (!filePath) {
          return builder.finish();
        }
        for (const { from, to } of view.visibleRanges) {
          let pos = from;
          while (pos < to) {
            const line = view.state.doc.lineAt(pos);
            const lineText = line.text;
            const lineNumber = line.number - 1;
            if (isHeaderTodoWithChildren(
              lineText,
              lineNumber,
              this.scanner,
              filePath
            )) {
              const widget = new SortButtonWidget(
                this.app,
                this.processor,
                this.scanner,
                lineNumber,
                filePath
              );
              builder.add(
                line.to,
                line.to,
                import_view.Decoration.widget({ widget, side: 1 })
              );
            }
            pos = line.to + 1;
          }
        }
        return builder.finish();
      }
      getFilePath(view) {
        var _a;
        const file = this.app.workspace.getActiveFile();
        return (_a = file == null ? void 0 : file.path) != null ? _a : null;
      }
    },
    {
      decorations: (v) => v.decorations
    }
  );
}

// src/HeaderChecklistExtension.ts
var import_view2 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
function isTaggedHeader(lineText) {
  if (!/^#{1,6}\s+/.test(lineText)) {
    return false;
  }
  return /#(?:todos?|ideas?)\b/.test(lineText);
}
function isNextLineEmpty(view, currentLineNumber) {
  const doc = view.state.doc;
  if (currentLineNumber >= doc.lines) {
    return true;
  }
  const nextLine = doc.line(currentLineNumber + 1);
  return nextLine.text.trim() === "";
}
function handleEnterOnTaggedHeader(view) {
  const { state } = view;
  const { selection } = state;
  if (!selection.main.empty || selection.ranges.length > 1) {
    return false;
  }
  const cursorPos = selection.main.head;
  const currentLine = state.doc.lineAt(cursorPos);
  const lineText = currentLine.text;
  if (!isTaggedHeader(lineText)) {
    return false;
  }
  const textAfterCursor = lineText.slice(cursorPos - currentLine.from);
  if (textAfterCursor.trim() !== "") {
    return false;
  }
  if (!isNextLineEmpty(view, currentLine.number)) {
    return false;
  }
  const checklistText = "\n\n- [ ] ";
  const insertPos = currentLine.to;
  view.dispatch({
    changes: { from: insertPos, to: insertPos, insert: checklistText },
    selection: { anchor: insertPos + checklistText.length }
  });
  return true;
}
function createHeaderChecklistExtension() {
  return import_state2.Prec.high(
    import_view2.keymap.of([
      {
        key: "Enter",
        run: handleEnterOnTaggedHeader
      }
    ])
  );
}

// main.ts
var SpaceCommandPlugin = class extends import_obsidian11.Plugin {
  async onload() {
    await this.loadSettings();
    this.scanner = new TodoScanner(this.app);
    this.processor = new TodoProcessor(this.app, this.settings.dateFormat);
    this.processor.setScanner(this.scanner);
    this.projectManager = new ProjectManager(
      this.app,
      this.scanner,
      this.settings.defaultProjectsFolder,
      this.settings.priorityTags,
      this.settings.excludeFoldersFromProjects
    );
    this.embedRenderer = new EmbedRenderer(
      this.app,
      this.scanner,
      this.processor,
      this.projectManager,
      this.settings.defaultTodoneFile,
      this.settings.focusListLimit,
      this.settings.priorityTags,
      this.settings.makeLinksClickable
    );
    this.llmClient = new LLMClient({
      url: this.settings.llmUrl,
      model: this.settings.llmModel,
      prompt: this.settings.llmPrompt,
      rewritePrompt: this.settings.llmRewritePrompt,
      reviewPrompt: this.settings.llmReviewPrompt,
      timeout: this.settings.llmTimeout
    });
    this.defineTooltip = new DefineTooltip(this.app);
    this.tabLockManager = new TabLockManager(this.app);
    if (this.settings.showTabLockButton) {
      this.app.workspace.onLayoutReady(() => {
        this.tabLockManager.enable();
      });
    }
    if (this.settings.excludeTodoneFilesFromRecent) {
      this.scanner.setExcludeFromTodones([this.settings.defaultTodoneFile]);
    }
    this.processor.setOnCompleteCallback(() => {
      this.app.workspace.trigger("markdown-changed");
    });
    await this.scanner.scanVault();
    this.scanner.watchFiles();
    this.registerEditorExtension(
      createHeaderSortPlugin(this.app, this.processor, this.scanner)
    );
    this.registerEditorExtension(createHeaderChecklistExtension());
    this.registerDomEvent(document, "change", async (evt) => {
      const target = evt.target;
      if (!target.matches('input[type="checkbox"].task-list-item-checkbox')) {
        return;
      }
      if (!target.checked) {
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
      const file = this.app.workspace.getActiveFile();
      if (!file)
        return;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.includes("#todo") && !line.includes("#todone") && /^-\s*\[x\]/i.test(line.trim())) {
          const todos = this.scanner.getTodos();
          const todo = todos.find(
            (t) => t.file.path === file.path && t.lineNumber === i
          );
          if (todo) {
            await this.processor.completeTodo(
              todo,
              this.settings.defaultTodoneFile
            );
            break;
          }
        }
      }
    });
    this.registerView(
      VIEW_TYPE_TODO_SIDEBAR,
      (leaf) => new TodoSidebarView(
        leaf,
        this.scanner,
        this.processor,
        this.projectManager,
        this.settings.defaultTodoneFile,
        this.settings.priorityTags,
        this.settings.recentTodonesLimit,
        this.settings.activeTodosLimit,
        this.settings.focusListLimit,
        this.settings.focusModeIncludeProjects,
        this.settings.makeLinksClickable,
        this.settings.triageSnoozedThreshold,
        this.settings.triageActiveThreshold,
        () => this.showAboutModal(),
        () => this.showStatsModal(),
        () => this.showTriageModal()
      )
    );
    if (this.settings.showSidebarByDefault) {
      this.app.workspace.onLayoutReady(() => {
        this.activateSidebar();
      });
    }
    this.registerMarkdownPostProcessor((el, ctx) => {
      const codeBlocks = el.findAll("p, div");
      for (const block of codeBlocks) {
        const text = block.textContent || "";
        if (text.includes("{{focus-todos")) {
          this.embedRenderer.render(text, block);
        } else if (text.includes("{{focus-ideas")) {
          this.embedRenderer.render(text, block);
        } else if (text.includes("{{focus-list}}")) {
          this.embedRenderer.render(text, block);
        }
      }
    });
    const codeBlockProcessor = new CodeBlockProcessor(
      this.embedRenderer,
      this.settings.defaultTodoneFile
    );
    codeBlockProcessor.registerProcessors(this);
    this.registerEditorSuggest(new SlashCommandSuggest(this.app, this.settings));
    this.registerEditorSuggest(new DateSuggest(this.app, this.settings));
    this.addCommand({
      id: "toggle-todo-sidebar",
      name: "Toggle TODO Sidebar",
      callback: () => {
        this.toggleSidebar();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "t"
        }
      ]
    });
    this.addCommand({
      id: "quick-add-todo",
      name: "Quick Add TODO",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        if (line.trim() === "") {
          editor.replaceRange("- [ ] #todo ", cursor);
          editor.setCursor({ line: cursor.line, ch: 6 });
        } else {
          const endOfLine = { line: cursor.line, ch: line.length };
          editor.replaceRange(" #todo", endOfLine);
        }
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "a"
        }
      ]
    });
    this.addCommand({
      id: "refresh-todos",
      name: "Refresh TODOs",
      callback: async () => {
        await this.scanner.scanVault();
        this.refreshSidebar();
      }
    });
    this.addCommand({
      id: "copy-as-slack",
      name: "Copy as Slack Markdown",
      editorCallback: async (editor) => {
        const selection = editor.getSelection();
        if (!selection) {
          showNotice("No text selected");
          return;
        }
        const slackMd = convertToSlackMarkdown(selection);
        await navigator.clipboard.writeText(slackMd);
        showNotice("Copied as Slack markdown");
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "c"
        }
      ]
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Copy as Slack").setIcon("clipboard-copy").onClick(async () => {
              const slackMd = convertToSlackMarkdown(selection);
              await navigator.clipboard.writeText(slackMd);
              showNotice("Copied as Slack markdown");
            });
          });
          if (this.settings.llmEnabled) {
            menu.addItem((item) => {
              item.setTitle("Define term...").setIcon("book-open").onClick(async () => {
                this.defineTooltip.show(editor, "", true, selection, {
                  loadingText: "Defining...",
                  commandType: "define"
                });
                const result = await this.llmClient.define(selection);
                if (result.success && result.definition) {
                  this.defineTooltip.updateContent(result.definition);
                } else {
                  this.defineTooltip.showError(
                    this.llmClient.getModel(),
                    () => this.openLLMSettings()
                  );
                }
              });
            });
            menu.addItem((item) => {
              item.setTitle("Review...").setIcon("message-square").onClick(async () => {
                this.defineTooltip.show(editor, "", true, "", {
                  loadingText: "Reviewing...",
                  commandType: "review",
                  showApply: true
                });
                const result = await this.llmClient.review(selection);
                if (result.success && result.result) {
                  this.defineTooltip.updateContent(result.result, {
                    showApply: true
                  });
                } else {
                  this.defineTooltip.showError(
                    this.llmClient.getModel(),
                    () => this.openLLMSettings()
                  );
                }
              });
            });
            menu.addItem((item) => {
              item.setTitle("Rewrite...").setIcon("pencil").onClick(async () => {
                const from = editor.getCursor("from");
                const to = editor.getCursor("to");
                this.defineTooltip.show(editor, "", true, "", {
                  loadingText: "Rewriting...",
                  commandType: "rewrite",
                  onApply: (content) => {
                    editor.replaceRange(content, from, to);
                    showNotice("Text replaced");
                  }
                });
                const result = await this.llmClient.rewrite(selection);
                if (result.success && result.result) {
                  this.defineTooltip.updateContent(result.result, {
                    onApply: (content) => {
                      editor.replaceRange(content, from, to);
                      showNotice("Text replaced");
                    }
                  });
                } else {
                  this.defineTooltip.showError(
                    this.llmClient.getModel(),
                    () => this.openLLMSettings()
                  );
                }
              });
            });
          }
        }
      })
    );
    this.addRibbonIcon("square-check-big", "Toggle TODO Sidebar", () => {
      this.toggleSidebar();
    });
    this.addSettingTab(new SpaceCommandSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    this.defineTooltip.close();
    this.tabLockManager.destroy();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateSidebar() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_TODO_SIDEBAR,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async toggleSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      await this.activateSidebar();
    }
  }
  refreshSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof TodoSidebarView) {
        view.render();
      }
    }
  }
  showAboutModal() {
    new AboutModal(this.app, this.manifest.version).open();
  }
  showStatsModal() {
    new StatsModal(this.app, this.scanner).open();
  }
  showTriageModal() {
    new TriageModal(this.app, this.scanner, this.processor, this.embedRenderer, this.settings.defaultTodoneFile).open();
  }
  openLLMSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("space-command");
  }
};
var AboutModal = class extends import_obsidian11.Modal {
  constructor(app, version) {
    super(app);
    this.version = version;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("space-command-about-modal");
    const header = contentEl.createEl("div", { cls: "about-header" });
    header.createEl("span", { cls: "space-command-logo about-logo", text: "\u2423\u2318" });
    header.createEl("h2", { text: "Space Command" });
    contentEl.createEl("p", { cls: "about-version", text: `Version ${this.version}` });
    contentEl.createEl("p", {
      cls: "about-blurb",
      text: "Focus on the right next task. Simple TODOs and tags in your markdown, surfaced when you need them."
    });
    const details = contentEl.createEl("div", { cls: "about-details" });
    details.createEl("p", { text: "Author: Bruce Alderson" });
    const repoLink = details.createEl("p");
    repoLink.appendText("Repository: ");
    repoLink.createEl("a", {
      text: "github.com/robotpony/obsidian-plugins",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
    details.createEl("p", { text: "Made in \u{1F1E8}\u{1F1E6}", cls: "about-made-in" });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var StatsModal = class extends import_obsidian11.Modal {
  constructor(app, scanner) {
    super(app);
    this.scanner = scanner;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("space-command-stats-modal");
    const header = contentEl.createEl("div", { cls: "stats-header" });
    header.createEl("span", { cls: "space-command-logo stats-logo", text: "\u2423\u2318" });
    header.createEl("h2", { text: "Vault Statistics" });
    const todos = this.scanner.getTodos();
    const todones = this.scanner.getTodones();
    const ideas = this.scanner.getIdeas();
    const principles = this.scanner.getPrinciples();
    const focusedTodos = todos.filter((t) => t.tags.includes("#focus")).length;
    const focusedIdeas = ideas.filter((i) => i.tags.includes("#focus")).length;
    const snoozedTodos = todos.filter((t) => t.tags.includes("#future")).length;
    const statsGrid = contentEl.createEl("div", { cls: "stats-grid" });
    const todosSection = statsGrid.createEl("div", { cls: "stats-section" });
    todosSection.createEl("h3", { text: "TODOs" });
    this.createStatRow(todosSection, "Active", todos.length);
    this.createStatRow(todosSection, "Focused", focusedTodos);
    this.createStatRow(todosSection, "Snoozed", snoozedTodos);
    this.createStatRow(todosSection, "Completed", todones.length);
    const ideasSection = statsGrid.createEl("div", { cls: "stats-section" });
    ideasSection.createEl("h3", { text: "Ideas" });
    this.createStatRow(ideasSection, "Total", ideas.length);
    this.createStatRow(ideasSection, "Focused", focusedIdeas);
    const principlesSection = statsGrid.createEl("div", { cls: "stats-section" });
    principlesSection.createEl("h3", { text: "Principles" });
    this.createStatRow(principlesSection, "Total", principles.length);
    const summarySection = contentEl.createEl("div", { cls: "stats-summary" });
    const total = todos.length + todones.length + ideas.length + principles.length;
    summarySection.createEl("p", {
      text: `Total tracked items: ${total}`,
      cls: "stats-total"
    });
  }
  createStatRow(container, label, value) {
    const row = container.createEl("div", { cls: "stats-row" });
    row.createEl("span", { cls: "stats-label", text: label });
    row.createEl("span", { cls: "stats-value", text: String(value) });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var TriageModal = class extends import_obsidian11.Modal {
  constructor(app, scanner, processor, embedRenderer, defaultTodoneFile) {
    super(app);
    this.items = [];
    this.currentIndex = 0;
    this.scanner = scanner;
    this.processor = processor;
    this.embedRenderer = embedRenderer;
    this.defaultTodoneFile = defaultTodoneFile;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("space-command-triage-modal");
    const todos = this.scanner.getTodos();
    const ideas = this.scanner.getIdeas();
    const activeTodos = todos.filter(
      (t) => !t.isHeader && !t.tags.includes("#future") && !t.tags.includes("#snooze") && !t.tags.includes("#snoozed") && !t.tags.includes("#idea") && !t.tags.includes("#ideas") && !t.tags.includes("#ideation") && !t.tags.includes("#focus")
      // Skip already focused
    );
    const activeIdeas = ideas.filter(
      (i) => !i.isHeader && !i.tags.includes("#future") && !i.tags.includes("#snooze") && !i.tags.includes("#snoozed") && !i.tags.includes("#focus")
      // Skip already focused
    );
    const snoozedTodos = todos.filter(
      (t) => !t.isHeader && (t.tags.includes("#future") || t.tags.includes("#snooze") || t.tags.includes("#snoozed")) && !t.tags.includes("#idea") && !t.tags.includes("#ideas") && !t.tags.includes("#ideation")
    );
    const snoozedIdeas = ideas.filter(
      (i) => !i.isHeader && (i.tags.includes("#future") || i.tags.includes("#snooze") || i.tags.includes("#snoozed"))
    );
    this.items = [...activeTodos, ...activeIdeas, ...snoozedTodos, ...snoozedIdeas];
    this.currentIndex = 0;
    this.renderCurrentItem();
  }
  renderCurrentItem() {
    const { contentEl } = this;
    contentEl.empty();
    const header = contentEl.createEl("div", { cls: "triage-header" });
    const titleGroup = header.createEl("div", { cls: "triage-title-group" });
    titleGroup.createEl("span", { cls: "space-command-logo", text: "\u2423\u2318" });
    const progress = header.createEl("div", { cls: "triage-progress" });
    progress.appendText(`${this.currentIndex + 1} of ${this.items.length}`);
    if (this.items.length === 0 || this.currentIndex >= this.items.length) {
      const titleEl2 = titleGroup.createEl("span", { cls: "triage-title" });
      titleEl2.appendText("Triage your ");
      titleEl2.createEl("em", { text: "tasks" });
      const doneEl = contentEl.createEl("div", { cls: "triage-done" });
      doneEl.createEl("p", { text: "All items triaged!", cls: "triage-done-text" });
      const closeBtn = doneEl.createEl("button", { text: "Close", cls: "triage-btn triage-btn-close" });
      closeBtn.addEventListener("click", () => this.close());
      return;
    }
    const item = this.items[this.currentIndex];
    const isSnoozed = item.tags.includes("#future") || item.tags.includes("#snooze") || item.tags.includes("#snoozed");
    const isIdea = item.itemType === "idea" || item.tags.includes("#idea") || item.tags.includes("#ideas");
    const titleEl = titleGroup.createEl("span", { cls: "triage-title" });
    titleEl.appendText("Triage your ");
    if (isSnoozed) {
      titleEl.createEl("em", { text: "snoozed items" });
    } else if (isIdea) {
      titleEl.createEl("em", { text: "ideas" });
    } else {
      titleEl.createEl("em", { text: "tasks" });
    }
    const contextIndicator = contentEl.createEl("div", { cls: "triage-context" });
    if (item.parentLineNumber !== void 0) {
      const allItems = isIdea ? this.scanner.getIdeas() : this.scanner.getTodos();
      const parentHeader = allItems.find(
        (t) => t.filePath === item.filePath && t.lineNumber === item.parentLineNumber
      );
      if (parentHeader) {
        const parentText = parentHeader.text.replace(/\\#/g, "\0ESCAPED_HASH\0").replace(/#[\w-]+/g, "").replace(/\x00ESCAPED_HASH\x00/g, "#").replace(/^#{1,6}\s+/, "").trim();
        contextIndicator.appendText(parentText);
      }
    }
    const itemContent = contentEl.createEl("div", { cls: "triage-item-content" });
    const checkbox = itemContent.createEl("input", {
      type: "checkbox",
      cls: "triage-checkbox"
    });
    checkbox.addEventListener("change", async () => {
      checkbox.disabled = true;
      if (isIdea) {
        await this.processor.completeIdea(item);
      } else {
        await this.processor.completeTodo(item, this.defaultTodoneFile);
      }
      this.nextItem();
    });
    const textSpan = itemContent.createEl("span", { cls: "triage-item-text" });
    let displayText = item.text.replace(/\\#/g, "\0ESCAPED_HASH\0").replace(/#[\w-]+/g, "").replace(/\x00ESCAPED_HASH\x00/g, "#").replace(/^[-*+]\s*\[.\]\s*/, "").replace(/^[-*+]\s*/, "").replace(/^#{1,6}\s+/, "").trim();
    this.embedRenderer.renderInlineMarkdown(displayText, textSpan);
    const metaRow = contentEl.createEl("div", { cls: "triage-meta-row" });
    const sourceEl = metaRow.createEl("div", { cls: "triage-source" });
    sourceEl.appendText(`(from ${item.filePath})`);
    const tagsEl = metaRow.createEl("div", { cls: "triage-tags" });
    const escapedTagPattern = /\\(#[\w-]+)/g;
    const escapedTags = /* @__PURE__ */ new Set();
    let match;
    while ((match = escapedTagPattern.exec(item.text)) !== null) {
      escapedTags.add(match[1]);
    }
    for (const tag of item.tags) {
      if (!escapedTags.has(tag)) {
        tagsEl.createEl("a", { cls: "tag", href: tag, text: tag });
      }
    }
    contentEl.createEl("div", { cls: "triage-separator" });
    const actions = contentEl.createEl("div", { cls: "triage-actions" });
    if (isSnoozed) {
      const unsnoozeBtn = actions.createEl("button", {
        cls: "triage-btn triage-btn-unsnooze",
        attr: { title: "Remove snooze tag and make this item active again" }
      });
      unsnoozeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg> Wake';
      unsnoozeBtn.addEventListener("click", async () => {
        await this.processor.removeTag(item, "#future");
        if (item.tags.includes("#snooze"))
          await this.processor.removeTag(item, "#snooze");
        if (item.tags.includes("#snoozed"))
          await this.processor.removeTag(item, "#snoozed");
        this.nextItem();
      });
    } else {
      const snoozeBtn = actions.createEl("button", {
        cls: "triage-btn triage-btn-snooze",
        attr: { title: "Snooze this item for later" }
      });
      snoozeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> Snooze';
      snoozeBtn.addEventListener("click", async () => {
        await this.processor.setPriorityTag(item, "#future");
        this.nextItem();
      });
    }
    const clearBtn = actions.createEl("button", {
      cls: "triage-btn triage-btn-clear",
      attr: { title: "Remove the type tag (item will no longer appear in lists)" }
    });
    clearBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg> Clear';
    clearBtn.addEventListener("click", async () => {
      if (isIdea) {
        await this.processor.removeTag(item, "#idea");
        if (item.tags.includes("#ideas"))
          await this.processor.removeTag(item, "#ideas");
        if (item.tags.includes("#ideation"))
          await this.processor.removeTag(item, "#ideation");
      } else {
        await this.processor.removeTag(item, "#todo");
      }
      this.nextItem();
    });
    if (isIdea) {
      const toTodoBtn = actions.createEl("button", {
        cls: "triage-btn triage-btn-convert",
        attr: { title: "Convert this Idea to a TODO" }
      });
      toTodoBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.5"/><path d="m9 11 3 3L22 4"/></svg> \u2192 TODO';
      toTodoBtn.addEventListener("click", async () => {
        await this.processor.removeTag(item, "#idea");
        if (item.tags.includes("#ideas"))
          await this.processor.removeTag(item, "#ideas");
        if (item.tags.includes("#ideation"))
          await this.processor.removeTag(item, "#ideation");
        await this.processor.addTag(item, "#todo");
        this.nextItem();
      });
    } else {
      const toIdeaBtn = actions.createEl("button", {
        cls: "triage-btn triage-btn-convert",
        attr: { title: "Convert this TODO to an Idea" }
      });
      toIdeaBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18h6"></path><path d="M10 22h4"></path><path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"></path></svg> \u2192 Idea';
      toIdeaBtn.addEventListener("click", async () => {
        await this.processor.removeTag(item, "#todo");
        await this.processor.addTag(item, "#idea");
        this.nextItem();
      });
    }
    const focusBtn = actions.createEl("button", {
      cls: "triage-btn triage-btn-focus",
      attr: { title: "Add #focus tag to prioritize this item" }
    });
    focusBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg> Focus';
    focusBtn.addEventListener("click", async () => {
      await this.processor.setPriorityTag(item, "#focus");
      this.nextItem();
    });
    const backBtn = actions.createEl("button", {
      cls: "triage-btn triage-btn-back",
      attr: { title: "Go back to previous item" }
    });
    backBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="5" x2="5" y2="19"/><polygon points="19 4 9 12 19 20 19 4"/></svg>';
    backBtn.addEventListener("click", () => this.prevItem());
    if (this.currentIndex === 0) {
      backBtn.disabled = true;
      backBtn.classList.add("triage-btn-disabled");
    }
    const skipBtn = actions.createEl("button", {
      cls: "triage-btn triage-btn-skip",
      attr: { title: "Skip this item and move to next" }
    });
    skipBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg> Skip';
    skipBtn.addEventListener("click", () => this.nextItem());
  }
  prevItem() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.renderCurrentItem();
    }
  }
  nextItem() {
    this.currentIndex++;
    this.renderCurrentItem();
  }
  onClose() {
    this.contentEl.empty();
  }
};
var SpaceCommandSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Space Command Settings" });
    const aboutSection = containerEl.createEl("div", { cls: "space-command-about-section" });
    const aboutHeader = aboutSection.createEl("div", { cls: "about-header" });
    aboutHeader.createEl("span", { cls: "space-command-logo about-logo", text: "\u2423\u2318" });
    aboutHeader.createEl("span", { cls: "about-title", text: "Space Command" });
    aboutSection.createEl("p", {
      cls: "about-blurb",
      text: "Focus on the right next task. Simple TODOs and tags in your markdown, surfaced when you need them."
    });
    aboutSection.createEl("p", { cls: "about-version", text: `Version ${this.plugin.manifest.version}` });
    const aboutDetails = aboutSection.createEl("div", { cls: "about-details" });
    aboutDetails.createEl("span", { text: "By Bruce Alderson" });
    aboutDetails.appendText(" \xB7 ");
    aboutDetails.createEl("a", {
      text: "GitHub",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
    containerEl.createEl("h3", { text: "Sidebar" });
    new import_obsidian11.Setting(containerEl).setName("Show sidebar by default").setDesc("Show the TODO sidebar when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSidebarByDefault).onChange(async (value) => {
        this.plugin.settings.showSidebarByDefault = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Show tab lock buttons").setDesc("Add lock buttons to tab headers. Locked tabs force links to open in new tabs.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTabLockButton).onChange(async (value) => {
        this.plugin.settings.showTabLockButton = value;
        if (value) {
          this.plugin.tabLockManager.enable();
        } else {
          this.plugin.tabLockManager.disable();
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Make links clickable in lists").setDesc("Render wiki links and markdown links as clickable in sidebar and embeds. When disabled, links display as plain text without markdown syntax.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.makeLinksClickable).onChange(async (value) => {
        this.plugin.settings.makeLinksClickable = value;
        await this.plugin.saveSettings();
        this.plugin.refreshSidebar();
      })
    );
    containerEl.createEl("h3", { text: "TODOs" });
    new import_obsidian11.Setting(containerEl).setName("Default TODONE file").setDesc("Default file path for logging completed TODOs").addText(
      (text) => text.setPlaceholder("todos/done.md").setValue(this.plugin.settings.defaultTodoneFile).onChange(async (value) => {
        this.plugin.settings.defaultTodoneFile = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Date format").setDesc("Format for completion dates (using moment.js format)").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        this.plugin.settings.dateFormat = value;
        this.plugin.processor = new TodoProcessor(
          this.app,
          value
        );
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Projects" });
    new import_obsidian11.Setting(containerEl).setName("Default projects folder").setDesc("Folder where project files are created (e.g., projects/)").addText(
      (text) => text.setPlaceholder("projects/").setValue(this.plugin.settings.defaultProjectsFolder).onChange(async (value) => {
        this.plugin.settings.defaultProjectsFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Focus list limit").setDesc("Maximum number of projects to show in sidebar and {{focus-list}}").addText(
      (text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.focusListLimit)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.focusListLimit = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Active TODOs limit").setDesc("Maximum number of TODOs to show in sidebar (0 for unlimited)").addText(
      (text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.activeTodosLimit)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.activeTodosLimit = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Focus mode includes project TODOs").setDesc("When enabled, focus mode shows all TODOs from focused projects (not just #focus items)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.focusModeIncludeProjects).onChange(async (value) => {
        this.plugin.settings.focusModeIncludeProjects = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Exclude folders from projects").setDesc("Comma-separated folders to exclude from inferred project tags (e.g., log, archive)").addText(
      (text) => text.setPlaceholder("log").setValue(this.plugin.settings.excludeFoldersFromProjects.join(", ")).onChange(async (value) => {
        const folders = value.split(",").map((f) => f.trim()).filter((f) => f.length > 0);
        this.plugin.settings.excludeFoldersFromProjects = folders;
        this.plugin.projectManager = new ProjectManager(
          this.app,
          this.plugin.scanner,
          this.plugin.settings.defaultProjectsFolder,
          this.plugin.settings.priorityTags,
          folders
        );
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Priority Settings" });
    new import_obsidian11.Setting(containerEl).setName("Priority tags").setDesc("Comma-separated list of priority tags (e.g., #p0, #p1, #p2, #p3, #p4). These tags won't appear in the Projects list.").addText(
      (text) => text.setPlaceholder("#p0, #p1, #p2, #p3, #p4").setValue(this.plugin.settings.priorityTags.join(", ")).onChange(async (value) => {
        const tags = value.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0).map((tag) => tag.startsWith("#") ? tag : `#${tag}`);
        this.plugin.settings.priorityTags = tags;
        this.plugin.projectManager = new ProjectManager(
          this.app,
          this.plugin.scanner,
          this.plugin.settings.defaultProjectsFolder,
          tags,
          this.plugin.settings.excludeFoldersFromProjects
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Recent TODONEs limit").setDesc("Maximum number of recent TODONEs to show in sidebar").addText(
      (text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.recentTodonesLimit)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.recentTodonesLimit = num;
          await this.plugin.saveSettings();
        }
      })
    );
    containerEl.createEl("h3", { text: "Triage" });
    new import_obsidian11.Setting(containerEl).setName("Snoozed items threshold").setDesc("Show triage alert when snoozed items exceed this count").addText(
      (text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.triageSnoozedThreshold)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.triageSnoozedThreshold = num;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Active items threshold").setDesc("Show triage alert when active TODOs + Ideas exceed this count").addText(
      (text) => text.setPlaceholder("20").setValue(String(this.plugin.settings.triageActiveThreshold)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 0) {
          this.plugin.settings.triageActiveThreshold = num;
          await this.plugin.saveSettings();
        }
      })
    );
    containerEl.createEl("h3", { text: "LLM Settings (Define, Rewrite, Review)" });
    new import_obsidian11.Setting(containerEl).setName("Enable Define feature").setDesc("Show 'Define' option in context menu to look up definitions via LLM").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.llmEnabled).onChange(async (value) => {
        this.plugin.settings.llmEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("LLM URL").setDesc("Ollama server URL (default: http://localhost:11434)").addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.llmUrl).onChange(async (value) => {
        this.plugin.settings.llmUrl = value;
        this.plugin.llmClient.updateConfig({ url: value });
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("LLM Model").setDesc("Model name to use (e.g., llama3.2, mistral, codellama)").addText(
      (text) => text.setPlaceholder("llama3.2").setValue(this.plugin.settings.llmModel).onChange(async (value) => {
        this.plugin.settings.llmModel = value;
        this.plugin.llmClient.updateConfig({ model: value });
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian11.Setting(containerEl).setName("Definition prompt").setDesc("Prompt prepended to the selected text for Define").addTextArea((text) => {
      text.setPlaceholder("Explain what this means...").setValue(this.plugin.settings.llmPrompt).onChange(async (value) => {
        this.plugin.settings.llmPrompt = value;
        this.plugin.llmClient.updateConfig({ prompt: value });
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian11.Setting(containerEl).setName("Rewrite prompt").setDesc("Prompt prepended to the selected text for Rewrite").addTextArea((text) => {
      text.setPlaceholder("Rewrite for clarity and brevity...").setValue(this.plugin.settings.llmRewritePrompt).onChange(async (value) => {
        this.plugin.settings.llmRewritePrompt = value;
        this.plugin.llmClient.updateConfig({ rewritePrompt: value });
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian11.Setting(containerEl).setName("Review prompt").setDesc("Prompt prepended to the selected text for Review").addTextArea((text) => {
      text.setPlaceholder("Review and suggest improvements...").setValue(this.plugin.settings.llmReviewPrompt).onChange(async (value) => {
        this.plugin.settings.llmReviewPrompt = value;
        this.plugin.llmClient.updateConfig({ reviewPrompt: value });
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian11.Setting(containerEl).setName("Timeout (ms)").setDesc("Maximum time to wait for LLM response").addText(
      (text) => text.setPlaceholder("30000").setValue(String(this.plugin.settings.llmTimeout)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.llmTimeout = num;
          this.plugin.llmClient.updateConfig({ timeout: num });
          await this.plugin.saveSettings();
        }
      })
    );
  }
};
