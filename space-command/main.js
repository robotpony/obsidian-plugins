/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WeeklyLogHelpersPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/TodoScanner.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
function formatDate(date, format) {
  return (0, import_obsidian.moment)(date).format(format);
}
function extractTags(text) {
  const tagRegex = /#[\w-]+/g;
  return text.match(tagRegex) || [];
}
function hasCheckboxFormat(text) {
  return /^-\s*\[[ x]\]/.test(text.trim());
}
function markCheckboxComplete(text) {
  return text.replace(/^(-\s*\[)[ ](\])/, "$1x$2");
}
function replaceTodoWithTodone(text, date) {
  return text.replace(/#todo\b/, `#todone @${date}`);
}

// src/TodoScanner.ts
var TodoScanner = class extends import_obsidian2.Events {
  constructor(app) {
    super();
    this.todosCache = /* @__PURE__ */ new Map();
    this.todonesCache = /* @__PURE__ */ new Map();
    this.excludeFromTodones = /* @__PURE__ */ new Set();
    this.app = app;
  }
  setExcludeFromTodones(filePaths) {
    this.excludeFromTodones = new Set(filePaths);
  }
  async scanVault() {
    this.todosCache.clear();
    this.todonesCache.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      await this.scanFile(file);
    }
  }
  async scanFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const todos = [];
      const todones = [];
      let inCodeBlock = false;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim().startsWith("```")) {
          inCodeBlock = !inCodeBlock;
          continue;
        }
        if (inCodeBlock) {
          continue;
        }
        if (this.isInInlineCode(line)) {
          continue;
        }
        const tags = extractTags(line);
        if (tags.includes("#todo")) {
          todos.push(this.createTodoItem(file, i, line, tags));
        } else if (tags.includes("#todone")) {
          todones.push(this.createTodoItem(file, i, line, tags));
        }
      }
      if (todos.length > 0) {
        this.todosCache.set(file.path, todos);
      } else {
        this.todosCache.delete(file.path);
      }
      if (todones.length > 0) {
        this.todonesCache.set(file.path, todones);
      } else {
        this.todonesCache.delete(file.path);
      }
      this.trigger("todos-updated");
    } catch (error) {
      console.error(`Error scanning file ${file.path}:`, error);
    }
  }
  isInInlineCode(line) {
    const todoMatches = [...line.matchAll(/#todo\b/g)];
    const todoneMatches = [...line.matchAll(/#todone\b/g)];
    const allMatches = [...todoMatches, ...todoneMatches];
    if (allMatches.length === 0) {
      return false;
    }
    const backticks = [];
    for (let i = 0; i < line.length; i++) {
      if (line[i] === "`") {
        backticks.push(i);
      }
    }
    if (backticks.length % 2 !== 0) {
      return false;
    }
    for (const match of allMatches) {
      const pos = match.index;
      for (let i = 0; i < backticks.length; i += 2) {
        const start = backticks[i];
        const end = backticks[i + 1];
        if (pos > start && pos < end) {
          return true;
        }
      }
    }
    return false;
  }
  createTodoItem(file, lineNumber, text, tags) {
    var _a;
    return {
      file,
      filePath: file.path,
      folder: ((_a = file.parent) == null ? void 0 : _a.path) || "",
      lineNumber,
      text: text.trim(),
      hasCheckbox: hasCheckboxFormat(text),
      tags,
      dateCreated: file.stat.mtime
    };
  }
  getTodos() {
    const allTodos = [];
    for (const todos of this.todosCache.values()) {
      allTodos.push(...todos);
    }
    return allTodos.sort((a, b) => a.dateCreated - b.dateCreated);
  }
  getTodones(limit) {
    const allTodones = [];
    for (const [filePath, todones] of this.todonesCache.entries()) {
      if (this.excludeFromTodones.has(filePath)) {
        continue;
      }
      allTodones.push(...todones);
    }
    const sorted = allTodones.sort((a, b) => b.dateCreated - a.dateCreated);
    return limit ? sorted.slice(0, limit) : sorted;
  }
  watchFiles() {
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.scanFile(file);
      }
    });
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.scanFile(file);
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        this.todosCache.delete(file.path);
        this.todonesCache.delete(file.path);
      }
    });
    this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.todosCache.delete(oldPath);
        this.todonesCache.delete(oldPath);
        this.scanFile(file);
      }
    });
  }
};

// src/TodoProcessor.ts
var import_obsidian3 = require("obsidian");
var TodoProcessor = class {
  constructor(app, dateFormat = "YYYY-MM-DD") {
    this.app = app;
    this.dateFormat = dateFormat;
  }
  setOnCompleteCallback(callback) {
    this.onComplete = callback;
  }
  async completeTodo(todo, todoneFilePath) {
    try {
      const today = formatDate(/* @__PURE__ */ new Date(), this.dateFormat);
      await this.updateSourceFile(todo, today);
      await this.appendToTodoneFile(todo, todoneFilePath, today);
      if (this.onComplete) {
        this.onComplete();
      }
      new import_obsidian3.Notice("TODO marked as complete!");
      return true;
    } catch (error) {
      console.error("Error completing TODO:", error);
      new import_obsidian3.Notice("Failed to complete TODO. See console for details.");
      return false;
    }
  }
  async updateSourceFile(todo, date) {
    const content = await this.app.vault.read(todo.file);
    const lines = content.split("\n");
    if (todo.lineNumber >= lines.length) {
      throw new Error(
        `Line number ${todo.lineNumber} out of bounds for file ${todo.filePath}`
      );
    }
    let updatedLine = lines[todo.lineNumber];
    updatedLine = replaceTodoWithTodone(updatedLine, date);
    if (todo.hasCheckbox) {
      updatedLine = markCheckboxComplete(updatedLine);
    }
    lines[todo.lineNumber] = updatedLine;
    await this.app.vault.modify(todo.file, lines.join("\n"));
  }
  async appendToTodoneFile(todo, todoneFilePath, date) {
    let todoneFile = this.app.vault.getAbstractFileByPath(todoneFilePath);
    if (!todoneFile) {
      const pathParts = todoneFilePath.split("/");
      const fileName = pathParts.pop();
      const folderPath = pathParts.join("/");
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      todoneFile = await this.app.vault.create(todoneFilePath, "");
    }
    if (!(todoneFile instanceof import_obsidian3.TFile)) {
      throw new Error(`${todoneFilePath} is not a file`);
    }
    let todoneText = todo.text;
    todoneText = replaceTodoWithTodone(todoneText, date);
    if (todo.hasCheckbox) {
      todoneText = markCheckboxComplete(todoneText);
    } else {
      todoneText = `- [x] ${todoneText}`;
    }
    const currentContent = await this.app.vault.read(todoneFile);
    const newContent = currentContent ? `${currentContent}
${todoneText}` : todoneText;
    await this.app.vault.modify(todoneFile, newContent);
  }
  async ensureFolderExists(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      await this.app.vault.createFolder(folderPath);
    }
  }
};

// src/FilterParser.ts
var FilterParser = class {
  static parse(filterString) {
    const filters = {};
    if (!filterString || filterString.trim() === "") {
      return filters;
    }
    const parts = filterString.split("|").map((p) => p.trim());
    for (const part of parts) {
      if (part.startsWith("path:")) {
        filters.path = part.substring(5).trim();
      } else if (part.startsWith("tags:")) {
        const tagString = part.substring(5).trim();
        filters.tags = tagString.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      } else if (part.startsWith("limit:")) {
        const limitStr = part.substring(6).trim();
        const limit = parseInt(limitStr, 10);
        if (!isNaN(limit) && limit > 0) {
          filters.limit = limit;
        }
      }
    }
    return filters;
  }
  static applyFilters(todos, filters) {
    let filtered = [...todos];
    if (filters.path) {
      const pathPrefix = filters.path.toLowerCase();
      filtered = filtered.filter(
        (todo) => todo.filePath.toLowerCase().startsWith(pathPrefix)
      );
    }
    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter((todo) => {
        const todoTags = todo.tags.map((t) => t.toLowerCase());
        return filters.tags.every(
          (filterTag) => todoTags.includes(filterTag.toLowerCase())
        );
      });
    }
    if (filters.limit) {
      filtered = filtered.slice(0, filters.limit);
    }
    return filtered;
  }
};

// src/EmbedRenderer.ts
var EmbedRenderer = class {
  constructor(app, scanner, processor, defaultTodoneFile = "todos/done.md") {
    this.app = app;
    this.scanner = scanner;
    this.processor = processor;
    this.defaultTodoneFile = defaultTodoneFile;
  }
  async render(source, el, ctx) {
    var _a;
    const match = source.match(
      /\{\{focus-todos:?\s*([^|}\s]*)(?:\s*\|\s*(.+))?\}\}/
    );
    if (!match) {
      el.createEl("div", {
        text: "Invalid focus-todos syntax",
        cls: "weekly-log-helpers-error"
      });
      return;
    }
    const todoneFile = ((_a = match[1]) == null ? void 0 : _a.trim()) || this.defaultTodoneFile;
    const filterString = match[2] || "";
    const filters = FilterParser.parse(filterString);
    let todos = this.scanner.getTodos();
    todos = FilterParser.applyFilters(todos, filters);
    this.renderTodoList(el, todos, todoneFile);
  }
  renderTodoList(container, todos, todoneFile) {
    container.empty();
    container.addClass("weekly-log-helpers-embed");
    if (todos.length === 0) {
      container.createEl("div", {
        text: "No active TODOs",
        cls: "weekly-log-helpers-empty"
      });
      return;
    }
    const list = container.createEl("ul", { cls: "contains-task-list" });
    for (const todo of todos) {
      const item = list.createEl("li", { cls: "task-list-item" });
      const checkbox = item.createEl("input", {
        type: "checkbox",
        cls: "task-list-item-checkbox"
      });
      checkbox.addEventListener("change", async () => {
        checkbox.disabled = true;
        const success = await this.processor.completeTodo(todo, todoneFile);
        if (success) {
          item.remove();
          if (list.children.length === 0) {
            container.empty();
            container.createEl("div", {
              text: "No active TODOs",
              cls: "weekly-log-helpers-empty"
            });
          }
        } else {
          checkbox.disabled = false;
        }
      });
      const textSpan = item.createEl("span", { cls: "todo-text" });
      const cleanText = todo.text.replace(/#todo\b/g, "").trim();
      const displayText = cleanText.replace(/^-\s*\[\s*\]\s*/, "");
      textSpan.textContent = displayText + " ";
      const link = item.createEl("a", {
        text: "\u2192",
        cls: "todo-source-link",
        href: "#"
      });
      link.addEventListener("click", (e) => {
        e.preventDefault();
        this.openFileAtLine(todo.file, todo.lineNumber);
      });
    }
  }
  openFileAtLine(file, line) {
    const leaf = this.app.workspace.getLeaf(false);
    leaf.openFile(file, { active: true }).then(() => {
      const view = this.app.workspace.getActiveViewOfType(
        require("obsidian").MarkdownView
      );
      if (view && view.editor) {
        const editor = view.editor;
        editor.setCursor({ line, ch: 0 });
        editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
        this.highlightLine(editor, line);
      }
    });
  }
  highlightLine(editor, line) {
    const lineText = editor.getLine(line);
    const lineLength = lineText.length;
    editor.setSelection(
      { line, ch: 0 },
      { line, ch: lineLength }
    );
    setTimeout(() => {
      editor.setCursor({ line, ch: 0 });
    }, 1500);
  }
};

// src/SidebarView.ts
var import_obsidian4 = require("obsidian");
var VIEW_TYPE_TODO_SIDEBAR = "weekly-log-helpers-sidebar";
var TodoSidebarView = class extends import_obsidian4.ItemView {
  constructor(leaf, scanner, processor, defaultTodoneFile) {
    super(leaf);
    this.todonesCollapsed = false;
    this.updateListener = null;
    this.sortMode = "date";
    this.scanner = scanner;
    this.processor = processor;
    this.defaultTodoneFile = defaultTodoneFile;
  }
  getViewType() {
    return VIEW_TYPE_TODO_SIDEBAR;
  }
  getDisplayText() {
    return "\u2325\u2318 TODOs";
  }
  getIcon() {
    return "checkbox-glyph";
  }
  async onOpen() {
    this.updateListener = () => this.render();
    this.scanner.on("todos-updated", this.updateListener);
    this.render();
  }
  async onClose() {
    if (this.updateListener) {
      this.scanner.off("todos-updated", this.updateListener);
      this.updateListener = null;
    }
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("weekly-log-helpers-sidebar");
    const headerDiv = container.createEl("div", { cls: "sidebar-header" });
    headerDiv.createEl("h4", { text: "\u2325\u2318 TODOs" });
    const buttonGroup = headerDiv.createEl("div", { cls: "sidebar-button-group" });
    const sortBtn = buttonGroup.createEl("button", {
      cls: "clickable-icon sidebar-sort-btn",
      attr: { "aria-label": `Sort by: ${this.sortMode}` }
    });
    this.updateSortIcon(sortBtn);
    sortBtn.addEventListener("click", () => {
      this.cycleSortMode();
      this.updateSortIcon(sortBtn);
      sortBtn.setAttribute("aria-label", `Sort by: ${this.sortMode}`);
      this.render();
    });
    const refreshBtn = buttonGroup.createEl("button", {
      cls: "clickable-icon sidebar-refresh-btn",
      attr: { "aria-label": "Refresh TODOs" }
    });
    refreshBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>';
    refreshBtn.addEventListener("click", async () => {
      refreshBtn.addClass("rotating");
      await this.scanner.scanVault();
      setTimeout(() => refreshBtn.removeClass("rotating"), 500);
    });
    this.renderActiveTodos(container);
    this.renderRecentTodones(container);
  }
  cycleSortMode() {
    const modes = ["date", "file", "folder"];
    const currentIndex = modes.indexOf(this.sortMode);
    this.sortMode = modes[(currentIndex + 1) % modes.length];
  }
  updateSortIcon(button) {
    const icons = {
      date: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>',
      file: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>',
      folder: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>'
    };
    button.innerHTML = icons[this.sortMode];
  }
  sortTodos(todos) {
    const sorted = [...todos];
    switch (this.sortMode) {
      case "date":
        return sorted.sort((a, b) => a.dateCreated - b.dateCreated);
      case "file":
        return sorted.sort((a, b) => a.filePath.localeCompare(b.filePath));
      case "folder":
        return sorted.sort((a, b) => {
          const folderCompare = a.folder.localeCompare(b.folder);
          if (folderCompare !== 0)
            return folderCompare;
          return a.filePath.localeCompare(b.filePath);
        });
    }
  }
  renderActiveTodos(container) {
    let todos = this.scanner.getTodos();
    todos = this.sortTodos(todos);
    const section = container.createEl("div", { cls: "todo-section" });
    const header = section.createEl("div", { cls: "todo-section-header" });
    header.createEl("span", {
      text: `\u25BC Active TODOs (${todos.length})`,
      cls: "todo-section-title"
    });
    if (todos.length === 0) {
      section.createEl("div", {
        text: "No active TODOs",
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "todo-list" });
    for (const todo of todos) {
      this.renderTodoItem(list, todo);
    }
  }
  renderTodoItem(list, todo) {
    const item = list.createEl("li", { cls: "todo-item" });
    const checkbox = item.createEl("input", {
      type: "checkbox",
      cls: "todo-checkbox"
    });
    checkbox.addEventListener("change", async () => {
      checkbox.disabled = true;
      const success = await this.processor.completeTodo(
        todo,
        this.defaultTodoneFile
      );
      if (success) {
        this.render();
      } else {
        checkbox.disabled = false;
      }
    });
    const textSpan = item.createEl("span", { cls: "todo-text" });
    const cleanText = todo.text.replace(/#todo\b/g, "").trim();
    const displayText = cleanText.replace(/^-\s*\[\s*\]\s*/, "");
    textSpan.textContent = displayText + " ";
    const link = item.createEl("a", {
      text: "\u2192",
      cls: "todo-link",
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.openFileAtLine(todo.file, todo.lineNumber);
    });
  }
  renderRecentTodones(container) {
    const todones = this.scanner.getTodones(10);
    const section = container.createEl("div", { cls: "todone-section" });
    const header = section.createEl("div", {
      cls: "todo-section-header todone-header"
    });
    const titleSpan = header.createEl("span", {
      text: this.todonesCollapsed ? "\u25B6" : "\u25BC",
      cls: "collapse-icon"
    });
    titleSpan.appendText(` Recent TODONEs (${todones.length})`);
    titleSpan.addClass("todo-section-title");
    header.addEventListener("click", () => {
      this.todonesCollapsed = !this.todonesCollapsed;
      this.render();
    });
    if (this.todonesCollapsed) {
      return;
    }
    if (todones.length === 0) {
      section.createEl("div", {
        text: "No completed TODOs yet",
        cls: "todo-empty"
      });
      return;
    }
    const list = section.createEl("ul", { cls: "todo-list todone-list" });
    for (const todone of todones) {
      this.renderTodoneItem(list, todone);
    }
  }
  renderTodoneItem(list, todone) {
    const item = list.createEl("li", { cls: "todo-item todone-item" });
    item.createEl("input", {
      type: "checkbox",
      cls: "todo-checkbox",
      attr: { checked: "checked", disabled: "disabled" }
    });
    const textSpan = item.createEl("span", { cls: "todo-text todone-text" });
    const cleanText = todone.text.replace(/#todone\b/g, "").trim();
    const displayText = cleanText.replace(/^-\s*\[x\]\s*/, "");
    textSpan.textContent = displayText + " ";
    const link = item.createEl("a", {
      text: "\u2192",
      cls: "todo-link",
      href: "#"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.openFileAtLine(todone.file, todone.lineNumber);
    });
  }
  openFileAtLine(file, line) {
    const leaf = this.app.workspace.getLeaf(false);
    leaf.openFile(file, { active: true }).then(() => {
      const view = this.app.workspace.getActiveViewOfType(
        require("obsidian").MarkdownView
      );
      if (view && view.editor) {
        const editor = view.editor;
        editor.setCursor({ line, ch: 0 });
        editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
        this.highlightLine(editor, line);
      }
    });
  }
  highlightLine(editor, line) {
    const lineText = editor.getLine(line);
    const lineLength = lineText.length;
    editor.setSelection(
      { line, ch: 0 },
      { line, ch: lineLength }
    );
    setTimeout(() => {
      editor.setCursor({ line, ch: 0 });
    }, 1500);
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  defaultTodoneFile: "todos/done.md",
  showSidebarByDefault: true,
  dateFormat: "YYYY-MM-DD",
  excludeTodoneFilesFromRecent: true
};

// main.ts
var WeeklyLogHelpersPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.scanner = new TodoScanner(this.app);
    this.processor = new TodoProcessor(this.app, this.settings.dateFormat);
    this.embedRenderer = new EmbedRenderer(
      this.app,
      this.scanner,
      this.processor,
      this.settings.defaultTodoneFile
    );
    if (this.settings.excludeTodoneFilesFromRecent) {
      this.scanner.setExcludeFromTodones([this.settings.defaultTodoneFile]);
    }
    this.processor.setOnCompleteCallback(() => {
      this.app.workspace.trigger("markdown-changed");
    });
    await this.scanner.scanVault();
    this.scanner.watchFiles();
    this.registerView(
      VIEW_TYPE_TODO_SIDEBAR,
      (leaf) => new TodoSidebarView(
        leaf,
        this.scanner,
        this.processor,
        this.settings.defaultTodoneFile
      )
    );
    if (this.settings.showSidebarByDefault) {
      this.activateSidebar();
    }
    this.registerMarkdownPostProcessor((el, ctx) => {
      const codeBlocks = el.findAll("p, div");
      for (const block of codeBlocks) {
        const text = block.textContent || "";
        if (text.includes("{{focus-todos:")) {
          this.embedRenderer.render(text, block, ctx);
        }
      }
    });
    this.addCommand({
      id: "toggle-todo-sidebar",
      name: "Toggle TODO Sidebar",
      callback: () => {
        this.toggleSidebar();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "t"
        }
      ]
    });
    this.addCommand({
      id: "quick-add-todo",
      name: "Quick Add TODO",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        if (line.trim() === "") {
          editor.replaceRange("- [ ] #todo ", cursor);
          editor.setCursor({ line: cursor.line, ch: 6 });
        } else {
          const endOfLine = { line: cursor.line, ch: line.length };
          editor.replaceRange(" #todo", endOfLine);
        }
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "a"
        }
      ]
    });
    this.addCommand({
      id: "refresh-todos",
      name: "Refresh TODOs",
      callback: async () => {
        await this.scanner.scanVault();
        this.refreshSidebar();
      }
    });
    this.addRibbonIcon("checkbox-glyph", "Toggle TODO Sidebar", () => {
      this.toggleSidebar();
    });
    this.addSettingTab(new WeeklyLogHelpersSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateSidebar() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_TODO_SIDEBAR,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async toggleSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      await this.activateSidebar();
    }
  }
  refreshSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TODO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof TodoSidebarView) {
        view.render();
      }
    }
  }
};
var WeeklyLogHelpersSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Weekly Log Helpers Settings" });
    new import_obsidian5.Setting(containerEl).setName("Default TODONE file").setDesc("Default file path for logging completed TODOs").addText(
      (text) => text.setPlaceholder("todos/done.md").setValue(this.plugin.settings.defaultTodoneFile).onChange(async (value) => {
        this.plugin.settings.defaultTodoneFile = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Show sidebar by default").setDesc("Show the TODO sidebar when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSidebarByDefault).onChange(async (value) => {
        this.plugin.settings.showSidebarByDefault = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Date format").setDesc("Format for completion dates (using moment.js format)").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        this.plugin.settings.dateFormat = value;
        this.plugin.processor = new TodoProcessor(
          this.app,
          value
        );
        await this.plugin.saveSettings();
      })
    );
  }
};
