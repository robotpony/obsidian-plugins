/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HugoCommandPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/HugoScanner.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
var LOGO_PREFIX = "H\u2318";
function showNotice(message, timeout) {
  return new import_obsidian.Notice(`${LOGO_PREFIX} ${message}`, timeout);
}
function parseFrontmatter(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!match) {
    return null;
  }
  try {
    const yaml = (0, import_obsidian.parseYaml)(match[1]);
    if (typeof yaml !== "object" || yaml === null) {
      return null;
    }
    return yaml;
  } catch (e) {
    return null;
  }
}
function parseHugoDate(dateStr) {
  if (!dateStr) {
    return null;
  }
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) {
    return null;
  }
  return date;
}
function formatDate(date, format = "YYYY-MM-DD") {
  if (!date) {
    return "";
  }
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return format.replace("YYYY", String(year)).replace("MM", month).replace("DD", day);
}
function normalizeTags(tags) {
  if (!tags) {
    return [];
  }
  if (Array.isArray(tags)) {
    return tags.filter((t) => typeof t === "string").map((t) => String(t));
  }
  if (typeof tags === "string") {
    return [tags];
  }
  return [];
}
async function openFile(app, file) {
  const leaf = app.workspace.getLeaf(false);
  await leaf.openFile(file);
}
function getFolderFromPath(filePath) {
  const lastSlash = filePath.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  }
  return filePath.substring(0, lastSlash);
}
function getTitleFromItem(frontmatter, filePath) {
  if (frontmatter.title && typeof frontmatter.title === "string") {
    return frontmatter.title;
  }
  const lastSlash = filePath.lastIndexOf("/");
  const filename = lastSlash === -1 ? filePath : filePath.substring(lastSlash + 1);
  return filename.replace(/\.md$/, "");
}

// src/HugoScanner.ts
var HugoScanner = class extends import_obsidian2.Events {
  constructor(app, contentPaths) {
    super();
    this.contentCache = /* @__PURE__ */ new Map();
    this.app = app;
    this.contentPaths = contentPaths;
    this.debouncedScanFile = (0, import_obsidian2.debounce)(
      (file) => this.scanFile(file),
      100,
      true
    );
  }
  /**
   * Update content paths (called when settings change)
   */
  setContentPaths(paths) {
    this.contentPaths = paths;
  }
  /**
   * Check if a file path is within one of the configured content paths
   * Supports "." or "/" to mean the entire vault
   */
  isInContentPath(filePath) {
    if (this.contentPaths.length === 0) {
      return true;
    }
    return this.contentPaths.some((contentPath) => {
      const normalized = contentPath.trim().replace(/\/$/, "");
      if (normalized === "." || normalized === "/" || normalized === "") {
        return true;
      }
      return filePath.startsWith(normalized + "/") || filePath === normalized;
    });
  }
  /**
   * Scan all files in the vault that match content paths
   */
  async scanVault() {
    this.contentCache.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.isInContentPath(file.path)) {
        await this.scanFile(file);
      }
    }
    this.trigger("content-updated");
  }
  /**
   * Scan a single file and update the cache
   */
  async scanFile(file) {
    if (!this.isInContentPath(file.path)) {
      this.contentCache.delete(file.path);
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = parseFrontmatter(content);
      if (!frontmatter) {
        this.contentCache.delete(file.path);
        return;
      }
      const item = this.createContentItem(file, frontmatter);
      this.contentCache.set(file.path, item);
    } catch (e) {
      this.contentCache.delete(file.path);
    }
  }
  /**
   * Create a HugoContentItem from a file and its frontmatter
   */
  createContentItem(file, frontmatter) {
    const tags = normalizeTags(frontmatter.tags);
    const categories = normalizeTags(frontmatter.categories);
    return {
      file,
      filePath: file.path,
      folder: getFolderFromPath(file.path),
      frontmatter,
      title: getTitleFromItem(frontmatter, file.path),
      date: parseHugoDate(frontmatter.date),
      isDraft: frontmatter.draft === true,
      tags,
      categories,
      description: typeof frontmatter.description === "string" ? frontmatter.description : ""
    };
  }
  /**
   * Watch for file changes and update cache
   */
  watchFiles() {
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        this.contentCache.delete(file.path);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.contentCache.delete(oldPath);
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      }
    });
  }
  /**
   * Get all content items
   */
  getContent() {
    return Array.from(this.contentCache.values());
  }
  /**
   * Get content filtered by draft status
   */
  getContentByStatus(isDraft) {
    return this.getContent().filter((item) => item.isDraft === isDraft);
  }
  /**
   * Get content sorted by date (newest first by default)
   */
  getContentSorted(order = "date-desc") {
    const items = this.getContent();
    switch (order) {
      case "date-desc":
        return items.sort((a, b) => {
          if (!a.date && !b.date)
            return 0;
          if (!a.date)
            return 1;
          if (!b.date)
            return -1;
          return b.date.getTime() - a.date.getTime();
        });
      case "date-asc":
        return items.sort((a, b) => {
          if (!a.date && !b.date)
            return 0;
          if (!a.date)
            return 1;
          if (!b.date)
            return -1;
          return a.date.getTime() - b.date.getTime();
        });
      case "title":
        return items.sort((a, b) => a.title.localeCompare(b.title));
      default:
        return items;
    }
  }
  /**
   * Get all unique tags across all content
   */
  getAllTags() {
    const tagSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      for (const tag of item.tags) {
        tagSet.add(tag);
      }
      for (const cat of item.categories) {
        tagSet.add(cat);
      }
    }
    return Array.from(tagSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get content count
   */
  getCount() {
    const items = this.getContent();
    const drafts = items.filter((item) => item.isDraft).length;
    return {
      total: items.length,
      drafts,
      published: items.length - drafts
    };
  }
};

// src/SidebarView.ts
var import_obsidian3 = require("obsidian");
var VIEW_TYPE_HUGO_SIDEBAR = "hugo-command-sidebar";
var HugoSidebarView = class extends import_obsidian3.ItemView {
  constructor(leaf, scanner, settings, onShowAbout, onOpenSettings) {
    super(leaf);
    this.updateListener = null;
    this.activeTagFilter = null;
    this.activeStatusFilter = "all";
    this.openDropdown = null;
    this.scanner = scanner;
    this.settings = settings;
    this.onShowAbout = onShowAbout;
    this.onOpenSettings = onOpenSettings;
  }
  getViewType() {
    return VIEW_TYPE_HUGO_SIDEBAR;
  }
  getDisplayText() {
    return `${LOGO_PREFIX} Hugo`;
  }
  getIcon() {
    return "file-text";
  }
  async onOpen() {
    this.updateListener = () => this.render();
    this.scanner.on("content-updated", this.updateListener);
    const hasContent = this.scanner.getContent().length > 0;
    if (!hasContent) {
      await this.scanner.scanVault();
    } else {
      this.render();
    }
  }
  async onClose() {
    if (this.updateListener) {
      this.scanner.off("content-updated", this.updateListener);
      this.updateListener = null;
    }
    this.closeDropdown();
  }
  closeDropdown() {
    if (this.openDropdown) {
      this.openDropdown.remove();
      this.openDropdown = null;
    }
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("hugo-command-sidebar");
    this.renderHeader(container);
    this.renderFilters(container);
    this.renderContentList(container);
  }
  renderHeader(container) {
    const header = container.createEl("div", { cls: "hugo-command-header" });
    const logo = header.createEl("span", {
      cls: "hugo-command-logo clickable-logo",
      text: LOGO_PREFIX
    });
    logo.addEventListener("click", () => {
      this.onShowAbout();
    });
    header.createEl("span", {
      cls: "hugo-command-title",
      text: "Hugo Command"
    });
    const menuBtn = header.createEl("button", {
      cls: "clickable-icon hugo-command-menu-btn",
      attr: { "aria-label": "Menu" }
    });
    menuBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
    menuBtn.addEventListener("click", (evt) => {
      const menu = new import_obsidian3.Menu();
      menu.addItem((item) => {
        item.setTitle("Refresh").setIcon("refresh-cw").onClick(async () => {
          await this.scanner.scanVault();
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("About").setIcon("info").onClick(() => this.onShowAbout());
      });
      menu.addItem((item) => {
        item.setTitle("Settings").setIcon("settings").onClick(() => this.onOpenSettings());
      });
      menu.showAtMouseEvent(evt);
    });
  }
  renderFilters(container) {
    const filterBar = container.createEl("div", { cls: "hugo-command-filters" });
    const statusSelect = filterBar.createEl("select", {
      cls: "hugo-command-status-filter"
    });
    const statusOptions = [
      { value: "all", label: "All" },
      { value: "published", label: "Published" },
      { value: "draft", label: "Drafts" }
    ];
    for (const opt of statusOptions) {
      const option = statusSelect.createEl("option", {
        text: opt.label,
        value: opt.value
      });
      if (opt.value === this.activeStatusFilter) {
        option.selected = true;
      }
    }
    statusSelect.addEventListener("change", () => {
      this.activeStatusFilter = statusSelect.value;
      this.render();
    });
    const allTags = this.scanner.getAllTags();
    if (allTags.length > 0) {
      this.renderTagFilterButton(filterBar, allTags);
    }
    if (this.activeTagFilter) {
      const activeTag = filterBar.createEl("span", {
        cls: "hugo-command-active-tag",
        text: this.activeTagFilter
      });
      const clearBtn = activeTag.createEl("span", {
        cls: "hugo-command-clear-tag",
        text: "\xD7"
      });
      clearBtn.addEventListener("click", () => {
        this.activeTagFilter = null;
        this.render();
      });
    }
    const counts = this.scanner.getCount();
    filterBar.createEl("span", {
      cls: "hugo-command-count",
      text: `${counts.published} published, ${counts.drafts} drafts`
    });
  }
  renderTagFilterButton(container, allTags) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-tag-trigger",
      text: "#"
    });
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      dropdown.style.left = `${rect.left}px`;
      for (const tag of allTags) {
        const tagItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item",
          text: tag
        });
        if (tag === this.activeTagFilter) {
          tagItem.addClass("active");
        }
        tagItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = tag === this.activeTagFilter ? null : tag;
          this.closeDropdown();
          this.render();
        });
      }
      if (this.activeTagFilter) {
        dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        const clearItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item clear",
          text: "Clear filter"
        });
        clearItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = null;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderContentList(container) {
    const list = container.createEl("ul", { cls: "hugo-command-list" });
    let items = this.scanner.getContentSorted(this.settings.defaultSortOrder);
    if (this.activeStatusFilter === "draft") {
      items = items.filter((item) => item.isDraft);
    } else if (this.activeStatusFilter === "published") {
      items = items.filter((item) => !item.isDraft);
    }
    if (this.activeTagFilter) {
      items = items.filter(
        (item) => item.tags.includes(this.activeTagFilter) || item.categories.includes(this.activeTagFilter)
      );
    }
    if (!this.settings.showDrafts && this.activeStatusFilter === "all") {
      items = items.filter((item) => !item.isDraft);
    }
    if (items.length === 0) {
      list.createEl("li", {
        cls: "hugo-command-empty",
        text: "No content found"
      });
      return;
    }
    for (const item of items) {
      this.renderContentItem(list, item);
    }
  }
  renderContentItem(list, item) {
    const listItem = list.createEl("li", { cls: "hugo-command-item" });
    const badge = listItem.createEl("span", {
      cls: `hugo-command-badge ${item.isDraft ? "draft" : "published"}`,
      text: item.isDraft ? "D" : "P"
    });
    badge.setAttribute("aria-label", item.isDraft ? "Draft" : "Published");
    const title = listItem.createEl("span", {
      cls: "hugo-command-item-title",
      text: item.title
    });
    title.addEventListener("click", () => {
      openFile(this.app, item.file);
    });
    if (item.date) {
      listItem.createEl("span", {
        cls: "hugo-command-item-date",
        text: formatDate(item.date)
      });
    }
    const allItemTags = [...item.tags, ...item.categories];
    if (allItemTags.length > 0) {
      this.renderItemTagDropdown(listItem, allItemTags);
    }
  }
  renderItemTagDropdown(container, tags) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-item-tag-trigger",
      text: "#"
    });
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      const sidebarRoot = this.leaf.getRoot();
      const isRightSidebar = sidebarRoot === this.app.workspace.rightSplit;
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      if (isRightSidebar) {
        dropdown.style.right = `${window.innerWidth - rect.right}px`;
      } else {
        dropdown.style.left = `${rect.left}px`;
      }
      for (const tag of tags) {
        const tagItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item"
        });
        tagItem.createEl("span", {
          cls: "hugo-command-tag-label",
          text: tag
        });
        const filterBtn = tagItem.createEl("span", {
          cls: "hugo-command-tag-action",
          text: "Filter"
        });
        filterBtn.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = tag;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  /**
   * Update settings reference (called when settings change)
   */
  updateSettings(settings) {
    this.settings = settings;
    this.render();
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  contentPaths: ["."],
  showSidebarByDefault: true,
  showDrafts: true,
  defaultSortOrder: "date-desc"
};

// main.ts
var HugoCommandPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.scanner = new HugoScanner(this.app, this.settings.contentPaths);
    await this.scanner.scanVault();
    this.scanner.watchFiles();
    this.registerView(
      VIEW_TYPE_HUGO_SIDEBAR,
      (leaf) => new HugoSidebarView(
        leaf,
        this.scanner,
        this.settings,
        () => this.showAboutModal(),
        () => this.openSettings()
      )
    );
    if (this.settings.showSidebarByDefault) {
      this.app.workspace.onLayoutReady(() => {
        this.activateSidebar();
      });
    }
    this.addCommand({
      id: "toggle-hugo-sidebar",
      name: "Toggle Hugo Sidebar",
      callback: () => {
        this.toggleSidebar();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "h"
        }
      ]
    });
    this.addCommand({
      id: "refresh-hugo-content",
      name: "Refresh Hugo Content",
      callback: async () => {
        await this.scanner.scanVault();
        this.refreshSidebar();
        showNotice("Content refreshed");
      }
    });
    this.addRibbonIcon("file-text", "Toggle Hugo Sidebar", () => {
      this.toggleSidebar();
    });
    this.addSettingTab(new HugoCommandSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.scanner.setContentPaths(this.settings.contentPaths);
    await this.scanner.scanVault();
    this.updateSidebarSettings();
  }
  async activateSidebar() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_HUGO_SIDEBAR,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async toggleSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      await this.activateSidebar();
    }
  }
  refreshSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HugoSidebarView) {
        view.render();
      }
    }
  }
  updateSidebarSettings() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HugoSidebarView) {
        view.updateSettings(this.settings);
      }
    }
  }
  showAboutModal() {
    new AboutModal(this.app, this.manifest.version).open();
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("hugo-command");
  }
};
var AboutModal = class extends import_obsidian4.Modal {
  constructor(app, version) {
    super(app);
    this.version = version;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("hugo-command-about-modal");
    const header = contentEl.createEl("div", { cls: "about-header" });
    header.createEl("span", { cls: "hugo-command-logo about-logo", text: LOGO_PREFIX });
    header.createEl("h2", { text: "Hugo Command" });
    contentEl.createEl("p", { cls: "about-version", text: `Version ${this.version}` });
    contentEl.createEl("p", {
      cls: "about-blurb",
      text: "Manage and browse your Hugo content. View posts, drafts, and filter by tags."
    });
    const details = contentEl.createEl("div", { cls: "about-details" });
    details.createEl("p", { text: "Author: Bruce Alderson" });
    const repoLink = details.createEl("p");
    repoLink.appendText("Repository: ");
    repoLink.createEl("a", {
      text: "github.com/robotpony/obsidian-plugins",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var HugoCommandSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: `${LOGO_PREFIX} Hugo Command Settings` });
    const aboutSection = containerEl.createEl("div", { cls: "hugo-command-about-section" });
    const aboutHeader = aboutSection.createEl("div", { cls: "about-header" });
    aboutHeader.createEl("span", { cls: "hugo-command-logo about-logo", text: LOGO_PREFIX });
    aboutHeader.createEl("span", { cls: "about-title", text: "Hugo Command" });
    aboutSection.createEl("p", {
      cls: "about-blurb",
      text: "Manage and browse your Hugo content. View posts, drafts, and filter by tags."
    });
    aboutSection.createEl("p", { cls: "about-version", text: `Version ${this.plugin.manifest.version}` });
    const aboutDetails = aboutSection.createEl("div", { cls: "about-details" });
    aboutDetails.createEl("span", { text: "By Bruce Alderson" });
    aboutDetails.appendText(" \xB7 ");
    aboutDetails.createEl("a", {
      text: "GitHub",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
    new import_obsidian4.Setting(containerEl).setName("Content paths").setDesc("Folders to scan for Hugo content (one per line, e.g., content/posts)").addTextArea(
      (text) => text.setPlaceholder("content\ncontent/posts").setValue(this.plugin.settings.contentPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.contentPaths = value.split("\n").map((p) => p.trim()).filter((p) => p.length > 0);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show sidebar by default").setDesc("Show the Hugo sidebar when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSidebarByDefault).onChange(async (value) => {
        this.plugin.settings.showSidebarByDefault = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show drafts").setDesc("Include draft posts in the content list").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDrafts).onChange(async (value) => {
        this.plugin.settings.showDrafts = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default sort order").setDesc("How to sort content in the sidebar").addDropdown(
      (dropdown) => dropdown.addOption("date-desc", "Date (newest first)").addOption("date-asc", "Date (oldest first)").addOption("title", "Title (A-Z)").setValue(this.plugin.settings.defaultSortOrder).onChange(async (value) => {
        this.plugin.settings.defaultSortOrder = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
