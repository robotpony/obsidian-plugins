/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HugoCommandPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/HugoScanner.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
var LOGO_PREFIX = "H\u2318";
function showNotice(message, timeout) {
  return new import_obsidian.Notice(`${LOGO_PREFIX} ${message}`, timeout);
}
function parseFrontmatter(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!match) {
    return null;
  }
  try {
    const yaml = (0, import_obsidian.parseYaml)(match[1]);
    if (typeof yaml !== "object" || yaml === null) {
      return null;
    }
    return yaml;
  } catch (e) {
    return null;
  }
}
function parseHugoDate(dateStr) {
  if (!dateStr) {
    return null;
  }
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) {
    return null;
  }
  return date;
}
function formatDate(date) {
  if (!date) {
    return "";
  }
  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const month = months[date.getMonth()];
  const day = String(date.getDate()).padStart(2, "0");
  const year = date.getFullYear();
  return `${month}-${day}-${year}`;
}
function normalizeTags(tags) {
  if (!tags) {
    return [];
  }
  if (Array.isArray(tags)) {
    return tags.filter((t) => typeof t === "string").map((t) => String(t));
  }
  if (typeof tags === "string") {
    return [tags];
  }
  return [];
}
async function openFile(app, file) {
  const leaf = app.workspace.getLeaf(false);
  await leaf.openFile(file);
}
function getFolderFromPath(filePath) {
  const lastSlash = filePath.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  }
  return filePath.substring(0, lastSlash);
}
function getTitleFromItem(frontmatter, filePath) {
  if (frontmatter.title && typeof frontmatter.title === "string") {
    return frontmatter.title;
  }
  const lastSlash = filePath.lastIndexOf("/");
  const filename = lastSlash === -1 ? filePath : filePath.substring(lastSlash + 1);
  return filename.replace(/\.md$/, "");
}
function getRelativePath(filePath, contentPaths) {
  for (const contentPath of contentPaths) {
    const normalized = contentPath.trim().replace(/\/$/, "");
    if (normalized === "." || normalized === "/" || normalized === "") {
      return filePath;
    }
    if (filePath.startsWith(normalized + "/")) {
      return filePath.substring(normalized.length + 1);
    }
  }
  return filePath;
}
function getTopLevelFolder(filePath, contentPaths) {
  const relativePath = getRelativePath(filePath, contentPaths);
  const parts = relativePath.split("/");
  if (parts.length <= 1) {
    return "(root)";
  }
  return parts[0];
}
function getSubfolderTags(filePath, contentPaths) {
  const relativePath = getRelativePath(filePath, contentPaths);
  const parts = relativePath.split("/");
  if (parts.length <= 2) {
    return [];
  }
  return parts.slice(1, parts.length - 1);
}
function slugify(title) {
  return title.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-+|-+$/g, "");
}
function generateHugoFrontmatter(title) {
  const now = /* @__PURE__ */ new Date();
  const dateStr = now.toISOString();
  return `---
title: "${title}"
date: ${dateStr}
draft: true
tags: []
categories: []
description: ""
---

`;
}
var HUGO_CONFIG_FILES = [
  "hugo.toml",
  "hugo.yaml",
  "hugo.yml",
  "config.toml",
  "config.yaml",
  "config.yml"
];
async function findHugoConfigFile(app) {
  for (const filename of HUGO_CONFIG_FILES) {
    const file = app.vault.getAbstractFileByPath(filename);
    if (file instanceof import_obsidian.TFile) {
      return file;
    }
  }
  return null;
}
function getConfigFormat(filename) {
  if (filename.endsWith(".toml")) {
    return "toml";
  }
  return "yaml";
}
function parseToml(content) {
  const result = {};
  let currentSection = result;
  let currentSectionName = "";
  const lines = content.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) {
      continue;
    }
    const sectionMatch = trimmed.match(/^\[([^\]]+)\]$/);
    if (sectionMatch) {
      const sectionPath = sectionMatch[1].split(".");
      currentSectionName = sectionPath[0];
      currentSection = result;
      for (const part of sectionPath) {
        if (!currentSection[part]) {
          currentSection[part] = {};
        }
        currentSection = currentSection[part];
      }
      continue;
    }
    const kvMatch = trimmed.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)$/);
    if (kvMatch) {
      const key = kvMatch[1];
      const rawValue = kvMatch[2].trim();
      currentSection[key] = parseTomlValue(rawValue);
    }
  }
  return result;
}
function parseTomlValue(value) {
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1);
  }
  if (value.startsWith('"""') || value.startsWith("'''")) {
    const quote = value.substring(0, 3);
    const endIdx = value.indexOf(quote, 3);
    if (endIdx > 0) {
      return value.substring(3, endIdx);
    }
    return value.substring(3);
  }
  if (value === "true")
    return true;
  if (value === "false")
    return false;
  const num = Number(value);
  if (!isNaN(num)) {
    return num;
  }
  if (value.startsWith("[") && value.endsWith("]")) {
    const inner = value.slice(1, -1).trim();
    if (!inner)
      return [];
    return inner.split(",").map((v) => parseTomlValue(v.trim()));
  }
  return value;
}
function serializeToml(config) {
  const lines = [];
  for (const [key, value] of Object.entries(config)) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      lines.push(`${key} = ${tomlValue(value)}`);
    }
  }
  for (const [key, value] of Object.entries(config)) {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      lines.push("");
      lines.push(`[${key}]`);
      for (const [subKey, subValue] of Object.entries(value)) {
        if (typeof subValue !== "object" || subValue === null || Array.isArray(subValue)) {
          lines.push(`${subKey} = ${tomlValue(subValue)}`);
        }
      }
    }
  }
  return lines.join("\n") + "\n";
}
function tomlValue(value) {
  if (typeof value === "string") {
    return `"${value.replace(/"/g, '\\"')}"`;
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (typeof value === "number") {
    return String(value);
  }
  if (Array.isArray(value)) {
    return `[${value.map(tomlValue).join(", ")}]`;
  }
  return '""';
}
function parseHugoConfig(content, format) {
  if (format === "yaml") {
    try {
      const parsed = (0, import_obsidian.parseYaml)(content);
      return parsed || {};
    } catch (e) {
      return {};
    }
  }
  return parseToml(content);
}
function serializeHugoConfig(config, format) {
  if (format === "yaml") {
    return (0, import_obsidian.stringifyYaml)(config);
  }
  return serializeToml(config);
}

// src/HugoScanner.ts
var HugoScanner = class extends import_obsidian2.Events {
  constructor(app, contentPaths) {
    super();
    this.contentCache = /* @__PURE__ */ new Map();
    this.folderCache = /* @__PURE__ */ new Set();
    this.app = app;
    this.contentPaths = contentPaths;
    this.debouncedScanFile = (0, import_obsidian2.debounce)(
      (file) => this.scanFile(file),
      100,
      true
    );
  }
  /**
   * Update content paths (called when settings change)
   */
  setContentPaths(paths) {
    this.contentPaths = paths;
  }
  /**
   * Check if a file path is within one of the configured content paths
   * Supports "." or "/" to mean the entire vault
   */
  isInContentPath(filePath) {
    if (this.contentPaths.length === 0) {
      return true;
    }
    return this.contentPaths.some((contentPath) => {
      const normalized = contentPath.trim().replace(/\/$/, "");
      if (normalized === "." || normalized === "/" || normalized === "") {
        return true;
      }
      return filePath.startsWith(normalized + "/") || filePath === normalized;
    });
  }
  /**
   * Scan all files in the vault that match content paths
   */
  async scanVault() {
    this.contentCache.clear();
    this.folderCache.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.isInContentPath(file.path)) {
        await this.scanFile(file);
      }
    }
    this.scanFolders();
    this.trigger("content-updated");
  }
  /**
   * Scan all folders in the vault that match content paths
   */
  scanFolders() {
    const folders = this.app.vault.getAllFolders();
    for (const folder of folders) {
      if (this.isInContentPath(folder.path)) {
        this.folderCache.add(folder.path);
      }
    }
  }
  /**
   * Scan a single file and update the cache
   */
  async scanFile(file) {
    if (!this.isInContentPath(file.path)) {
      this.contentCache.delete(file.path);
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = parseFrontmatter(content);
      if (!frontmatter) {
        this.contentCache.delete(file.path);
        return;
      }
      const item = this.createContentItem(file, frontmatter);
      this.contentCache.set(file.path, item);
    } catch (e) {
      this.contentCache.delete(file.path);
    }
  }
  /**
   * Create a HugoContentItem from a file and its frontmatter
   */
  createContentItem(file, frontmatter) {
    const tags = normalizeTags(frontmatter.tags);
    const categories = normalizeTags(frontmatter.categories);
    return {
      file,
      filePath: file.path,
      folder: getFolderFromPath(file.path),
      frontmatter,
      title: getTitleFromItem(frontmatter, file.path),
      date: parseHugoDate(frontmatter.date),
      isDraft: frontmatter.draft === true,
      tags,
      categories,
      description: typeof frontmatter.description === "string" ? frontmatter.description : "",
      topLevelFolder: getTopLevelFolder(file.path, this.contentPaths),
      folderTags: getSubfolderTags(file.path, this.contentPaths)
    };
  }
  /**
   * Watch for file changes and update cache
   */
  watchFiles() {
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      } else if (file instanceof import_obsidian2.TFolder) {
        if (this.isInContentPath(file.path)) {
          this.folderCache.add(file.path);
          this.trigger("content-updated");
        }
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian2.TFile) {
        this.contentCache.delete(file.path);
        this.trigger("content-updated");
      } else if (file instanceof import_obsidian2.TFolder) {
        this.folderCache.delete(file.path);
        this.trigger("content-updated");
      }
    });
    this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian2.TFile && file.extension === "md") {
        this.contentCache.delete(oldPath);
        this.debouncedScanFile(file);
        this.trigger("content-updated");
      } else if (file instanceof import_obsidian2.TFolder) {
        this.folderCache.delete(oldPath);
        if (this.isInContentPath(file.path)) {
          this.folderCache.add(file.path);
        }
        this.trigger("content-updated");
      }
    });
  }
  /**
   * Get all content items
   */
  getContent() {
    return Array.from(this.contentCache.values());
  }
  /**
   * Get content filtered by draft status
   */
  getContentByStatus(isDraft) {
    return this.getContent().filter((item) => item.isDraft === isDraft);
  }
  /**
   * Get content sorted by date (newest first by default)
   */
  getContentSorted(order = "date-desc") {
    const items = this.getContent();
    switch (order) {
      case "date-desc":
        return items.sort((a, b) => {
          if (!a.date && !b.date)
            return 0;
          if (!a.date)
            return 1;
          if (!b.date)
            return -1;
          return b.date.getTime() - a.date.getTime();
        });
      case "date-asc":
        return items.sort((a, b) => {
          if (!a.date && !b.date)
            return 0;
          if (!a.date)
            return 1;
          if (!b.date)
            return -1;
          return a.date.getTime() - b.date.getTime();
        });
      case "title":
        return items.sort((a, b) => a.title.localeCompare(b.title));
      default:
        return items;
    }
  }
  /**
   * Get all unique tags across all content
   */
  getAllTags() {
    const tagSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      for (const tag of item.tags) {
        tagSet.add(tag);
      }
      for (const cat of item.categories) {
        tagSet.add(cat);
      }
    }
    return Array.from(tagSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get all unique folder tags across all content
   */
  getAllFolderTags() {
    const tagSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      for (const tag of item.folderTags) {
        tagSet.add(tag);
      }
    }
    return Array.from(tagSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get all unique folders (top-level + subfolder tags) for filtering
   */
  getAllFolders() {
    const folderSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      if (item.topLevelFolder !== "(root)") {
        folderSet.add(item.topLevelFolder);
      }
      for (const tag of item.folderTags) {
        folderSet.add(tag);
      }
    }
    return Array.from(folderSet).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get folder hierarchy as a flat list with depth for display
   * Returns folders with their full path and nesting depth
   * Merges folders derived from files with actual folders from the vault
   */
  getFolderHierarchy() {
    const pathSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      if (item.topLevelFolder === "(root)")
        continue;
      let currentPath = item.topLevelFolder;
      pathSet.add(currentPath);
      for (const subFolder of item.folderTags) {
        currentPath = `${currentPath}/${subFolder}`;
        pathSet.add(currentPath);
      }
    }
    for (const folderPath of this.folderCache) {
      pathSet.add(folderPath);
      const parts = folderPath.split("/");
      let currentPath = "";
      for (const part of parts) {
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        pathSet.add(currentPath);
      }
    }
    const paths = Array.from(pathSet).sort((a, b) => a.localeCompare(b));
    return paths.map((path) => {
      const parts = path.split("/");
      return {
        name: parts[parts.length - 1],
        // Just the folder name
        path,
        // Full path for filtering
        depth: parts.length - 1
        // 0 for top-level, 1 for first sublevel, etc.
      };
    });
  }
  /**
   * Get all unique top-level folders
   */
  getTopLevelFolders() {
    const folderSet = /* @__PURE__ */ new Set();
    for (const item of this.contentCache.values()) {
      folderSet.add(item.topLevelFolder);
    }
    return Array.from(folderSet).sort((a, b) => {
      if (a === "(root)")
        return 1;
      if (b === "(root)")
        return -1;
      return a.localeCompare(b);
    });
  }
  /**
   * Get content count
   */
  getCount() {
    const items = this.getContent();
    const drafts = items.filter((item) => item.isDraft).length;
    return {
      total: items.length,
      drafts,
      published: items.length - drafts
    };
  }
};

// src/SidebarView.ts
var import_obsidian3 = require("obsidian");
var VIEW_TYPE_HUGO_SIDEBAR = "hugo-command-sidebar";
var HugoSidebarView = class extends import_obsidian3.ItemView {
  constructor(leaf, scanner, settings, reviewCache, reviewClient, getStyleGuide, onShowAbout, onOpenSettings, onOpenSiteSettings) {
    super(leaf);
    this.updateListener = null;
    this.activeTagFilter = null;
    this.activeFolderTagFilter = null;
    this.searchQuery = "";
    this.openDropdown = null;
    this.openDropdownTrigger = null;
    this.openInfoPopup = null;
    this.scanner = scanner;
    this.settings = settings;
    this.reviewCache = reviewCache;
    this.reviewClient = reviewClient;
    this.getStyleGuide = getStyleGuide;
    this.activeStatusFilter = settings.defaultStatusFilter;
    this.onShowAbout = onShowAbout;
    this.onOpenSettings = onOpenSettings;
    this.onOpenSiteSettings = onOpenSiteSettings;
  }
  getViewType() {
    return VIEW_TYPE_HUGO_SIDEBAR;
  }
  getDisplayText() {
    return "Hugo";
  }
  getIcon() {
    return "file-text";
  }
  async onOpen() {
    this.updateListener = () => this.render();
    this.scanner.on("content-updated", this.updateListener);
    const hasContent = this.scanner.getContent().length > 0;
    if (!hasContent) {
      await this.scanner.scanVault();
    } else {
      this.render();
    }
  }
  async onClose() {
    if (this.updateListener) {
      this.scanner.off("content-updated", this.updateListener);
      this.updateListener = null;
    }
    this.closeDropdown();
    this.closeInfoPopup();
  }
  closeDropdown() {
    if (this.openDropdown) {
      this.openDropdown.remove();
      this.openDropdown = null;
    }
    this.openDropdownTrigger = null;
  }
  closeInfoPopup() {
    if (this.openInfoPopup) {
      this.openInfoPopup.remove();
      this.openInfoPopup = null;
    }
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("hugo-command-sidebar");
    this.renderHeader(container);
    const content = container.createEl("div", { cls: "hugo-command-content" });
    this.renderFilters(content);
    this.renderContentList(content);
  }
  renderHeader(container) {
    const header = container.createEl("div", { cls: "hugo-command-header" });
    const titleEl = header.createEl("div", { cls: "hugo-command-header-title" });
    const logo = titleEl.createEl("span", {
      cls: "hugo-command-logo clickable-logo",
      text: LOGO_PREFIX
    });
    logo.addEventListener("click", () => {
      this.onShowAbout();
    });
    titleEl.createEl("h4", { text: "Hugo" });
    const buttonGroup = header.createEl("div", { cls: "hugo-command-button-group" });
    const newBtn = buttonGroup.createEl("button", {
      cls: "clickable-icon hugo-command-new-btn",
      attr: { "aria-label": "New post" }
    });
    newBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
    newBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.showNewPostDropdown(newBtn);
    });
    const menuBtn = buttonGroup.createEl("button", {
      cls: "clickable-icon hugo-command-menu-btn",
      attr: { "aria-label": "Menu" }
    });
    menuBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
    menuBtn.addEventListener("click", (evt) => {
      const menu = new import_obsidian3.Menu();
      menu.addItem((item) => {
        item.setTitle("Site Settings").setIcon("globe").onClick(() => this.onOpenSiteSettings());
      });
      menu.addItem((item) => {
        item.setTitle("Refresh").setIcon("refresh-cw").onClick(async () => {
          await this.scanner.scanVault();
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("About").setIcon("info").onClick(() => this.onShowAbout());
      });
      menu.addItem((item) => {
        item.setTitle("Settings").setIcon("settings").onClick(() => this.onOpenSettings());
      });
      menu.showAtMouseEvent(evt);
    });
  }
  renderFilters(container) {
    const filterBar = container.createEl("div", { cls: "hugo-command-filters" });
    filterBar.createEl("span", {
      cls: "hugo-command-filter-prefix",
      text: ""
    });
    const folderHierarchy = this.scanner.getFolderHierarchy();
    if (folderHierarchy.length > 0) {
      this.renderFolderFilterButton(filterBar, folderHierarchy);
    }
    const allTags = this.scanner.getAllTags();
    if (allTags.length > 0) {
      this.renderTagFilterButton(filterBar, allTags);
    }
    const statusSelect = filterBar.createEl("select", {
      cls: "hugo-command-status-filter"
    });
    const statusOptions = [
      { value: "all", label: "All" },
      { value: "published", label: "Published" },
      { value: "draft", label: "Drafts" }
    ];
    for (const opt of statusOptions) {
      const option = statusSelect.createEl("option", {
        text: opt.label,
        value: opt.value
      });
      if (opt.value === this.activeStatusFilter) {
        option.selected = true;
      }
    }
    statusSelect.addEventListener("change", () => {
      this.activeStatusFilter = statusSelect.value;
      this.render();
    });
    this.renderSearchField(filterBar);
    const counts = this.scanner.getCount();
    const infoIcon = filterBar.createEl("span", {
      cls: "hugo-command-info-icon",
      text: "\u24D8",
      attr: { "aria-label": "Content stats" }
    });
    infoIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeInfoPopup();
      this.closeDropdown();
      const popup = document.createElement("div");
      popup.className = "hugo-command-info-popup";
      const rect = infoIcon.getBoundingClientRect();
      popup.style.position = "fixed";
      popup.style.top = `${rect.bottom + 4}px`;
      popup.style.right = `${window.innerWidth - rect.right}px`;
      popup.createEl("div", {
        cls: "hugo-command-info-row",
        text: `${counts.published} published`
      });
      popup.createEl("div", {
        cls: "hugo-command-info-row",
        text: `${counts.drafts} drafts`
      });
      popup.createEl("div", {
        cls: "hugo-command-info-row total",
        text: `${counts.total} total`
      });
      document.body.appendChild(popup);
      this.openInfoPopup = popup;
      const closeHandler = (e2) => {
        if (!popup.contains(e2.target) && e2.target !== infoIcon) {
          this.closeInfoPopup();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderSearchField(container) {
    const searchContainer = container.createEl("div", {
      cls: "hugo-command-search-container"
    });
    if (this.activeFolderTagFilter) {
      const chip = searchContainer.createEl("span", {
        cls: "hugo-command-search-chip folder-chip"
      });
      chip.createEl("span", { text: this.activeFolderTagFilter });
      const clearBtn = chip.createEl("span", {
        cls: "hugo-command-search-chip-clear",
        text: "\xD7"
      });
      clearBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.activeFolderTagFilter = null;
        this.render();
      });
    }
    if (this.activeTagFilter) {
      const chip = searchContainer.createEl("span", {
        cls: "hugo-command-search-chip"
      });
      chip.createEl("span", { text: this.activeTagFilter });
      const clearBtn = chip.createEl("span", {
        cls: "hugo-command-search-chip-clear",
        text: "\xD7"
      });
      clearBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.activeTagFilter = null;
        this.render();
      });
    }
    const searchInput = searchContainer.createEl("input", {
      cls: "hugo-command-search-input",
      attr: {
        type: "text",
        placeholder: "Search..."
      }
    });
    searchInput.value = this.searchQuery;
    searchInput.addEventListener("input", () => {
      this.searchQuery = searchInput.value;
      this.render();
    });
    if (this.searchQuery) {
      setTimeout(() => {
        searchInput.focus();
        searchInput.setSelectionRange(searchInput.value.length, searchInput.value.length);
      }, 0);
    }
    const hasFilters = this.activeTagFilter || this.activeFolderTagFilter || this.searchQuery;
    if (hasFilters) {
      const clearAll = searchContainer.createEl("span", {
        cls: "hugo-command-search-clear",
        text: "\xD7"
      });
      clearAll.addEventListener("click", (e) => {
        e.stopPropagation();
        this.activeTagFilter = null;
        this.activeFolderTagFilter = null;
        this.searchQuery = "";
        this.render();
      });
    }
  }
  renderTagFilterButton(container, allTags) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-filter-trigger"
    });
    trigger.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg><span>Tags</span>';
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      dropdown.style.left = `${rect.left}px`;
      for (const tag of allTags) {
        const tagItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item",
          text: tag
        });
        if (tag === this.activeTagFilter) {
          tagItem.addClass("active");
        }
        tagItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = tag === this.activeTagFilter ? null : tag;
          this.closeDropdown();
          this.render();
        });
      }
      if (this.activeTagFilter) {
        dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        const clearItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item clear",
          text: "Clear filter"
        });
        clearItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeTagFilter = null;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderFolderFilterButton(container, folderHierarchy) {
    const trigger = container.createEl("span", {
      cls: "hugo-command-filter-trigger"
    });
    trigger.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><span>Folder</span>';
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      dropdown.style.left = `${rect.left}px`;
      for (const folder of folderHierarchy) {
        const depthClass = `folder-depth-${Math.min(folder.depth, 4)}`;
        const folderItem = dropdown.createEl("div", {
          cls: `hugo-command-tag-item folder-tag ${depthClass}`,
          text: folder.name
        });
        if (folder.path === this.activeFolderTagFilter) {
          folderItem.addClass("active");
        }
        folderItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeFolderTagFilter = folder.path === this.activeFolderTagFilter ? null : folder.path;
          this.closeDropdown();
          this.render();
        });
      }
      if (this.activeFolderTagFilter) {
        dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        const clearItem = dropdown.createEl("div", {
          cls: "hugo-command-tag-item clear",
          text: "Clear filter"
        });
        clearItem.addEventListener("click", (e2) => {
          e2.stopPropagation();
          this.activeFolderTagFilter = null;
          this.closeDropdown();
          this.render();
        });
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  renderContentList(container) {
    let items = this.scanner.getContentSorted(this.settings.defaultSortOrder);
    if (this.activeStatusFilter === "draft") {
      items = items.filter((item) => item.isDraft);
    } else if (this.activeStatusFilter === "published") {
      items = items.filter((item) => !item.isDraft);
    }
    if (this.activeTagFilter) {
      items = items.filter(
        (item) => item.tags.includes(this.activeTagFilter) || item.categories.includes(this.activeTagFilter)
      );
    }
    if (this.activeFolderTagFilter) {
      items = items.filter((item) => {
        const itemPath = item.topLevelFolder === "(root)" ? "" : item.folderTags.length > 0 ? `${item.topLevelFolder}/${item.folderTags.join("/")}` : item.topLevelFolder;
        return itemPath === this.activeFolderTagFilter || itemPath.startsWith(this.activeFolderTagFilter + "/");
      });
    }
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase().trim();
      items = items.filter((item) => {
        if (item.title.toLowerCase().includes(query))
          return true;
        if (item.tags.some((tag) => tag.toLowerCase().includes(query)))
          return true;
        if (item.categories.some((cat) => cat.toLowerCase().includes(query)))
          return true;
        if (item.description && item.description.toLowerCase().includes(query))
          return true;
        return false;
      });
    }
    if (!this.settings.showDrafts && this.activeStatusFilter === "all") {
      items = items.filter((item) => !item.isDraft);
    }
    if (items.length === 0) {
      const emptyDiv = container.createEl("div", {
        cls: "hugo-command-empty",
        text: "No content found"
      });
      return;
    }
    const folders = this.scanner.getTopLevelFolders();
    const groupedItems = /* @__PURE__ */ new Map();
    for (const folder of folders) {
      groupedItems.set(folder, []);
    }
    for (const item of items) {
      const folderItems = groupedItems.get(item.topLevelFolder);
      if (folderItems) {
        folderItems.push(item);
      }
    }
    for (const folder of folders) {
      const folderItems = groupedItems.get(folder) || [];
      if (folderItems.length === 0)
        continue;
      this.renderFolderGroup(container, folder, folderItems);
    }
  }
  renderFolderGroup(container, folder, items) {
    const group = container.createEl("div", { cls: "hugo-command-folder-group" });
    const header = group.createEl("div", {
      cls: "hugo-command-folder-header static"
    });
    header.createEl("span", {
      cls: "hugo-command-folder-name",
      text: folder
    });
    const list = group.createEl("ul", { cls: "hugo-command-list" });
    for (const item of items) {
      this.renderContentItem(list, item);
    }
  }
  renderContentItem(list, item) {
    const listItem = list.createEl("li", { cls: "hugo-command-item" });
    const badge = listItem.createEl("span", {
      cls: `hugo-command-badge ${item.isDraft ? "draft" : "published"}`,
      text: item.isDraft ? "D" : "P"
    });
    badge.setAttribute("aria-label", item.isDraft ? "Draft" : "Published");
    const title = listItem.createEl("span", {
      cls: "hugo-command-item-title",
      text: item.title
    });
    title.addEventListener("click", () => {
      openFile(this.app, item.file);
    });
    if (item.folderTags.length > 0) {
      const subfolderChip = listItem.createEl("span", {
        cls: "hugo-command-subfolder-chip",
        text: item.folderTags.join("/")
      });
    }
    const frontmatterTags = [...item.tags, ...item.categories];
    const folderTags = item.folderTags;
    this.renderItemInfoDropdown(listItem, item, frontmatterTags, folderTags);
  }
  renderItemInfoDropdown(container, item, frontmatterTags, folderTags) {
    const date = item.date;
    const trigger = container.createEl("span", {
      cls: "hugo-command-item-info-trigger",
      text: "\u24D8"
    });
    trigger.addEventListener("click", (e) => {
      e.stopPropagation();
      if (this.openDropdownTrigger === trigger) {
        this.closeDropdown();
        return;
      }
      this.closeDropdown();
      const dropdown = document.createElement("div");
      dropdown.className = "hugo-command-tag-dropdown";
      const rect = trigger.getBoundingClientRect();
      const sidebarRoot = this.leaf.getRoot();
      const isRightSidebar = sidebarRoot === this.app.workspace.rightSplit;
      dropdown.style.position = "fixed";
      dropdown.style.top = `${rect.bottom + 4}px`;
      if (isRightSidebar) {
        dropdown.style.right = `${window.innerWidth - rect.right}px`;
      } else {
        dropdown.style.left = `${rect.left}px`;
      }
      const headerSection = dropdown.createEl("div", {
        cls: "hugo-command-info-header"
      });
      headerSection.createEl("div", {
        cls: "hugo-command-info-title",
        text: item.title
      });
      const metaParts = [];
      if (date) {
        metaParts.push(formatDate(date));
      }
      if (folderTags.length > 0) {
        metaParts.push(folderTags.join("/"));
      }
      if (metaParts.length > 0) {
        headerSection.createEl("div", {
          cls: "hugo-command-info-meta",
          text: metaParts.join(" \xB7 ")
        });
      }
      if (frontmatterTags.length > 0) {
        if (date || folderTags.length > 0) {
          dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
        }
        dropdown.createEl("div", {
          cls: "hugo-command-tag-section-header",
          text: "Tags"
        });
        for (const tag of frontmatterTags) {
          const tagItem = dropdown.createEl("div", {
            cls: "hugo-command-tag-item"
          });
          tagItem.createEl("span", {
            cls: "hugo-command-tag-label",
            text: tag
          });
          const filterBtn = tagItem.createEl("span", {
            cls: "hugo-command-tag-action",
            text: "Filter"
          });
          filterBtn.addEventListener("click", (e2) => {
            e2.stopPropagation();
            this.activeTagFilter = tag;
            this.closeDropdown();
            this.render();
          });
        }
      }
      if (this.settings.review.enabled) {
        this.renderReviewSection(dropdown, item);
      }
      document.body.appendChild(dropdown);
      this.openDropdown = dropdown;
      this.openDropdownTrigger = trigger;
      const closeHandler = (e2) => {
        if (!dropdown.contains(e2.target) && e2.target !== trigger) {
          this.closeDropdown();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
    });
  }
  /**
   * Render review section in item info dropdown
   */
  renderReviewSection(dropdown, item) {
    dropdown.createEl("div", { cls: "hugo-command-tag-separator" });
    dropdown.createEl("div", {
      cls: "hugo-command-tag-section-header",
      text: "Review"
    });
    const cachedReview = this.reviewCache.get(item.filePath);
    const reviewContainer = dropdown.createEl("div", {
      cls: "hugo-command-review-container"
    });
    if (cachedReview && !cachedReview.error) {
      this.renderReviewResults(reviewContainer, cachedReview);
    } else if (cachedReview == null ? void 0 : cachedReview.error) {
      reviewContainer.createEl("div", {
        cls: "hugo-command-review-error",
        text: cachedReview.error
      });
    }
    const buttonText = cachedReview ? "Review post again" : "Review post";
    const runBtn = dropdown.createEl("div", {
      cls: "hugo-command-review-btn",
      text: buttonText
    });
    runBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      runBtn.textContent = "Reading post";
      runBtn.addClass("loading");
      reviewContainer.empty();
      const loadingEl = reviewContainer.createEl("div", {
        cls: "hugo-command-review-loading"
      });
      loadingEl.createEl("span", { cls: "hugo-command-review-spinner" });
      loadingEl.createSpan({ text: "Reading post..." });
      try {
        const content = await this.app.vault.read(item.file);
        const styleGuide = await this.getStyleGuide();
        const criteria = await this.reviewClient.review(content, styleGuide);
        const result = {
          filePath: item.filePath,
          criteria,
          timestamp: Date.now()
        };
        this.reviewCache.set(result);
        reviewContainer.empty();
        this.renderReviewResults(reviewContainer, result);
        runBtn.textContent = "Review post again";
        runBtn.removeClass("loading");
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : "Review failed";
        const result = {
          filePath: item.filePath,
          criteria: [],
          timestamp: Date.now(),
          error: errorMsg
        };
        this.reviewCache.set(result);
        reviewContainer.empty();
        reviewContainer.createEl("div", {
          cls: "hugo-command-review-error",
          text: errorMsg
        });
        runBtn.textContent = "Retry";
        runBtn.removeClass("loading");
      }
    });
  }
  /**
   * Render review results checklist
   */
  renderReviewResults(container, result) {
    const total = result.criteria.length;
    const passed = result.criteria.filter((c) => c.passed === true).length;
    const failed = result.criteria.filter((c) => c.passed === false).length;
    if (total > 0) {
      const scoreEl = container.createEl("div", { cls: "hugo-command-review-score" });
      const scoreClass = failed === 0 ? "all-passed" : failed <= total / 2 ? "some-failed" : "many-failed";
      scoreEl.addClass(scoreClass);
      scoreEl.setText(`${passed}/${total} passed`);
    }
    const list = container.createEl("div", { cls: "hugo-command-review-list" });
    for (const criterion of result.criteria) {
      const item = list.createEl("div", { cls: "hugo-command-review-item" });
      let statusIcon;
      let statusClass;
      if (criterion.passed === true) {
        statusIcon = "\u2713";
        statusClass = "passed";
      } else if (criterion.passed === false) {
        statusIcon = "\u2717";
        statusClass = "failed";
      } else {
        statusIcon = "\u2014";
        statusClass = "unknown";
      }
      item.createEl("span", {
        cls: `hugo-command-review-status ${statusClass}`,
        text: statusIcon
      });
      const textEl = item.createEl("span", {
        cls: "hugo-command-review-text",
        text: criterion.text
      });
      if (criterion.note) {
        textEl.setAttribute("title", criterion.note);
      }
    }
    const timestamp = new Date(result.timestamp);
    container.createEl("div", {
      cls: "hugo-command-review-timestamp",
      text: `Reviewed ${this.formatTimeAgo(timestamp)}`
    });
  }
  /**
   * Format a date as relative time (e.g., "2 hours ago")
   */
  formatTimeAgo(date) {
    const seconds = Math.floor((Date.now() - date.getTime()) / 1e3);
    if (seconds < 60)
      return "just now";
    if (seconds < 3600)
      return `${Math.floor(seconds / 60)}m ago`;
    if (seconds < 86400)
      return `${Math.floor(seconds / 3600)}h ago`;
    return `${Math.floor(seconds / 86400)}d ago`;
  }
  /**
   * Update settings reference (called when settings change)
   */
  updateSettings(settings) {
    this.settings = settings;
    this.render();
  }
  /**
   * Get the primary content root folder from settings
   * Returns empty string if set to "." or "/" (vault root)
   */
  getContentRoot() {
    const contentPaths = this.settings.contentPaths;
    if (!contentPaths || contentPaths.length === 0) {
      return "";
    }
    const first = contentPaths[0].trim().replace(/\/$/, "");
    if (first === "." || first === "/" || first === "") {
      return "";
    }
    return first;
  }
  /**
   * Show dropdown for selecting folder to create new post
   */
  showNewPostDropdown(trigger) {
    this.closeDropdown();
    this.closeInfoPopup();
    const dropdown = document.createElement("div");
    dropdown.className = "hugo-command-tag-dropdown";
    const rect = trigger.getBoundingClientRect();
    dropdown.style.position = "fixed";
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.right = `${window.innerWidth - rect.right}px`;
    dropdown.createEl("div", {
      cls: "hugo-command-tag-section-header",
      text: "Create in folder"
    });
    const folderHierarchy = this.scanner.getFolderHierarchy();
    const contentRoot = this.getContentRoot();
    const rootItem = dropdown.createEl("div", {
      cls: "hugo-command-tag-item",
      text: `(${contentRoot || "root"})`
    });
    rootItem.addEventListener("click", (e) => {
      e.stopPropagation();
      this.closeDropdown();
      this.promptForNewPost(contentRoot);
    });
    for (const folder of folderHierarchy) {
      const depthClass = `folder-depth-${Math.min(folder.depth, 4)}`;
      const folderItem = dropdown.createEl("div", {
        cls: `hugo-command-tag-item folder-tag ${depthClass}`,
        text: folder.name
      });
      const fullPath = contentRoot ? `${contentRoot}/${folder.path}` : folder.path;
      folderItem.addEventListener("click", (e) => {
        e.stopPropagation();
        this.closeDropdown();
        this.promptForNewPost(fullPath);
      });
    }
    document.body.appendChild(dropdown);
    this.openDropdown = dropdown;
    const closeHandler = (e) => {
      if (!dropdown.contains(e.target) && e.target !== trigger) {
        this.closeDropdown();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  /**
   * Prompt user for title and create new post
   */
  promptForNewPost(folderPath) {
    const modal = new TitlePromptModal(this.app, async (title) => {
      if (!title.trim()) {
        showNotice("Title cannot be empty");
        return;
      }
      await this.createNewPost(folderPath, title.trim());
    });
    modal.open();
  }
  /**
   * Create a new post with Hugo frontmatter
   */
  async createNewPost(folderPath, title) {
    const filename = slugify(title) || "untitled";
    const fullPath = folderPath ? `${folderPath}/${filename}.md` : `${filename}.md`;
    const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
    if (existingFile) {
      showNotice(`File already exists: ${fullPath}`);
      return;
    }
    if (folderPath) {
      const folderExists = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folderExists) {
        await this.app.vault.createFolder(folderPath);
      }
    }
    const content = generateHugoFrontmatter(title);
    const newFile = await this.app.vault.create(fullPath, content);
    showNotice(`Created: ${fullPath}`);
    await openFile(this.app, newFile);
    await this.scanner.scanVault();
  }
};
var TitlePromptModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.inputEl = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("hugo-command-title-modal");
    contentEl.createEl("h3", { text: "New Post" });
    const inputContainer = contentEl.createEl("div", {
      cls: "hugo-command-title-input-container"
    });
    this.inputEl = inputContainer.createEl("input", {
      cls: "hugo-command-title-input",
      attr: {
        type: "text",
        placeholder: "Enter post title..."
      }
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.submit();
      }
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "hugo-command-title-buttons"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const createBtn = buttonContainer.createEl("button", {
      cls: "mod-cta",
      text: "Create"
    });
    createBtn.addEventListener("click", () => {
      this.submit();
    });
    setTimeout(() => {
      var _a;
      return (_a = this.inputEl) == null ? void 0 : _a.focus();
    }, 10);
  }
  submit() {
    var _a;
    const title = ((_a = this.inputEl) == null ? void 0 : _a.value) || "";
    this.close();
    this.onSubmit(title);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/types.ts
var DEFAULT_OUTLINE_SETTINGS = {
  enabled: false,
  prompt: `Analyze this blog post outline/draft and enhance it by:
1. Adding inline questions as HTML comments (<!-- Q: question here -->) where more detail or examples would help
2. Suggesting missing sections that would strengthen the piece
3. Noting any structural improvements
4. If a style guide is provided, flag specific places where the writing doesn't follow the guidelines, citing the relevant rule

Keep the original content intact. Add your suggestions as HTML comments so they're invisible when rendered.`
};
var DEFAULT_REVIEW_SETTINGS = {
  enabled: false,
  provider: "ollama",
  ollamaEndpoint: "http://localhost:11434",
  ollamaModel: "llama3.2",
  openaiApiKey: "",
  openaiModel: "gpt-4o-mini",
  geminiApiKey: "",
  geminiModel: "gemini-1.5-flash",
  anthropicApiKey: "",
  anthropicModel: "claude-3-haiku-20240307",
  criteria: "Has a clear, descriptive title\nIncludes an introduction\nHas a conclusion or summary\nUses proper headings structure\nIncludes relevant tags",
  styleGuideFile: "",
  styleGuideInline: ""
};
var DEFAULT_SETTINGS = {
  contentPaths: ["content"],
  trashFolder: "_trash",
  showSidebarByDefault: true,
  showDrafts: true,
  defaultSortOrder: "date-desc",
  defaultStatusFilter: "draft",
  review: DEFAULT_REVIEW_SETTINGS,
  outline: DEFAULT_OUTLINE_SETTINGS
};

// src/SiteSettingsModal.ts
var import_obsidian4 = require("obsidian");
var SiteSettingsModal = class extends import_obsidian4.Modal {
  constructor(app) {
    super(app);
    this.config = {};
    this.configFile = null;
    this.format = "toml";
    this.hasChanges = false;
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("hugo-command-site-settings");
    modalEl.addClass("hugo-command-site-settings-modal");
    this.configFile = await findHugoConfigFile(this.app);
    if (!this.configFile) {
      this.renderNoConfigFound(contentEl);
      return;
    }
    this.format = getConfigFormat(this.configFile.name);
    const content = await this.app.vault.read(this.configFile);
    this.config = parseHugoConfig(content, this.format);
    this.renderSettings(contentEl);
  }
  renderNoConfigFound(container) {
    const header = container.createEl("div", { cls: "site-settings-header" });
    header.createEl("span", { cls: "hugo-command-logo", text: LOGO_PREFIX });
    header.createEl("h2", { text: "Site Settings" });
    container.createEl("p", {
      cls: "site-settings-error",
      text: "No Hugo config file found. Create hugo.toml or config.toml in the vault root."
    });
  }
  renderSettings(container) {
    var _a;
    const headerSection = container.createEl("div", { cls: "site-settings-header-section" });
    const header = headerSection.createEl("div", { cls: "site-settings-header" });
    header.createEl("span", { cls: "hugo-command-logo", text: LOGO_PREFIX });
    header.createEl("h2", { text: "Site Settings" });
    const titleDisplay = headerSection.createEl("div", { cls: "site-settings-title-display" });
    const siteTitle = this.config.title || "Untitled Site";
    titleDisplay.createEl("span", { cls: "site-title-label", text: "Site:" });
    titleDisplay.createEl("span", { cls: "site-title-value", text: siteTitle });
    const scrollArea = container.createEl("div", { cls: "site-settings-scroll-area" });
    scrollArea.createEl("h3", { text: "Basic Settings" });
    new import_obsidian4.Setting(scrollArea).setName("Site title").setDesc("The title of your Hugo site").addText(
      (text) => text.setPlaceholder("My Hugo Site").setValue(this.config.title || "").onChange((value) => {
        this.config.title = value;
        this.hasChanges = true;
        const titleValue = container.querySelector(".site-title-value");
        if (titleValue) {
          titleValue.textContent = value || "Untitled Site";
        }
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Base URL").setDesc("The base URL for your site (e.g., https://example.com/)").addText(
      (text) => text.setPlaceholder("https://example.com/").setValue(this.config.baseURL || "").onChange((value) => {
        this.config.baseURL = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Language code").setDesc("The language code for your site (e.g., en-us)").addText(
      (text) => text.setPlaceholder("en-us").setValue(this.config.languageCode || "").onChange((value) => {
        this.config.languageCode = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Summary length").setDesc("Number of words in auto-generated summaries").addText(
      (text) => text.setPlaceholder("70").setValue(String(this.config.summaryLength || "")).onChange((value) => {
        const num = parseInt(value, 10);
        this.config.summaryLength = isNaN(num) ? void 0 : num;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Paginate").setDesc("Number of items per page in list pages").addText(
      (text) => text.setPlaceholder("10").setValue(String(this.config.paginate || "")).onChange((value) => {
        const num = parseInt(value, 10);
        this.config.paginate = isNaN(num) ? void 0 : num;
        this.hasChanges = true;
      })
    );
    scrollArea.createEl("h3", { text: "Author & Copyright" });
    new import_obsidian4.Setting(scrollArea).setName("Author").setDesc("Site author name").addText(
      (text) => text.setPlaceholder("Your Name").setValue(this.config.author || "").onChange((value) => {
        this.config.author = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Copyright").setDesc("Copyright notice for your site").addText(
      (text) => text.setPlaceholder("Copyright 2024").setValue(this.config.copyright || "").onChange((value) => {
        this.config.copyright = value;
        this.hasChanges = true;
      })
    );
    scrollArea.createEl("h3", { text: "Theme" });
    new import_obsidian4.Setting(scrollArea).setName("Theme").setDesc("The Hugo theme to use").addText(
      (text) => text.setPlaceholder("theme-name").setValue(this.config.theme || "").onChange((value) => {
        this.config.theme = value;
        this.hasChanges = true;
      })
    );
    scrollArea.createEl("h3", { text: "Build Settings" });
    new import_obsidian4.Setting(scrollArea).setName("Build drafts").setDesc("Include draft content when building").addToggle(
      (toggle) => toggle.setValue(Boolean(this.config.buildDrafts)).onChange((value) => {
        this.config.buildDrafts = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Build future").setDesc("Include content with future publish dates").addToggle(
      (toggle) => toggle.setValue(Boolean(this.config.buildFuture)).onChange((value) => {
        this.config.buildFuture = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Build expired").setDesc("Include expired content").addToggle(
      (toggle) => toggle.setValue(Boolean(this.config.buildExpired)).onChange((value) => {
        this.config.buildExpired = value;
        this.hasChanges = true;
      })
    );
    scrollArea.createEl("h3", { text: "Features" });
    new import_obsidian4.Setting(scrollArea).setName("Enable robots.txt").setDesc("Generate robots.txt file").addToggle(
      (toggle) => toggle.setValue(Boolean(this.config.enableRobotsTXT)).onChange((value) => {
        this.config.enableRobotsTXT = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Enable Git info").setDesc("Use Git for .Lastmod and other metadata").addToggle(
      (toggle) => toggle.setValue(Boolean(this.config.enableGitInfo)).onChange((value) => {
        this.config.enableGitInfo = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Disable kinds").setDesc("Page kinds to disable (comma-separated: taxonomy, term, RSS, sitemap)").addText(
      (text) => text.setPlaceholder("taxonomy, term").setValue(Array.isArray(this.config.disableKinds) ? this.config.disableKinds.join(", ") : "").onChange((value) => {
        this.config.disableKinds = value.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
        this.hasChanges = true;
      })
    );
    scrollArea.createEl("h3", { text: "Taxonomies" });
    const taxonomies = this.config.taxonomies || {};
    new import_obsidian4.Setting(scrollArea).setName("Category taxonomy").setDesc("Plural name for category taxonomy").addText(
      (text) => text.setPlaceholder("categories").setValue(taxonomies.category || "").onChange((value) => {
        if (!this.config.taxonomies)
          this.config.taxonomies = {};
        this.config.taxonomies.category = value;
        this.hasChanges = true;
      })
    );
    new import_obsidian4.Setting(scrollArea).setName("Tag taxonomy").setDesc("Plural name for tag taxonomy").addText(
      (text) => text.setPlaceholder("tags").setValue(taxonomies.tag || "").onChange((value) => {
        if (!this.config.taxonomies)
          this.config.taxonomies = {};
        this.config.taxonomies.tag = value;
        this.hasChanges = true;
      })
    );
    scrollArea.createEl("h3", { text: "Permalinks" });
    const permalinks = this.config.permalinks || {};
    new import_obsidian4.Setting(scrollArea).setName("Posts permalink").setDesc("URL structure for posts (e.g., /:year/:month/:slug/)").addText(
      (text) => text.setPlaceholder("/:year/:month/:slug/").setValue(permalinks.posts || permalinks.post || "").onChange((value) => {
        if (!this.config.permalinks)
          this.config.permalinks = {};
        this.config.permalinks.posts = value;
        this.hasChanges = true;
      })
    );
    const params = this.config.params;
    if (params && Object.keys(params).length > 0) {
      scrollArea.createEl("h3", { text: "Site Parameters" });
      for (const [key, value] of Object.entries(params)) {
        this.renderParamSetting(scrollArea, key, value);
      }
    }
    const footerSection = container.createEl("div", { cls: "site-settings-footer-section" });
    const fileInfo = footerSection.createEl("div", {
      cls: "site-settings-file-info clickable"
    });
    fileInfo.createEl("span", { text: "Config: " });
    const fileLink = fileInfo.createEl("span", {
      cls: "site-settings-file-link",
      text: ((_a = this.configFile) == null ? void 0 : _a.name) || ""
    });
    fileLink.addEventListener("click", async () => {
      if (this.configFile) {
        const leaf = this.app.workspace.getLeaf(false);
        await leaf.openFile(this.configFile);
        this.close();
      }
    });
    const buttonContainer = footerSection.createEl("div", { cls: "site-settings-buttons" });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const saveBtn = buttonContainer.createEl("button", {
      cls: "mod-cta",
      text: "Save"
    });
    saveBtn.addEventListener("click", async () => {
      await this.saveConfig();
    });
  }
  renderParamSetting(container, key, value) {
    const displayName = key.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()).trim();
    if (typeof value === "boolean") {
      new import_obsidian4.Setting(container).setName(displayName).setDesc(`params.${key}`).addToggle(
        (toggle) => toggle.setValue(value).onChange((newValue) => {
          if (!this.config.params)
            this.config.params = {};
          this.config.params[key] = newValue;
          this.hasChanges = true;
        })
      );
    } else if (typeof value === "number") {
      new import_obsidian4.Setting(container).setName(displayName).setDesc(`params.${key}`).addText(
        (text) => text.setValue(String(value)).onChange((newValue) => {
          if (!this.config.params)
            this.config.params = {};
          const num = Number(newValue);
          this.config.params[key] = isNaN(num) ? newValue : num;
          this.hasChanges = true;
        })
      );
    } else if (typeof value === "string") {
      new import_obsidian4.Setting(container).setName(displayName).setDesc(`params.${key}`).addText(
        (text) => text.setValue(value).onChange((newValue) => {
          if (!this.config.params)
            this.config.params = {};
          this.config.params[key] = newValue;
          this.hasChanges = true;
        })
      );
    }
  }
  async saveConfig() {
    if (!this.configFile) {
      showNotice("No config file to save");
      return;
    }
    try {
      const content = serializeHugoConfig(this.config, this.format);
      await this.app.vault.modify(this.configFile, content);
      showNotice("Site settings saved");
      this.hasChanges = false;
      this.close();
    } catch (error) {
      showNotice("Failed to save settings");
      console.error("Failed to save Hugo config:", error);
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ReviewCache.ts
var ReviewCache = class {
  constructor(onSave) {
    this.cache = /* @__PURE__ */ new Map();
    this.onSave = onSave;
  }
  /**
   * Load cache from persisted data.
   */
  load(data) {
    this.cache.clear();
    if (data) {
      for (const [key, value] of Object.entries(data)) {
        this.cache.set(key, value);
      }
    }
  }
  /**
   * Get cached review result for a file.
   */
  get(filePath) {
    return this.cache.get(filePath);
  }
  /**
   * Store review result for a file.
   */
  set(result) {
    this.cache.set(result.filePath, result);
    this.persist();
  }
  /**
   * Clear cached result for a file.
   */
  clear(filePath) {
    this.cache.delete(filePath);
    this.persist();
  }
  /**
   * Clear all cached results.
   */
  clearAll() {
    this.cache.clear();
    this.persist();
  }
  /**
   * Get all cached results.
   */
  getAll() {
    return Array.from(this.cache.values());
  }
  /**
   * Persist cache to plugin data.
   */
  persist() {
    const data = {};
    for (const [key, value] of this.cache.entries()) {
      data[key] = value;
    }
    this.onSave(data);
  }
  /**
   * Export cache data for saving.
   */
  export() {
    const data = {};
    for (const [key, value] of this.cache.entries()) {
      data[key] = value;
    }
    return data;
  }
};

// src/ReviewLLMClient.ts
var import_obsidian5 = require("obsidian");
var ReviewLLMClient = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Run a review of the content against the criteria.
   * Returns structured results for each criterion.
   */
  async review(content, styleGuide) {
    const criteria = this.parseCriteria();
    if (criteria.length === 0) {
      return [];
    }
    const prompt = this.buildPrompt(content, styleGuide, criteria);
    try {
      const response = await this.callLLM(prompt);
      return this.parseResponse(response, criteria);
    } catch (error) {
      console.error("[Hugo Review] LLM call failed:", error);
      throw error;
    }
  }
  parseCriteria() {
    return this.settings.criteria.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
  }
  buildPrompt(content, styleGuide, criteria) {
    const criteriaList = criteria.map((c, i) => `${i + 1}. ${c}`).join("\n");
    let styleSection = "";
    if (styleGuide.trim()) {
      styleSection = `
## Style Guidelines

${styleGuide}

`;
    }
    return `You are a content reviewer. Review the following blog post against the checklist criteria.
${styleSection}
## Review Criteria

${criteriaList}

## Content to Review

${content}

## Instructions

For each criterion, determine if the content passes (true), fails (false), or is not applicable (null).
Provide a brief note explaining your assessment.

Respond with ONLY a JSON array in this exact format, with one object per criterion in order:
[
  {"passed": true, "note": "Brief explanation"},
  {"passed": false, "note": "Brief explanation"},
  ...
]

Do not include any other text, just the JSON array.`;
  }
  async callLLM(prompt) {
    switch (this.settings.provider) {
      case "ollama":
        return this.callOllama(prompt);
      case "openai":
        return this.callOpenAI(prompt);
      case "gemini":
        return this.callGemini(prompt);
      case "anthropic":
        return this.callAnthropic(prompt);
      default:
        throw new Error(`Unknown provider: ${this.settings.provider}`);
    }
  }
  async callOllama(prompt) {
    const response = await (0, import_obsidian5.requestUrl)({
      url: `${this.settings.ollamaEndpoint}/api/generate`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: this.settings.ollamaModel,
        prompt,
        stream: false,
        format: "json"
      })
    });
    if (response.status !== 200) {
      throw new Error(`Ollama error: ${response.status}`);
    }
    return response.json.response;
  }
  async callOpenAI(prompt) {
    if (!this.settings.openaiApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const response = await (0, import_obsidian5.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.settings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.settings.openaiModel,
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenAI error: ${response.status}`);
    }
    return response.json.choices[0].message.content;
  }
  async callGemini(prompt) {
    if (!this.settings.geminiApiKey) {
      throw new Error("Gemini API key not configured");
    }
    const response = await (0, import_obsidian5.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/${this.settings.geminiModel}:generateContent?key=${this.settings.geminiApiKey}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
          responseMimeType: "application/json"
        }
      })
    });
    if (response.status !== 200) {
      throw new Error(`Gemini error: ${response.status}`);
    }
    return response.json.candidates[0].content.parts[0].text;
  }
  async callAnthropic(prompt) {
    if (!this.settings.anthropicApiKey) {
      throw new Error("Anthropic API key not configured");
    }
    const response = await (0, import_obsidian5.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.settings.anthropicModel,
        max_tokens: 1024,
        messages: [{ role: "user", content: prompt }]
      })
    });
    if (response.status !== 200) {
      throw new Error(`Anthropic error: ${response.status}`);
    }
    return response.json.content[0].text;
  }
  parseResponse(response, criteria) {
    try {
      let jsonStr = response.trim();
      const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1].trim();
      }
      const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
      if (arrayMatch) {
        jsonStr = arrayMatch[0];
      }
      const results = JSON.parse(jsonStr);
      if (!Array.isArray(results)) {
        throw new Error("Response is not an array");
      }
      return criteria.map((text, i) => {
        const result = results[i] || { passed: null, note: "No response" };
        return {
          text,
          passed: result.passed,
          note: result.note || ""
        };
      });
    } catch (error) {
      console.error("[Hugo Review] Failed to parse LLM response:", error);
      return criteria.map((text) => ({
        text,
        passed: null,
        note: "Failed to parse review response"
      }));
    }
  }
};

// src/OutlineLLMClient.ts
var import_obsidian6 = require("obsidian");
var OutlineLLMClient = class {
  constructor(reviewSettings, outlineSettings) {
    this.reviewSettings = reviewSettings;
    this.outlineSettings = outlineSettings;
  }
  updateSettings(reviewSettings, outlineSettings) {
    this.reviewSettings = reviewSettings;
    this.outlineSettings = outlineSettings;
  }
  /**
   * Enhance a document outline with questions and suggestions.
   * Returns the modified markdown content.
   */
  async enhance(content, styleGuide) {
    const prompt = this.buildPrompt(content, styleGuide);
    try {
      const response = await this.callLLM(prompt);
      return this.extractMarkdown(response);
    } catch (error) {
      console.error("[Hugo Outline] LLM call failed:", error);
      throw error;
    }
  }
  buildPrompt(content, styleGuide) {
    let styleSection = "";
    if (styleGuide.trim()) {
      styleSection = `
## Style Guidelines

${styleGuide}

`;
    }
    const hasStyleGuide = styleGuide.trim().length > 0;
    const styleInstructions = hasStyleGuide ? `When the content doesn't follow a style guide rule, cite the specific rule in your comment (e.g., "<!-- Style: 'Avoid corporate jargon' - consider replacing 'leverage' with 'use' -->").` : "";
    return `${this.outlineSettings.prompt}
${styleSection}
## Document to Enhance

${content}

## Instructions

Return the enhanced document as markdown. Keep all original content intact.
Add your questions and suggestions as HTML comments (<!-- Q: question here --> for questions, <!-- suggestion here --> for suggestions).
${styleInstructions}
Return ONLY the enhanced markdown, no explanations or preamble.`;
  }
  async callLLM(prompt) {
    switch (this.reviewSettings.provider) {
      case "ollama":
        return this.callOllama(prompt);
      case "openai":
        return this.callOpenAI(prompt);
      case "gemini":
        return this.callGemini(prompt);
      case "anthropic":
        return this.callAnthropic(prompt);
      default:
        throw new Error(`Unknown provider: ${this.reviewSettings.provider}`);
    }
  }
  async callOllama(prompt) {
    const response = await (0, import_obsidian6.requestUrl)({
      url: `${this.reviewSettings.ollamaEndpoint}/api/generate`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: this.reviewSettings.ollamaModel,
        prompt,
        stream: false
      })
    });
    if (response.status !== 200) {
      throw new Error(`Ollama error: ${response.status}`);
    }
    return response.json.response;
  }
  async callOpenAI(prompt) {
    if (!this.reviewSettings.openaiApiKey) {
      throw new Error("OpenAI API key not configured");
    }
    const response = await (0, import_obsidian6.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.reviewSettings.openaiApiKey}`
      },
      body: JSON.stringify({
        model: this.reviewSettings.openaiModel,
        messages: [{ role: "user", content: prompt }]
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenAI error: ${response.status}`);
    }
    return response.json.choices[0].message.content;
  }
  async callGemini(prompt) {
    if (!this.reviewSettings.geminiApiKey) {
      throw new Error("Gemini API key not configured");
    }
    const response = await (0, import_obsidian6.requestUrl)({
      url: `https://generativelanguage.googleapis.com/v1beta/models/${this.reviewSettings.geminiModel}:generateContent?key=${this.reviewSettings.geminiApiKey}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }]
      })
    });
    if (response.status !== 200) {
      throw new Error(`Gemini error: ${response.status}`);
    }
    return response.json.candidates[0].content.parts[0].text;
  }
  async callAnthropic(prompt) {
    if (!this.reviewSettings.anthropicApiKey) {
      throw new Error("Anthropic API key not configured");
    }
    const response = await (0, import_obsidian6.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.reviewSettings.anthropicApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.reviewSettings.anthropicModel,
        max_tokens: 4096,
        messages: [{ role: "user", content: prompt }]
      })
    });
    if (response.status !== 200) {
      throw new Error(`Anthropic error: ${response.status}`);
    }
    return response.json.content[0].text;
  }
  /**
   * Extract markdown from the response, handling code blocks if present.
   */
  extractMarkdown(response) {
    let content = response.trim();
    const codeBlockMatch = content.match(/^```(?:markdown|md)?\s*\n([\s\S]*?)\n```$/);
    if (codeBlockMatch) {
      content = codeBlockMatch[1];
    }
    return content;
  }
};

// src/CommentBubbles.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var CommentBubbleWidget = class extends import_view.WidgetType {
  constructor(content, commentType) {
    super();
    this.content = content;
    this.commentType = commentType;
  }
  toDOM() {
    const bubble = document.createElement("span");
    bubble.className = `hugo-comment-bubble ${this.commentType}`;
    const icon = document.createElement("span");
    icon.className = "hugo-comment-icon";
    switch (this.commentType) {
      case "question":
        icon.textContent = "?";
        break;
      case "style":
        icon.textContent = "\u{1F4DD}";
        break;
      default:
        icon.textContent = "\u{1F4A1}";
    }
    bubble.appendChild(icon);
    const text = document.createElement("span");
    text.className = "hugo-comment-text";
    text.textContent = this.content;
    bubble.appendChild(text);
    return bubble;
  }
  eq(other) {
    return other.content === this.content && other.commentType === this.commentType;
  }
  ignoreEvent() {
    return false;
  }
};
var hideDecoration = import_view.Decoration.replace({});
function getCommentType(prefix, content) {
  if (prefix == null ? void 0 : prefix.startsWith("Q:"))
    return "question";
  if ((prefix == null ? void 0 : prefix.startsWith("Style:")) || content.toLowerCase().startsWith("style:"))
    return "style";
  return "suggestion";
}
function buildDecorations(view) {
  const builder = new import_state.RangeSetBuilder();
  const doc = view.state.doc;
  const text = doc.toString();
  const commentRegex = /<!--\s*(Q:\s*|Style:\s*)?(.+?)\s*-->/gs;
  let match;
  while ((match = commentRegex.exec(text)) !== null) {
    const prefix = match[1];
    const content = match[2].trim();
    const commentType = getCommentType(prefix, content);
    const from = match.index;
    const to = match.index + match[0].length;
    const line = doc.lineAt(from);
    const lineText = line.text;
    const commentStartInLine = from - line.from;
    const beforeComment = lineText.substring(0, commentStartInLine).trim();
    const afterComment = lineText.substring(commentStartInLine + match[0].length).trim();
    const isStandalone = !beforeComment && !afterComment;
    if (isStandalone) {
      builder.add(from, to, import_view.Decoration.replace({
        widget: new CommentBubbleWidget(content, commentType)
      }));
    } else {
      builder.add(from, to, hideDecoration);
      builder.add(to, to, import_view.Decoration.widget({
        widget: new CommentBubbleWidget(content, commentType),
        side: 1
        // After the position
      }));
    }
  }
  return builder.finish();
}
var commentBubblesPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = buildDecorations(update.view);
      }
    }
  },
  {
    decorations: (v) => v.decorations
  }
);

// main.ts
var HugoCommandPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.reviewCacheData = {};
    this.isEnhancingOutline = false;
  }
  async onload() {
    await this.loadSettings();
    this.scanner = new HugoScanner(this.app, this.settings.contentPaths);
    this.reviewCache = new ReviewCache((data) => {
      this.reviewCacheData = data;
      this.saveData({ ...this.settings, _reviewCache: data });
    });
    this.reviewCache.load(this.reviewCacheData);
    this.reviewClient = new ReviewLLMClient(this.settings.review);
    this.outlineClient = new OutlineLLMClient(this.settings.review, this.settings.outline);
    await this.scanner.scanVault();
    this.scanner.watchFiles();
    this.registerView(
      VIEW_TYPE_HUGO_SIDEBAR,
      (leaf) => new HugoSidebarView(
        leaf,
        this.scanner,
        this.settings,
        this.reviewCache,
        this.reviewClient,
        () => this.getStyleGuide(),
        () => this.showAboutModal(),
        () => this.openSettings(),
        () => this.showSiteSettings()
      )
    );
    if (this.settings.showSidebarByDefault) {
      this.app.workspace.onLayoutReady(() => {
        this.activateSidebar();
      });
    }
    this.addCommand({
      id: "toggle-hugo-sidebar",
      name: "Toggle Hugo Sidebar",
      callback: () => {
        this.toggleSidebar();
      },
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "h"
        }
      ]
    });
    this.addCommand({
      id: "refresh-hugo-content",
      name: "Refresh Hugo Content",
      callback: async () => {
        await this.scanner.scanVault();
        this.refreshSidebar();
        showNotice("Content refreshed");
      }
    });
    this.addRibbonIcon("file-text", "Toggle Hugo Sidebar", () => {
      this.toggleSidebar();
    });
    if (this.settings.outline.enabled) {
      this.registerEditorExtension(commentBubblesPlugin);
    }
    this.addCommand({
      id: "enhance-outline",
      name: "Enhance Outline with Suggestions",
      editorCallback: async (editor, view) => {
        if (!this.settings.outline.enabled) {
          new import_obsidian7.Notice("Outline enhancement is not enabled in settings");
          return;
        }
        await this.enhanceCurrentOutline();
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!this.settings.outline.enabled)
          return;
        if (!(file instanceof import_obsidian7.TFile) || file.extension !== "md")
          return;
        menu.addItem((item) => {
          item.setTitle("Enhance outline").setIcon("sparkles").onClick(async () => {
            const leaf = this.app.workspace.getLeaf();
            await leaf.openFile(file);
            await this.enhanceCurrentOutline();
          });
        });
      })
    );
    this.addSettingTab(new HugoCommandSettingTab(this.app, this));
  }
  /**
   * Enhance the current document outline using LLM
   */
  async enhanceCurrentOutline() {
    if (this.isEnhancingOutline) {
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian7.Notice("No file is currently open");
      return;
    }
    if (activeFile.extension !== "md") {
      new import_obsidian7.Notice("Outline enhancement only works on markdown files");
      return;
    }
    this.isEnhancingOutline = true;
    new import_obsidian7.Notice("Enhancing outline...");
    try {
      const content = await this.app.vault.read(activeFile);
      const styleGuide = await this.getStyleGuide();
      const enhanced = await this.outlineClient.enhance(content, styleGuide);
      await this.app.vault.modify(activeFile, enhanced);
      new import_obsidian7.Notice("Outline enhanced with suggestions");
    } catch (error) {
      const msg = error instanceof Error ? error.message : "Enhancement failed";
      new import_obsidian7.Notice(`Error: ${msg}`);
      console.error("[Hugo Outline] Enhancement failed:", error);
    } finally {
      this.isEnhancingOutline = false;
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
  }
  async loadSettings() {
    const data = await this.loadData();
    const { _reviewCache, ...settingsData } = data || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, settingsData);
    if (!this.settings.review) {
      this.settings.review = DEFAULT_REVIEW_SETTINGS;
    }
    if (!this.settings.outline) {
      this.settings.outline = DEFAULT_OUTLINE_SETTINGS;
    }
    this.reviewCacheData = _reviewCache || {};
  }
  async saveSettings() {
    await this.saveData({ ...this.settings, _reviewCache: this.reviewCacheData });
    this.scanner.setContentPaths(this.settings.contentPaths);
    this.reviewClient.updateSettings(this.settings.review);
    this.outlineClient.updateSettings(this.settings.review, this.settings.outline);
    await this.scanner.scanVault();
    this.updateSidebarSettings();
  }
  async activateSidebar() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_HUGO_SIDEBAR,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async toggleSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      await this.activateSidebar();
    }
  }
  refreshSidebar() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HugoSidebarView) {
        view.render();
      }
    }
  }
  updateSidebarSettings() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_HUGO_SIDEBAR);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HugoSidebarView) {
        view.updateSettings(this.settings);
      }
    }
  }
  showAboutModal() {
    new AboutModal(this.app, this.manifest.version).open();
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("hugo-command");
  }
  showSiteSettings() {
    new SiteSettingsModal(this.app).open();
  }
  /**
   * Get the combined style guide content from file and inline settings.
   */
  async getStyleGuide() {
    const parts = [];
    if (this.settings.review.styleGuideFile) {
      const file = this.app.vault.getAbstractFileByPath(this.settings.review.styleGuideFile);
      if (file instanceof import_obsidian7.TFile) {
        try {
          const content = await this.app.vault.read(file);
          parts.push(content);
        } catch (error) {
          console.error("[Hugo Review] Failed to read style guide file:", error);
        }
      }
    }
    if (this.settings.review.styleGuideInline) {
      parts.push(this.settings.review.styleGuideInline);
    }
    return parts.join("\n\n");
  }
};
var AboutModal = class extends import_obsidian7.Modal {
  constructor(app, version) {
    super(app);
    this.version = version;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("hugo-command-about-modal");
    const header = contentEl.createEl("div", { cls: "about-header" });
    header.createEl("span", { cls: "hugo-command-logo about-logo", text: LOGO_PREFIX });
    header.createEl("h2", { text: "Hugo Command" });
    contentEl.createEl("p", { cls: "about-version", text: `Version ${this.version}` });
    contentEl.createEl("p", {
      cls: "about-blurb",
      text: "Manage and browse your Hugo content. View posts, drafts, and filter by tags."
    });
    const details = contentEl.createEl("div", { cls: "about-details" });
    details.createEl("p", { text: "Author: Bruce Alderson" });
    const repoLink = details.createEl("p");
    repoLink.appendText("Repository: ");
    repoLink.createEl("a", {
      text: "github.com/robotpony/obsidian-plugins",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
    details.createEl("p", { text: "Made in \u{1F1E8}\u{1F1E6}", cls: "about-made-in" });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var HugoCommandSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Hugo Command Settings" });
    const aboutSection = containerEl.createEl("div", { cls: "hugo-command-about-section" });
    const aboutHeader = aboutSection.createEl("div", { cls: "about-header" });
    aboutHeader.createEl("span", { cls: "hugo-command-logo about-logo", text: LOGO_PREFIX });
    aboutHeader.createEl("span", { cls: "about-title", text: "Hugo Command" });
    aboutSection.createEl("p", {
      cls: "about-blurb",
      text: "Manage and browse your Hugo content. View posts, drafts, and filter by tags."
    });
    aboutSection.createEl("p", { cls: "about-version", text: `Version ${this.plugin.manifest.version}` });
    const aboutDetails = aboutSection.createEl("div", { cls: "about-details" });
    aboutDetails.createEl("span", { text: "By Bruce Alderson" });
    aboutDetails.appendText(" \xB7 ");
    aboutDetails.createEl("a", {
      text: "GitHub",
      href: "https://github.com/robotpony/obsidian-plugins"
    });
    containerEl.createEl("h3", { text: "Sidebar" });
    new import_obsidian7.Setting(containerEl).setName("Show sidebar by default").setDesc("Show the Hugo sidebar when Obsidian starts").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSidebarByDefault).onChange(async (value) => {
        this.plugin.settings.showSidebarByDefault = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Default status filter").setDesc("Which posts to show by default when opening the sidebar").addDropdown(
      (dropdown) => dropdown.addOption("all", "All").addOption("published", "Published").addOption("draft", "Drafts").setValue(this.plugin.settings.defaultStatusFilter).onChange(async (value) => {
        this.plugin.settings.defaultStatusFilter = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Default sort order").setDesc("How to sort content in the sidebar").addDropdown(
      (dropdown) => dropdown.addOption("date-desc", "Date (newest first)").addOption("date-asc", "Date (oldest first)").addOption("title", "Title (A-Z)").setValue(this.plugin.settings.defaultSortOrder).onChange(async (value) => {
        this.plugin.settings.defaultSortOrder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Show drafts").setDesc("Include draft posts in the content list").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDrafts).onChange(async (value) => {
        this.plugin.settings.showDrafts = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Content" });
    new import_obsidian7.Setting(containerEl).setName("Content paths").setDesc("Folders to scan for Hugo content (one per line, e.g., content/posts)").addTextArea(
      (text) => text.setPlaceholder("content\ncontent/posts").setValue(this.plugin.settings.contentPaths.join("\n")).onChange(async (value) => {
        this.plugin.settings.contentPaths = value.split("\n").map((p) => p.trim()).filter((p) => p.length > 0);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian7.Setting(containerEl).setName("Trash folder").setDesc("Folder for trashed posts (relative to vault root)").addText(
      (text) => text.setPlaceholder("_trash").setValue(this.plugin.settings.trashFolder).onChange(async (value) => {
        this.plugin.settings.trashFolder = value.trim() || "_trash";
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Content Review" });
    new import_obsidian7.Setting(containerEl).setName("Enable content review").setDesc("Use an LLM to review posts against a checklist of criteria").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.review.enabled).onChange(async (value) => {
        this.plugin.settings.review.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.review.enabled) {
      new import_obsidian7.Setting(containerEl).setName("LLM provider").setDesc("Which LLM service to use for reviews").addDropdown(
        (dropdown) => dropdown.addOption("ollama", "Ollama (local)").addOption("openai", "OpenAI").addOption("gemini", "Google Gemini").addOption("anthropic", "Anthropic Claude").setValue(this.plugin.settings.review.provider).onChange(async (value) => {
          this.plugin.settings.review.provider = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
      const provider = this.plugin.settings.review.provider;
      if (provider === "ollama") {
        new import_obsidian7.Setting(containerEl).setName("Ollama endpoint").setDesc("URL of your Ollama server").addText(
          (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.review.ollamaEndpoint).onChange(async (value) => {
            this.plugin.settings.review.ollamaEndpoint = value.trim() || "http://localhost:11434";
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian7.Setting(containerEl).setName("Ollama model").setDesc("Model to use (e.g., llama3.2, mistral)").addText(
          (text) => text.setPlaceholder("llama3.2").setValue(this.plugin.settings.review.ollamaModel).onChange(async (value) => {
            this.plugin.settings.review.ollamaModel = value.trim() || "llama3.2";
            await this.plugin.saveSettings();
          })
        );
      } else if (provider === "openai") {
        new import_obsidian7.Setting(containerEl).setName("OpenAI API key").setDesc("Your OpenAI API key").addText(
          (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.review.openaiApiKey).onChange(async (value) => {
            this.plugin.settings.review.openaiApiKey = value.trim();
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian7.Setting(containerEl).setName("OpenAI model").setDesc("Model to use (e.g., gpt-4o-mini, gpt-4o)").addText(
          (text) => text.setPlaceholder("gpt-4o-mini").setValue(this.plugin.settings.review.openaiModel).onChange(async (value) => {
            this.plugin.settings.review.openaiModel = value.trim() || "gpt-4o-mini";
            await this.plugin.saveSettings();
          })
        );
      } else if (provider === "gemini") {
        new import_obsidian7.Setting(containerEl).setName("Gemini API key").setDesc("Your Google AI Studio API key").addText(
          (text) => text.setPlaceholder("AI...").setValue(this.plugin.settings.review.geminiApiKey).onChange(async (value) => {
            this.plugin.settings.review.geminiApiKey = value.trim();
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian7.Setting(containerEl).setName("Gemini model").setDesc("Model to use (e.g., gemini-1.5-flash, gemini-1.5-pro)").addText(
          (text) => text.setPlaceholder("gemini-1.5-flash").setValue(this.plugin.settings.review.geminiModel).onChange(async (value) => {
            this.plugin.settings.review.geminiModel = value.trim() || "gemini-1.5-flash";
            await this.plugin.saveSettings();
          })
        );
      } else if (provider === "anthropic") {
        new import_obsidian7.Setting(containerEl).setName("Anthropic API key").setDesc("Your Anthropic API key").addText(
          (text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.review.anthropicApiKey).onChange(async (value) => {
            this.plugin.settings.review.anthropicApiKey = value.trim();
            await this.plugin.saveSettings();
          })
        );
        new import_obsidian7.Setting(containerEl).setName("Anthropic model").setDesc("Model to use (e.g., claude-3-haiku-20240307)").addText(
          (text) => text.setPlaceholder("claude-3-haiku-20240307").setValue(this.plugin.settings.review.anthropicModel).onChange(async (value) => {
            this.plugin.settings.review.anthropicModel = value.trim() || "claude-3-haiku-20240307";
            await this.plugin.saveSettings();
          })
        );
      }
      new import_obsidian7.Setting(containerEl).setName("Review criteria").setDesc("Checklist items to evaluate (one per line)").addTextArea(
        (text) => text.setPlaceholder("Has a clear title\nIncludes an introduction\nHas a conclusion").setValue(this.plugin.settings.review.criteria).onChange(async (value) => {
          this.plugin.settings.review.criteria = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian7.Setting(containerEl).setName("Style guide file").setDesc("Path to a markdown file containing style guidelines (optional)").addText(
        (text) => text.setPlaceholder("Resources/Style Guide.md").setValue(this.plugin.settings.review.styleGuideFile).onChange(async (value) => {
          this.plugin.settings.review.styleGuideFile = value.trim();
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian7.Setting(containerEl).setName("Inline style guidelines").setDesc("Additional style guidelines (combined with file if both specified)").addTextArea(
        (text) => text.setPlaceholder("Write in active voice. Keep paragraphs short.").setValue(this.plugin.settings.review.styleGuideInline).onChange(async (value) => {
          this.plugin.settings.review.styleGuideInline = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian7.Setting(containerEl).setName("Clear review cache").setDesc("Remove all cached review results").addButton(
        (button) => button.setButtonText("Clear Cache").onClick(async () => {
          this.plugin.reviewCache.clearAll();
          showNotice("Review cache cleared");
        })
      );
    }
    containerEl.createEl("h3", { text: "Outline Enhancement" });
    new import_obsidian7.Setting(containerEl).setName("Enable outline enhancement").setDesc("Use an LLM to add questions and suggestions to document outlines (uses same LLM settings as Content Review)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.outline.enabled).onChange(async (value) => {
        this.plugin.settings.outline.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.outline.enabled) {
      new import_obsidian7.Setting(containerEl).setName("Enhancement prompt").setDesc("Instructions for the LLM when enhancing outlines").addTextArea(
        (text) => text.setPlaceholder("Analyze this outline and add questions...").setValue(this.plugin.settings.outline.prompt).onChange(async (value) => {
          this.plugin.settings.outline.prompt = value;
          await this.plugin.saveSettings();
        })
      );
    }
  }
};
